var xh = Object.defineProperty, vh = Object.defineProperties;
var yh = Object.getOwnPropertyDescriptors;
var Ms = Object.getOwnPropertySymbols;
var Pn = Object.prototype.hasOwnProperty, Mn = Object.prototype.propertyIsEnumerable;
var In = (e, t, s) => t in e ? xh(e, t, {enumerable: !0, configurable: !0, writable: !0, value: s}) : e[t] = s,
    Yt = (e, t) => {
        for (var s in t || (t = {})) Pn.call(t, s) && In(e, s, t[s]);
        if (Ms) for (var s of Ms(t)) Mn.call(t, s) && In(e, s, t[s]);
        return e
    }, Ni = (e, t) => vh(e, yh(t));
var Li = (e, t) => {
    var s = {};
    for (var i in e) Pn.call(e, i) && t.indexOf(i) < 0 && (s[i] = e[i]);
    if (e != null && Ms) for (var i of Ms(e)) t.indexOf(i) < 0 && Mn.call(e, i) && (s[i] = e[i]);
    return s
};/*!
 * pixi.js - v7.1.2
 * Compiled Tue, 31 Jan 2023 14:52:16 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var he = (e => (e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", e[e.WEBGL = 1] = "WEBGL", e[e.WEBGL2 = 2] = "WEBGL2", e))(he || {}),
    Bn = (e => (e[e.UNKNOWN = 0] = "UNKNOWN", e[e.WEBGL = 1] = "WEBGL", e[e.CANVAS = 2] = "CANVAS", e))(Bn || {}),
    Bs = (e => (e[e.COLOR = 16384] = "COLOR", e[e.DEPTH = 256] = "DEPTH", e[e.STENCIL = 1024] = "STENCIL", e))(Bs || {}),
    k = (e => (e[e.NORMAL = 0] = "NORMAL", e[e.ADD = 1] = "ADD", e[e.MULTIPLY = 2] = "MULTIPLY", e[e.SCREEN = 3] = "SCREEN", e[e.OVERLAY = 4] = "OVERLAY", e[e.DARKEN = 5] = "DARKEN", e[e.LIGHTEN = 6] = "LIGHTEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.COLOR_BURN = 8] = "COLOR_BURN", e[e.HARD_LIGHT = 9] = "HARD_LIGHT", e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.NORMAL_NPM = 17] = "NORMAL_NPM", e[e.ADD_NPM = 18] = "ADD_NPM", e[e.SCREEN_NPM = 19] = "SCREEN_NPM", e[e.NONE = 20] = "NONE", e[e.SRC_OVER = 0] = "SRC_OVER", e[e.SRC_IN = 21] = "SRC_IN", e[e.SRC_OUT = 22] = "SRC_OUT", e[e.SRC_ATOP = 23] = "SRC_ATOP", e[e.DST_OVER = 24] = "DST_OVER", e[e.DST_IN = 25] = "DST_IN", e[e.DST_OUT = 26] = "DST_OUT", e[e.DST_ATOP = 27] = "DST_ATOP", e[e.ERASE = 26] = "ERASE", e[e.SUBTRACT = 28] = "SUBTRACT", e[e.XOR = 29] = "XOR", e))(k || {}),
    Nt = (e => (e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e))(Nt || {}),
    R = (e => (e[e.RGBA = 6408] = "RGBA", e[e.RGB = 6407] = "RGB", e[e.RG = 33319] = "RG", e[e.RED = 6403] = "RED", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.ALPHA = 6406] = "ALPHA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e))(R || {}),
    _e = (e => (e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e))(_e || {}),
    U = (e => (e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.BYTE = 5120] = "BYTE", e[e.SHORT = 5122] = "SHORT", e[e.INT = 5124] = "INT", e[e.FLOAT = 5126] = "FLOAT", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.HALF_FLOAT = 36193] = "HALF_FLOAT", e))(U || {}),
    Ds = (e => (e[e.FLOAT = 0] = "FLOAT", e[e.INT = 1] = "INT", e[e.UINT = 2] = "UINT", e))(Ds || {}),
    qt = (e => (e[e.NEAREST = 0] = "NEAREST", e[e.LINEAR = 1] = "LINEAR", e))(qt || {}),
    Kt = (e => (e[e.CLAMP = 33071] = "CLAMP", e[e.REPEAT = 10497] = "REPEAT", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e))(Kt || {}),
    Lt = (e => (e[e.OFF = 0] = "OFF", e[e.POW2 = 1] = "POW2", e[e.ON = 2] = "ON", e[e.ON_MANUAL = 3] = "ON_MANUAL", e))(Lt || {}),
    Ct = (e => (e[e.NPM = 0] = "NPM", e[e.UNPACK = 1] = "UNPACK", e[e.PMA = 2] = "PMA", e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", e))(Ct || {}),
    Ot = (e => (e[e.NO = 0] = "NO", e[e.YES = 1] = "YES", e[e.AUTO = 2] = "AUTO", e[e.BLEND = 0] = "BLEND", e[e.CLEAR = 1] = "CLEAR", e[e.BLIT = 2] = "BLIT", e))(Ot || {}),
    Fs = (e => (e[e.AUTO = 0] = "AUTO", e[e.MANUAL = 1] = "MANUAL", e))(Fs || {}),
    wt = (e => (e.LOW = "lowp", e.MEDIUM = "mediump", e.HIGH = "highp", e))(wt || {}),
    ht = (e => (e[e.NONE = 0] = "NONE", e[e.SCISSOR = 1] = "SCISSOR", e[e.STENCIL = 2] = "STENCIL", e[e.SPRITE = 3] = "SPRITE", e[e.COLOR = 4] = "COLOR", e))(ht || {}),
    Dn = (e => (e[e.RED = 1] = "RED", e[e.GREEN = 2] = "GREEN", e[e.BLUE = 4] = "BLUE", e[e.ALPHA = 8] = "ALPHA", e))(Dn || {}),
    st = (e => (e[e.NONE = 0] = "NONE", e[e.LOW = 2] = "LOW", e[e.MEDIUM = 4] = "MEDIUM", e[e.HIGH = 8] = "HIGH", e))(st || {}),
    Ut = (e => (e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e))(Ut || {});
const Fn = {
    createCanvas: (e, t) => {
        const s = document.createElement("canvas");
        return s.width = e, s.height = t, s
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => {
        var e;
        return (e = document.baseURI) != null ? e : window.location.href
    },
    getFontFaceSet: () => document.fonts,
    fetch: (e, t) => fetch(e, t),
    parseXML: e => new DOMParser().parseFromString(e, "text/xml")
}, M = {
    ADAPTER: Fn,
    RESOLUTION: 1,
    RENDER_OPTIONS: {
        view: null,
        width: 800,
        height: 600,
        autoDensity: !1,
        backgroundColor: 0,
        backgroundAlpha: 1,
        clearBeforeRender: !0,
        antialias: !1,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        hello: !1
    },
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1
};
var Oi = /iPhone/i, Nn = /iPod/i, Ln = /iPad/i, On = /\biOS-universal(?:.+)Mac\b/i, Ui = /\bAndroid(?:.+)Mobile\b/i,
    Un = /Android/i, Be = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, Ns = /Silk/i, te = /Windows Phone/i,
    kn = /\bWindows(?:.+)ARM\b/i, Gn = /BlackBerry/i, Hn = /BB10/i, Xn = /Opera Mini/i,
    Vn = /\b(CriOS|Chrome)(?:.+)Mobile/i, zn = /Mobile(?:.+)Firefox\b/i, Wn = function (e) {
        return typeof e != "undefined" && e.platform === "MacIntel" && typeof e.maxTouchPoints == "number" && e.maxTouchPoints > 1 && typeof MSStream == "undefined"
    };

function Th(e) {
    return function (t) {
        return t.test(e)
    }
}

function bh(e) {
    var t = {userAgent: "", platform: "", maxTouchPoints: 0};
    !e && typeof navigator != "undefined" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof e == "string" ? t.userAgent = e : e && e.userAgent && (t = {
        userAgent: e.userAgent,
        platform: e.platform,
        maxTouchPoints: e.maxTouchPoints || 0
    });
    var s = t.userAgent, i = s.split("[FBAN");
    typeof i[1] != "undefined" && (s = i[0]), i = s.split("Twitter"), typeof i[1] != "undefined" && (s = i[0]);
    var r = Th(s), n = {
        apple: {
            phone: r(Oi) && !r(te),
            ipod: r(Nn),
            tablet: !r(Oi) && (r(Ln) || Wn(t)) && !r(te),
            universal: r(On),
            device: (r(Oi) || r(Nn) || r(Ln) || r(On) || Wn(t)) && !r(te)
        },
        amazon: {phone: r(Be), tablet: !r(Be) && r(Ns), device: r(Be) || r(Ns)},
        android: {
            phone: !r(te) && r(Be) || !r(te) && r(Ui),
            tablet: !r(te) && !r(Be) && !r(Ui) && (r(Ns) || r(Un)),
            device: !r(te) && (r(Be) || r(Ns) || r(Ui) || r(Un)) || r(/\bokhttp\b/i)
        },
        windows: {phone: r(te), tablet: r(kn), device: r(te) || r(kn)},
        other: {
            blackberry: r(Gn),
            blackberry10: r(Hn),
            opera: r(Xn),
            firefox: r(zn),
            chrome: r(Vn),
            device: r(Gn) || r(Hn) || r(Xn) || r(zn) || r(Vn)
        },
        any: !1,
        phone: !1,
        tablet: !1
    };
    return n.any = n.apple.device || n.android.device || n.windows.device || n.other.device, n.phone = n.apple.phone || n.android.phone || n.windows.phone, n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet, n
}

const kt = bh(globalThis.navigator);
M.RETINA_PREFIX = /@([0-9\.]+)x/, M.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var ki = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};

function Yp(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function Gi(e, t, s) {
    return s = {
        path: t, exports: {}, require: function (i, r) {
            return Eh(i, r == null ? s.path : r)
        }
    }, e(s, s.exports), s.exports
}

function qp(e) {
    return e && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function Kp(e) {
    return e && Object.prototype.hasOwnProperty.call(e, "default") && Object.keys(e).length === 1 ? e.default : e
}

function Zp(e) {
    if (e.__esModule) return e;
    var t = Object.defineProperty({}, "__esModule", {value: !0});
    return Object.keys(e).forEach(function (s) {
        var i = Object.getOwnPropertyDescriptor(e, s);
        Object.defineProperty(t, s, i.get ? i : {
            enumerable: !0, get: function () {
                return e[s]
            }
        })
    }), t
}

function Eh() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
}

var De = Gi(function (e) {
    "use strict";
    var t = Object.prototype.hasOwnProperty, s = "~";

    function i() {
    }

    Object.create && (i.prototype = Object.create(null), new i().__proto__ || (s = !1));

    function r(h, l, c) {
        this.fn = h, this.context = l, this.once = c || !1
    }

    function n(h, l, c, u, d) {
        if (typeof c != "function") throw new TypeError("The listener must be a function");
        var f = new r(c, u || h, d), p = s ? s + l : l;
        return h._events[p] ? h._events[p].fn ? h._events[p] = [h._events[p], f] : h._events[p].push(f) : (h._events[p] = f, h._eventsCount++), h
    }

    function o(h, l) {
        --h._eventsCount === 0 ? h._events = new i : delete h._events[l]
    }

    function a() {
        this._events = new i, this._eventsCount = 0
    }

    a.prototype.eventNames = function () {
        var l = [], c, u;
        if (this._eventsCount === 0) return l;
        for (u in c = this._events) t.call(c, u) && l.push(s ? u.slice(1) : u);
        return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(c)) : l
    }, a.prototype.listeners = function (l) {
        var c = s ? s + l : l, u = this._events[c];
        if (!u) return [];
        if (u.fn) return [u.fn];
        for (var d = 0, f = u.length, p = new Array(f); d < f; d++) p[d] = u[d].fn;
        return p
    }, a.prototype.listenerCount = function (l) {
        var c = s ? s + l : l, u = this._events[c];
        return u ? u.fn ? 1 : u.length : 0
    }, a.prototype.emit = function (l, c, u, d, f, p) {
        var _ = s ? s + l : l;
        if (!this._events[_]) return !1;
        var m = this._events[_], x = arguments.length, y, g;
        if (m.fn) {
            switch (m.once && this.removeListener(l, m.fn, void 0, !0), x) {
                case 1:
                    return m.fn.call(m.context), !0;
                case 2:
                    return m.fn.call(m.context, c), !0;
                case 3:
                    return m.fn.call(m.context, c, u), !0;
                case 4:
                    return m.fn.call(m.context, c, u, d), !0;
                case 5:
                    return m.fn.call(m.context, c, u, d, f), !0;
                case 6:
                    return m.fn.call(m.context, c, u, d, f, p), !0
            }
            for (g = 1, y = new Array(x - 1); g < x; g++) y[g - 1] = arguments[g];
            m.fn.apply(m.context, y)
        } else {
            var v = m.length, A;
            for (g = 0; g < v; g++) switch (m[g].once && this.removeListener(l, m[g].fn, void 0, !0), x) {
                case 1:
                    m[g].fn.call(m[g].context);
                    break;
                case 2:
                    m[g].fn.call(m[g].context, c);
                    break;
                case 3:
                    m[g].fn.call(m[g].context, c, u);
                    break;
                case 4:
                    m[g].fn.call(m[g].context, c, u, d);
                    break;
                default:
                    if (!y) for (A = 1, y = new Array(x - 1); A < x; A++) y[A - 1] = arguments[A];
                    m[g].fn.apply(m[g].context, y)
            }
        }
        return !0
    }, a.prototype.on = function (l, c, u) {
        return n(this, l, c, u, !1)
    }, a.prototype.once = function (l, c, u) {
        return n(this, l, c, u, !0)
    }, a.prototype.removeListener = function (l, c, u, d) {
        var f = s ? s + l : l;
        if (!this._events[f]) return this;
        if (!c) return o(this, f), this;
        var p = this._events[f];
        if (p.fn) p.fn === c && (!d || p.once) && (!u || p.context === u) && o(this, f); else {
            for (var _ = 0, m = [], x = p.length; _ < x; _++) (p[_].fn !== c || d && !p[_].once || u && p[_].context !== u) && m.push(p[_]);
            m.length ? this._events[f] = m.length === 1 ? m[0] : m : o(this, f)
        }
        return this
    }, a.prototype.removeAllListeners = function (l) {
        var c;
        return l ? (c = s ? s + l : l, this._events[c] && o(this, c)) : (this._events = new i, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = s, a.EventEmitter = a, e.exports = a
}), Hi = Ls, wh = Ls;

function Ls(e, t, s) {
    s = s || 2;
    var i = t && t.length, r = i ? t[0] * s : e.length, n = jn(e, 0, r, s, !0), o = [];
    if (!n || n.next === n.prev) return o;
    var a, h, l, c, u, d, f;
    if (i && (n = Ih(e, t, n, s)), e.length > 80 * s) {
        a = l = e[0], h = c = e[1];
        for (var p = s; p < r; p += s) u = e[p], d = e[p + 1], u < a && (a = u), d < h && (h = d), u > l && (l = u), d > c && (c = d);
        f = Math.max(l - a, c - h), f = f !== 0 ? 32767 / f : 0
    }
    return qe(n, o, s, a, h, f, 0), o
}

function jn(e, t, s, i, r) {
    var n, o;
    if (r === zi(e, t, s, i) > 0) for (n = t; n < s; n += i) o = qn(n, e[n], e[n + 1], o); else for (n = s - i; n >= t; n -= i) o = qn(n, e[n], e[n + 1], o);
    return o && Os(o, o.next) && (Ze(o), o = o.next), o
}

function ge(e, t) {
    if (!e) return e;
    t || (t = e);
    var s = e, i;
    do if (i = !1, !s.steiner && (Os(s, s.next) || it(s.prev, s, s.next) === 0)) {
        if (Ze(s), s = t = s.prev, s === s.next) break;
        i = !0
    } else s = s.next; while (i || s !== t);
    return t
}

function qe(e, t, s, i, r, n, o) {
    if (!!e) {
        !o && n && Fh(e, i, r, n);
        for (var a = e, h, l; e.prev !== e.next;) {
            if (h = e.prev, l = e.next, n ? Sh(e, i, r, n) : Ah(e)) {
                t.push(h.i / s | 0), t.push(e.i / s | 0), t.push(l.i / s | 0), Ze(e), e = l.next, a = l.next;
                continue
            }
            if (e = l, e === a) {
                o ? o === 1 ? (e = Rh(ge(e), t, s), qe(e, t, s, i, r, n, 2)) : o === 2 && Ch(e, t, s, i, r, n) : qe(ge(e), t, s, i, r, n, 1);
                break
            }
        }
    }
}

function Ah(e) {
    var t = e.prev, s = e, i = e.next;
    if (it(t, s, i) >= 0) return !1;
    for (var r = t.x, n = s.x, o = i.x, a = t.y, h = s.y, l = i.y, c = r < n ? r < o ? r : o : n < o ? n : o, u = a < h ? a < l ? a : l : h < l ? h : l, d = r > n ? r > o ? r : o : n > o ? n : o, f = a > h ? a > l ? a : l : h > l ? h : l, p = i.next; p !== t;) {
        if (p.x >= c && p.x <= d && p.y >= u && p.y <= f && Fe(r, a, n, h, o, l, p.x, p.y) && it(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function Sh(e, t, s, i) {
    var r = e.prev, n = e, o = e.next;
    if (it(r, n, o) >= 0) return !1;
    for (var a = r.x, h = n.x, l = o.x, c = r.y, u = n.y, d = o.y, f = a < h ? a < l ? a : l : h < l ? h : l, p = c < u ? c < d ? c : d : u < d ? u : d, _ = a > h ? a > l ? a : l : h > l ? h : l, m = c > u ? c > d ? c : d : u > d ? u : d, x = Xi(f, p, t, s, i), y = Xi(_, m, t, s, i), g = e.prevZ, v = e.nextZ; g && g.z >= x && v && v.z <= y;) {
        if (g.x >= f && g.x <= _ && g.y >= p && g.y <= m && g !== r && g !== o && Fe(a, c, h, u, l, d, g.x, g.y) && it(g.prev, g, g.next) >= 0 || (g = g.prevZ, v.x >= f && v.x <= _ && v.y >= p && v.y <= m && v !== r && v !== o && Fe(a, c, h, u, l, d, v.x, v.y) && it(v.prev, v, v.next) >= 0)) return !1;
        v = v.nextZ
    }
    for (; g && g.z >= x;) {
        if (g.x >= f && g.x <= _ && g.y >= p && g.y <= m && g !== r && g !== o && Fe(a, c, h, u, l, d, g.x, g.y) && it(g.prev, g, g.next) >= 0) return !1;
        g = g.prevZ
    }
    for (; v && v.z <= y;) {
        if (v.x >= f && v.x <= _ && v.y >= p && v.y <= m && v !== r && v !== o && Fe(a, c, h, u, l, d, v.x, v.y) && it(v.prev, v, v.next) >= 0) return !1;
        v = v.nextZ
    }
    return !0
}

function Rh(e, t, s) {
    var i = e;
    do {
        var r = i.prev, n = i.next.next;
        !Os(r, n) && $n(r, i, i.next, n) && Ke(r, n) && Ke(n, r) && (t.push(r.i / s | 0), t.push(i.i / s | 0), t.push(n.i / s | 0), Ze(i), Ze(i.next), i = e = n), i = i.next
    } while (i !== e);
    return ge(i)
}

function Ch(e, t, s, i, r, n) {
    var o = e;
    do {
        for (var a = o.next.next; a !== o.prev;) {
            if (o.i !== a.i && Oh(o, a)) {
                var h = Yn(o, a);
                o = ge(o, o.next), h = ge(h, h.next), qe(o, t, s, i, r, n, 0), qe(h, t, s, i, r, n, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== e)
}

function Ih(e, t, s, i) {
    var r = [], n, o, a, h, l;
    for (n = 0, o = t.length; n < o; n++) a = t[n] * i, h = n < o - 1 ? t[n + 1] * i : e.length, l = jn(e, a, h, i, !1), l === l.next && (l.steiner = !0), r.push(Lh(l));
    for (r.sort(Ph), n = 0; n < r.length; n++) s = Mh(r[n], s);
    return s
}

function Ph(e, t) {
    return e.x - t.x
}

function Mh(e, t) {
    var s = Bh(e, t);
    if (!s) return t;
    var i = Yn(s, e);
    return ge(i, i.next), ge(s, s.next)
}

function Bh(e, t) {
    var s = t, i = e.x, r = e.y, n = -1 / 0, o;
    do {
        if (r <= s.y && r >= s.next.y && s.next.y !== s.y) {
            var a = s.x + (r - s.y) * (s.next.x - s.x) / (s.next.y - s.y);
            if (a <= i && a > n && (n = a, o = s.x < s.next.x ? s : s.next, a === i)) return o
        }
        s = s.next
    } while (s !== t);
    if (!o) return null;
    var h = o, l = o.x, c = o.y, u = 1 / 0, d;
    s = o;
    do i >= s.x && s.x >= l && i !== s.x && Fe(r < c ? i : n, r, l, c, r < c ? n : i, r, s.x, s.y) && (d = Math.abs(r - s.y) / (i - s.x), Ke(s, e) && (d < u || d === u && (s.x > o.x || s.x === o.x && Dh(o, s))) && (o = s, u = d)), s = s.next; while (s !== h);
    return o
}

function Dh(e, t) {
    return it(e.prev, e, t.prev) < 0 && it(t.next, e, e.next) < 0
}

function Fh(e, t, s, i) {
    var r = e;
    do r.z === 0 && (r.z = Xi(r.x, r.y, t, s, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);
    r.prevZ.nextZ = null, r.prevZ = null, Nh(r)
}

function Nh(e) {
    var t, s, i, r, n, o, a, h, l = 1;
    do {
        for (s = e, e = null, n = null, o = 0; s;) {
            for (o++, i = s, a = 0, t = 0; t < l && (a++, i = i.nextZ, !!i); t++) ;
            for (h = l; a > 0 || h > 0 && i;) a !== 0 && (h === 0 || !i || s.z <= i.z) ? (r = s, s = s.nextZ, a--) : (r = i, i = i.nextZ, h--), n ? n.nextZ = r : e = r, r.prevZ = n, n = r;
            s = i
        }
        n.nextZ = null, l *= 2
    } while (o > 1);
    return e
}

function Xi(e, t, s, i, r) {
    return e = (e - s) * r | 0, t = (t - i) * r | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
}

function Lh(e) {
    var t = e, s = e;
    do (t.x < s.x || t.x === s.x && t.y < s.y) && (s = t), t = t.next; while (t !== e);
    return s
}

function Fe(e, t, s, i, r, n, o, a) {
    return (r - o) * (t - a) >= (e - o) * (n - a) && (e - o) * (i - a) >= (s - o) * (t - a) && (s - o) * (n - a) >= (r - o) * (i - a)
}

function Oh(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !Uh(e, t) && (Ke(e, t) && Ke(t, e) && kh(e, t) && (it(e.prev, e, t.prev) || it(e, t.prev, t)) || Os(e, t) && it(e.prev, e, e.next) > 0 && it(t.prev, t, t.next) > 0)
}

function it(e, t, s) {
    return (t.y - e.y) * (s.x - t.x) - (t.x - e.x) * (s.y - t.y)
}

function Os(e, t) {
    return e.x === t.x && e.y === t.y
}

function $n(e, t, s, i) {
    var r = ks(it(e, t, s)), n = ks(it(e, t, i)), o = ks(it(s, i, e)), a = ks(it(s, i, t));
    return !!(r !== n && o !== a || r === 0 && Us(e, s, t) || n === 0 && Us(e, i, t) || o === 0 && Us(s, e, i) || a === 0 && Us(s, t, i))
}

function Us(e, t, s) {
    return t.x <= Math.max(e.x, s.x) && t.x >= Math.min(e.x, s.x) && t.y <= Math.max(e.y, s.y) && t.y >= Math.min(e.y, s.y)
}

function ks(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}

function Uh(e, t) {
    var s = e;
    do {
        if (s.i !== e.i && s.next.i !== e.i && s.i !== t.i && s.next.i !== t.i && $n(s, s.next, e, t)) return !0;
        s = s.next
    } while (s !== e);
    return !1
}

function Ke(e, t) {
    return it(e.prev, e, e.next) < 0 ? it(e, t, e.next) >= 0 && it(e, e.prev, t) >= 0 : it(e, t, e.prev) < 0 || it(e, e.next, t) < 0
}

function kh(e, t) {
    var s = e, i = !1, r = (e.x + t.x) / 2, n = (e.y + t.y) / 2;
    do s.y > n != s.next.y > n && s.next.y !== s.y && r < (s.next.x - s.x) * (n - s.y) / (s.next.y - s.y) + s.x && (i = !i), s = s.next; while (s !== e);
    return i
}

function Yn(e, t) {
    var s = new Vi(e.i, e.x, e.y), i = new Vi(t.i, t.x, t.y), r = e.next, n = t.prev;
    return e.next = t, t.prev = e, s.next = r, r.prev = s, i.next = s, s.prev = i, n.next = i, i.prev = n, i
}

function qn(e, t, s, i) {
    var r = new Vi(e, t, s);
    return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
}

function Ze(e) {
    e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
}

function Vi(e, t, s) {
    this.i = e, this.x = t, this.y = s, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

Ls.deviation = function (e, t, s, i) {
    var r = t && t.length, n = r ? t[0] * s : e.length, o = Math.abs(zi(e, 0, n, s));
    if (r) for (var a = 0, h = t.length; a < h; a++) {
        var l = t[a] * s, c = a < h - 1 ? t[a + 1] * s : e.length;
        o -= Math.abs(zi(e, l, c, s))
    }
    var u = 0;
    for (a = 0; a < i.length; a += 3) {
        var d = i[a] * s, f = i[a + 1] * s, p = i[a + 2] * s;
        u += Math.abs((e[d] - e[p]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[p + 1] - e[d + 1]))
    }
    return o === 0 && u === 0 ? 0 : Math.abs((u - o) / o)
};

function zi(e, t, s, i) {
    for (var r = 0, n = t, o = s - i; n < s; n += i) r += (e[o] - e[n]) * (e[n + 1] + e[o + 1]), o = n;
    return r
}

Ls.flatten = function (e) {
    for (var t = e[0][0].length, s = {vertices: [], holes: [], dimensions: t}, i = 0, r = 0; r < e.length; r++) {
        for (var n = 0; n < e[r].length; n++) for (var o = 0; o < t; o++) s.vertices.push(e[r][n][o]);
        r > 0 && (i += e[r - 1].length, s.holes.push(i))
    }
    return s
}, Hi.default = wh;
var Gh = Gi(function (e, t) {/*! https://mths.be/punycode v1.3.2 by @mathias */
    (function (s) {
        var i = t && !t.nodeType && t, r = e && !e.nodeType && e, n = typeof ki == "object" && ki;
        (n.global === n || n.window === n || n.self === n) && (s = n);
        var o, a = 2147483647, h = 36, l = 1, c = 26, u = 38, d = 700, f = 72, p = 128, _ = "-", m = /^xn--/,
            x = /[^\x20-\x7E]/, y = /[\x2E\u3002\uFF0E\uFF61]/g, g = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }, v = h - l, A = Math.floor, P = String.fromCharCode, S;

        function b(w) {
            throw RangeError(g[w])
        }

        function L(w, H) {
            for (var $ = w.length, K = []; $--;) K[$] = H(w[$]);
            return K
        }

        function G(w, H) {
            var $ = w.split("@"), K = "";
            $.length > 1 && (K = $[0] + "@", w = $[1]), w = w.replace(y, ".");
            var Z = w.split("."), ut = L(Z, H).join(".");
            return K + ut
        }

        function C(w) {
            for (var H = [], $ = 0, K = w.length, Z, ut; $ < K;) Z = w.charCodeAt($++), Z >= 55296 && Z <= 56319 && $ < K ? (ut = w.charCodeAt($++), (ut & 64512) == 56320 ? H.push(((Z & 1023) << 10) + (ut & 1023) + 65536) : (H.push(Z), $--)) : H.push(Z);
            return H
        }

        function F(w) {
            return L(w, function (H) {
                var $ = "";
                return H > 65535 && (H -= 65536, $ += P(H >>> 10 & 1023 | 55296), H = 56320 | H & 1023), $ += P(H), $
            }).join("")
        }

        function E(w) {
            return w - 48 < 10 ? w - 22 : w - 65 < 26 ? w - 65 : w - 97 < 26 ? w - 97 : h
        }

        function T(w, H) {
            return w + 22 + 75 * (w < 26) - ((H != 0) << 5)
        }

        function V(w, H, $) {
            var K = 0;
            for (w = $ ? A(w / d) : w >> 1, w += A(w / H); w > v * c >> 1; K += h) w = A(w / v);
            return A(K + (v + 1) * w / (w + u))
        }

        function W(w) {
            var H = [], $ = w.length, K, Z = 0, ut = p, ot = f, dt, xt, Tt, gt, J, at, lt, jt, $t;
            for (dt = w.lastIndexOf(_), dt < 0 && (dt = 0), xt = 0; xt < dt; ++xt) w.charCodeAt(xt) >= 128 && b("not-basic"), H.push(w.charCodeAt(xt));
            for (Tt = dt > 0 ? dt + 1 : 0; Tt < $;) {
                for (gt = Z, J = 1, at = h; Tt >= $ && b("invalid-input"), lt = E(w.charCodeAt(Tt++)), (lt >= h || lt > A((a - Z) / J)) && b("overflow"), Z += lt * J, jt = at <= ot ? l : at >= ot + c ? c : at - ot, !(lt < jt); at += h) $t = h - jt, J > A(a / $t) && b("overflow"), J *= $t;
                K = H.length + 1, ot = V(Z - gt, K, gt == 0), A(Z / K) > a - ut && b("overflow"), ut += A(Z / K), Z %= K, H.splice(Z++, 0, ut)
            }
            return F(H)
        }

        function D(w) {
            var H, $, K, Z, ut, ot, dt, xt, Tt, gt, J, at = [], lt, jt, $t, Ye;
            for (w = C(w), lt = w.length, H = p, $ = 0, ut = f, ot = 0; ot < lt; ++ot) J = w[ot], J < 128 && at.push(P(J));
            for (K = Z = at.length, Z && at.push(_); K < lt;) {
                for (dt = a, ot = 0; ot < lt; ++ot) J = w[ot], J >= H && J < dt && (dt = J);
                for (jt = K + 1, dt - H > A((a - $) / jt) && b("overflow"), $ += (dt - H) * jt, H = dt, ot = 0; ot < lt; ++ot) if (J = w[ot], J < H && ++$ > a && b("overflow"), J == H) {
                    for (xt = $, Tt = h; gt = Tt <= ut ? l : Tt >= ut + c ? c : Tt - ut, !(xt < gt); Tt += h) Ye = xt - gt, $t = h - gt, at.push(P(T(gt + Ye % $t, 0))), xt = A(Ye / $t);
                    at.push(P(T(xt, 0))), ut = V($, jt, K == Z), $ = 0, ++K
                }
                ++$, ++H
            }
            return at.join("")
        }

        function q(w) {
            return G(w, function (H) {
                return m.test(H) ? W(H.slice(4).toLowerCase()) : H
            })
        }

        function rt(w) {
            return G(w, function (H) {
                return x.test(H) ? "xn--" + D(H) : H
            })
        }

        if (o = {
            version: "1.3.2",
            ucs2: {decode: C, encode: F},
            decode: W,
            encode: D,
            toASCII: rt,
            toUnicode: q
        }, i && r) if (e.exports == i) r.exports = o; else for (S in o) o.hasOwnProperty(S) && (i[S] = o[S]); else s.punycode = o
    })(ki)
}), Zt = {
    isString: function (e) {
        return typeof e == "string"
    }, isObject: function (e) {
        return typeof e == "object" && e !== null
    }, isNull: function (e) {
        return e === null
    }, isNullOrUndefined: function (e) {
        return e == null
    }
};

function Hh(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}

var Xh = function (e, t, s, i) {
    t = t || "&", s = s || "=";
    var r = {};
    if (typeof e != "string" || e.length === 0) return r;
    var n = /\+/g;
    e = e.split(t);
    var o = 1e3;
    i && typeof i.maxKeys == "number" && (o = i.maxKeys);
    var a = e.length;
    o > 0 && a > o && (a = o);
    for (var h = 0; h < a; ++h) {
        var l = e[h].replace(n, "%20"), c = l.indexOf(s), u, d, f, p;
        c >= 0 ? (u = l.substr(0, c), d = l.substr(c + 1)) : (u = l, d = ""), f = decodeURIComponent(u), p = decodeURIComponent(d), Hh(r, f) ? Array.isArray(r[f]) ? r[f].push(p) : r[f] = [r[f], p] : r[f] = p
    }
    return r
}, Qe = function (e) {
    switch (typeof e) {
        case"string":
            return e;
        case"boolean":
            return e ? "true" : "false";
        case"number":
            return isFinite(e) ? e : "";
        default:
            return ""
    }
}, Vh = function (e, t, s, i) {
    return t = t || "&", s = s || "=", e === null && (e = void 0), typeof e == "object" ? Object.keys(e).map(function (r) {
        var n = encodeURIComponent(Qe(r)) + s;
        return Array.isArray(e[r]) ? e[r].map(function (o) {
            return n + encodeURIComponent(Qe(o))
        }).join(t) : n + encodeURIComponent(Qe(e[r]))
    }).join(t) : i ? encodeURIComponent(Qe(i)) + s + encodeURIComponent(Qe(e)) : ""
}, Wi = Gi(function (e, t) {
    "use strict";
    t.decode = t.parse = Xh, t.encode = t.stringify = Vh
}), Kn = Je, Zn = el, zh = sl, Qn = tl, Wh = It;

function It() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
}

var jh = /^([a-z0-9.+-]+:)/i, $h = /:[0-9]*$/, Yh = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    qh = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Kh = ["{", "}", "|", "\\", "^", "`"].concat(qh), ji = ["'"].concat(Kh),
    Jn = ["%", "/", "?", ";", "#"].concat(ji), to = ["/", "?", "#"], Zh = 255, eo = /^[+a-z0-9A-Z_-]{0,63}$/,
    Qh = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Jh = {javascript: !0, "javascript:": !0},
    $i = {javascript: !0, "javascript:": !0}, Ne = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    };

function Je(e, t, s) {
    if (e && Zt.isObject(e) && e instanceof It) return e;
    var i = new It;
    return i.parse(e, t, s), i
}

It.prototype.parse = function (e, t, s) {
    if (!Zt.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var i = e.indexOf("?"), r = i !== -1 && i < e.indexOf("#") ? "?" : "#", n = e.split(r), o = /\\/g;
    n[0] = n[0].replace(o, "/"), e = n.join(r);
    var a = e;
    if (a = a.trim(), !s && e.split("#").length === 1) {
        var h = Yh.exec(a);
        if (h) return this.path = a, this.href = a, this.pathname = h[1], h[2] ? (this.search = h[2], t ? this.query = Wi.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this
    }
    var l = jh.exec(a);
    if (l) {
        l = l[0];
        var c = l.toLowerCase();
        this.protocol = c, a = a.substr(l.length)
    }
    if (s || l || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var u = a.substr(0, 2) === "//";
        u && !(l && $i[l]) && (a = a.substr(2), this.slashes = !0)
    }
    if (!$i[l] && (u || l && !Ne[l])) {
        for (var d = -1, f = 0; f < to.length; f++) {
            var p = a.indexOf(to[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var _, m;
        d === -1 ? m = a.lastIndexOf("@") : m = a.lastIndexOf("@", d), m !== -1 && (_ = a.slice(0, m), a = a.slice(m + 1), this.auth = decodeURIComponent(_)), d = -1;
        for (var f = 0; f < Jn.length; f++) {
            var p = a.indexOf(Jn[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = a.length), this.host = a.slice(0, d), a = a.slice(d), this.parseHost(), this.hostname = this.hostname || "";
        var x = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!x) for (var y = this.hostname.split(/\./), f = 0, g = y.length; f < g; f++) {
            var v = y[f];
            if (!!v && !v.match(eo)) {
                for (var A = "", P = 0, S = v.length; P < S; P++) v.charCodeAt(P) > 127 ? A += "x" : A += v[P];
                if (!A.match(eo)) {
                    var b = y.slice(0, f), L = y.slice(f + 1), G = v.match(Qh);
                    G && (b.push(G[1]), L.unshift(G[2])), L.length && (a = "/" + L.join(".") + a), this.hostname = b.join(".");
                    break
                }
            }
        }
        this.hostname.length > Zh ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), x || (this.hostname = Gh.toASCII(this.hostname));
        var C = this.port ? ":" + this.port : "", F = this.hostname || "";
        this.host = F + C, this.href += this.host, x && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a))
    }
    if (!Jh[c]) for (var f = 0, g = ji.length; f < g; f++) {
        var E = ji[f];
        if (a.indexOf(E) !== -1) {
            var T = encodeURIComponent(E);
            T === E && (T = escape(E)), a = a.split(E).join(T)
        }
    }
    var V = a.indexOf("#");
    V !== -1 && (this.hash = a.substr(V), a = a.slice(0, V));
    var W = a.indexOf("?");
    if (W !== -1 ? (this.search = a.substr(W), this.query = a.substr(W + 1), t && (this.query = Wi.parse(this.query)), a = a.slice(0, W)) : t && (this.search = "", this.query = {}), a && (this.pathname = a), Ne[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var C = this.pathname || "", D = this.search || "";
        this.path = C + D
    }
    return this.href = this.format(), this
};

function tl(e) {
    return Zt.isString(e) && (e = Je(e)), e instanceof It ? e.format() : It.prototype.format.call(e)
}

It.prototype.format = function () {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "", s = this.pathname || "", i = this.hash || "", r = !1, n = "";
    this.host ? r = e + this.host : this.hostname && (r = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (r += ":" + this.port)), this.query && Zt.isObject(this.query) && Object.keys(this.query).length && (n = Wi.stringify(this.query));
    var o = this.search || n && "?" + n || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Ne[t]) && r !== !1 ? (r = "//" + (r || ""), s && s.charAt(0) !== "/" && (s = "/" + s)) : r || (r = ""), i && i.charAt(0) !== "#" && (i = "#" + i), o && o.charAt(0) !== "?" && (o = "?" + o), s = s.replace(/[?#]/g, function (a) {
        return encodeURIComponent(a)
    }), o = o.replace("#", "%23"), t + r + s + o + i
};

function el(e, t) {
    return Je(e, !1, !0).resolve(t)
}

It.prototype.resolve = function (e) {
    return this.resolveObject(Je(e, !1, !0)).format()
};

function sl(e, t) {
    return e ? Je(e, !1, !0).resolveObject(t) : t
}

It.prototype.resolveObject = function (e) {
    if (Zt.isString(e)) {
        var t = new It;
        t.parse(e, !1, !0), e = t
    }
    for (var s = new It, i = Object.keys(this), r = 0; r < i.length; r++) {
        var n = i[r];
        s[n] = this[n]
    }
    if (s.hash = e.hash, e.href === "") return s.href = s.format(), s;
    if (e.slashes && !e.protocol) {
        for (var o = Object.keys(e), a = 0; a < o.length; a++) {
            var h = o[a];
            h !== "protocol" && (s[h] = e[h])
        }
        return Ne[s.protocol] && s.hostname && !s.pathname && (s.path = s.pathname = "/"), s.href = s.format(), s
    }
    if (e.protocol && e.protocol !== s.protocol) {
        if (!Ne[e.protocol]) {
            for (var l = Object.keys(e), c = 0; c < l.length; c++) {
                var u = l[c];
                s[u] = e[u]
            }
            return s.href = s.format(), s
        }
        if (s.protocol = e.protocol, !e.host && !$i[e.protocol]) {
            for (var g = (e.pathname || "").split("/"); g.length && !(e.host = g.shift());) ;
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), g[0] !== "" && g.unshift(""), g.length < 2 && g.unshift(""), s.pathname = g.join("/")
        } else s.pathname = e.pathname;
        if (s.search = e.search, s.query = e.query, s.host = e.host || "", s.auth = e.auth, s.hostname = e.hostname || e.host, s.port = e.port, s.pathname || s.search) {
            var d = s.pathname || "", f = s.search || "";
            s.path = d + f
        }
        return s.slashes = s.slashes || e.slashes, s.href = s.format(), s
    }
    var p = s.pathname && s.pathname.charAt(0) === "/", _ = e.host || e.pathname && e.pathname.charAt(0) === "/",
        m = _ || p || s.host && e.pathname, x = m, y = s.pathname && s.pathname.split("/") || [],
        g = e.pathname && e.pathname.split("/") || [], v = s.protocol && !Ne[s.protocol];
    if (v && (s.hostname = "", s.port = null, s.host && (y[0] === "" ? y[0] = s.host : y.unshift(s.host)), s.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (g[0] === "" ? g[0] = e.host : g.unshift(e.host)), e.host = null), m = m && (g[0] === "" || y[0] === "")), _) s.host = e.host || e.host === "" ? e.host : s.host, s.hostname = e.hostname || e.hostname === "" ? e.hostname : s.hostname, s.search = e.search, s.query = e.query, y = g; else if (g.length) y || (y = []), y.pop(), y = y.concat(g), s.search = e.search, s.query = e.query; else if (!Zt.isNullOrUndefined(e.search)) {
        if (v) {
            s.hostname = s.host = y.shift();
            var A = s.host && s.host.indexOf("@") > 0 ? s.host.split("@") : !1;
            A && (s.auth = A.shift(), s.host = s.hostname = A.shift())
        }
        return s.search = e.search, s.query = e.query, (!Zt.isNull(s.pathname) || !Zt.isNull(s.search)) && (s.path = (s.pathname ? s.pathname : "") + (s.search ? s.search : "")), s.href = s.format(), s
    }
    if (!y.length) return s.pathname = null, s.search ? s.path = "/" + s.search : s.path = null, s.href = s.format(), s;
    for (var P = y.slice(-1)[0], S = (s.host || e.host || y.length > 1) && (P === "." || P === "..") || P === "", b = 0, L = y.length; L >= 0; L--) P = y[L], P === "." ? y.splice(L, 1) : P === ".." ? (y.splice(L, 1), b++) : b && (y.splice(L, 1), b--);
    if (!m && !x) for (; b--; b) y.unshift("..");
    m && y[0] !== "" && (!y[0] || y[0].charAt(0) !== "/") && y.unshift(""), S && y.join("/").substr(-1) !== "/" && y.push("");
    var G = y[0] === "" || y[0] && y[0].charAt(0) === "/";
    if (v) {
        s.hostname = s.host = G ? "" : y.length ? y.shift() : "";
        var A = s.host && s.host.indexOf("@") > 0 ? s.host.split("@") : !1;
        A && (s.auth = A.shift(), s.host = s.hostname = A.shift())
    }
    return m = m || s.host && y.length, m && !G && y.unshift(""), y.length ? s.pathname = y.join("/") : (s.pathname = null, s.path = null), (!Zt.isNull(s.pathname) || !Zt.isNull(s.search)) && (s.path = (s.pathname ? s.pathname : "") + (s.search ? s.search : "")), s.auth = e.auth || s.auth, s.slashes = s.slashes || e.slashes, s.href = s.format(), s
}, It.prototype.parseHost = function () {
    var e = this.host, t = $h.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
};
var Qp = {parse: Kn, resolve: Zn, resolveObject: zh, format: Qn, Url: Wh};
const so = {parse: Kn, format: Qn, resolve: Zn};

function Gt(e) {
    if (typeof e != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
}

function ts(e) {
    return e.split("?")[0].split("#")[0]
}

function il(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function rl(e, t, s) {
    return e.replace(new RegExp(il(t), "g"), s)
}

function nl(e, t) {
    let s = "", i = 0, r = -1, n = 0, o = -1;
    for (let a = 0; a <= e.length; ++a) {
        if (a < e.length) o = e.charCodeAt(a); else {
            if (o === 47) break;
            o = 47
        }
        if (o === 47) {
            if (!(r === a - 1 || n === 1)) if (r !== a - 1 && n === 2) {
                if (s.length < 2 || i !== 2 || s.charCodeAt(s.length - 1) !== 46 || s.charCodeAt(s.length - 2) !== 46) {
                    if (s.length > 2) {
                        const h = s.lastIndexOf("/");
                        if (h !== s.length - 1) {
                            h === -1 ? (s = "", i = 0) : (s = s.slice(0, h), i = s.length - 1 - s.lastIndexOf("/")), r = a, n = 0;
                            continue
                        }
                    } else if (s.length === 2 || s.length === 1) {
                        s = "", i = 0, r = a, n = 0;
                        continue
                    }
                }
                t && (s.length > 0 ? s += "/.." : s = "..", i = 2)
            } else s.length > 0 ? s += `/${e.slice(r + 1, a)}` : s = e.slice(r + 1, a), i = a - r - 1;
            r = a, n = 0
        } else o === 46 && n !== -1 ? ++n : n = -1
    }
    return s
}

const ft = {
    toPosix(e) {
        return rl(e, "\\", "/")
    }, isUrl(e) {
        return /^https?:/.test(this.toPosix(e))
    }, isDataUrl(e) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e)
    }, hasProtocol(e) {
        return /^[^/:]+:\//.test(this.toPosix(e))
    }, getProtocol(e) {
        Gt(e), e = this.toPosix(e);
        let t = "";
        const s = /^file:\/\/\//.exec(e), i = /^[^/:]+:\/\//.exec(e), r = /^[^/:]+:\//.exec(e);
        if (s || i || r) {
            const n = (s == null ? void 0 : s[0]) || (i == null ? void 0 : i[0]) || (r == null ? void 0 : r[0]);
            t = n, e = e.slice(n.length)
        }
        return t
    }, toAbsolute(e, t, s) {
        if (this.isDataUrl(e)) return e;
        const i = ts(this.toPosix(t != null ? t : M.ADAPTER.getBaseUrl())),
            r = ts(this.toPosix(s != null ? s : this.rootname(i)));
        return Gt(e), e = this.toPosix(e), e.startsWith("/") ? ft.join(r, e.slice(1)) : this.isAbsolute(e) ? e : this.join(i, e)
    }, normalize(e) {
        if (e = this.toPosix(e), Gt(e), e.length === 0) return ".";
        let t = "";
        const s = e.startsWith("/");
        this.hasProtocol(e) && (t = this.rootname(e), e = e.slice(t.length));
        const i = e.endsWith("/");
        return e = nl(e, !1), e.length > 0 && i && (e += "/"), s ? `/${e}` : t + e
    }, isAbsolute(e) {
        return Gt(e), e = this.toPosix(e), this.hasProtocol(e) ? !0 : e.startsWith("/")
    }, join(...e) {
        var s;
        if (e.length === 0) return ".";
        let t;
        for (let i = 0; i < e.length; ++i) {
            const r = e[i];
            if (Gt(r), r.length > 0) if (t === void 0) t = r; else {
                const n = (s = e[i - 1]) != null ? s : "";
                this.extname(n) ? t += `/../${r}` : t += `/${r}`
            }
        }
        return t === void 0 ? "." : this.normalize(t)
    }, dirname(e) {
        if (Gt(e), e.length === 0) return ".";
        e = this.toPosix(e);
        let t = e.charCodeAt(0);
        const s = t === 47;
        let i = -1, r = !0;
        const n = this.getProtocol(e), o = e;
        e = e.slice(n.length);
        for (let a = e.length - 1; a >= 1; --a) if (t = e.charCodeAt(a), t === 47) {
            if (!r) {
                i = a;
                break
            }
        } else r = !1;
        return i === -1 ? s ? "/" : this.isUrl(o) ? n + e : n : s && i === 1 ? "//" : n + e.slice(0, i)
    }, rootname(e) {
        Gt(e), e = this.toPosix(e);
        let t = "";
        if (e.startsWith("/") ? t = "/" : t = this.getProtocol(e), this.isUrl(e)) {
            const s = e.indexOf("/", t.length);
            s !== -1 ? t = e.slice(0, s) : t = e, t.endsWith("/") || (t += "/")
        }
        return t
    }, basename(e, t) {
        Gt(e), t && Gt(t), e = ts(this.toPosix(e));
        let s = 0, i = -1, r = !0, n;
        if (t !== void 0 && t.length > 0 && t.length <= e.length) {
            if (t.length === e.length && t === e) return "";
            let o = t.length - 1, a = -1;
            for (n = e.length - 1; n >= 0; --n) {
                const h = e.charCodeAt(n);
                if (h === 47) {
                    if (!r) {
                        s = n + 1;
                        break
                    }
                } else a === -1 && (r = !1, a = n + 1), o >= 0 && (h === t.charCodeAt(o) ? --o === -1 && (i = n) : (o = -1, i = a))
            }
            return s === i ? i = a : i === -1 && (i = e.length), e.slice(s, i)
        }
        for (n = e.length - 1; n >= 0; --n) if (e.charCodeAt(n) === 47) {
            if (!r) {
                s = n + 1;
                break
            }
        } else i === -1 && (r = !1, i = n + 1);
        return i === -1 ? "" : e.slice(s, i)
    }, extname(e) {
        Gt(e), e = ts(this.toPosix(e));
        let t = -1, s = 0, i = -1, r = !0, n = 0;
        for (let o = e.length - 1; o >= 0; --o) {
            const a = e.charCodeAt(o);
            if (a === 47) {
                if (!r) {
                    s = o + 1;
                    break
                }
                continue
            }
            i === -1 && (r = !1, i = o + 1), a === 46 ? t === -1 ? t = o : n !== 1 && (n = 1) : t !== -1 && (n = -1)
        }
        return t === -1 || i === -1 || n === 0 || n === 1 && t === i - 1 && t === s + 1 ? "" : e.slice(t, i)
    }, parse(e) {
        Gt(e);
        const t = {root: "", dir: "", base: "", ext: "", name: ""};
        if (e.length === 0) return t;
        e = ts(this.toPosix(e));
        let s = e.charCodeAt(0);
        const i = this.isAbsolute(e);
        let r;
        const n = "";
        t.root = this.rootname(e), i || this.hasProtocol(e) ? r = 1 : r = 0;
        let o = -1, a = 0, h = -1, l = !0, c = e.length - 1, u = 0;
        for (; c >= r; --c) {
            if (s = e.charCodeAt(c), s === 47) {
                if (!l) {
                    a = c + 1;
                    break
                }
                continue
            }
            h === -1 && (l = !1, h = c + 1), s === 46 ? o === -1 ? o = c : u !== 1 && (u = 1) : o !== -1 && (u = -1)
        }
        return o === -1 || h === -1 || u === 0 || u === 1 && o === h - 1 && o === a + 1 ? h !== -1 && (a === 0 && i ? t.base = t.name = e.slice(1, h) : t.base = t.name = e.slice(a, h)) : (a === 0 && i ? (t.name = e.slice(1, o), t.base = e.slice(1, h)) : (t.name = e.slice(a, o), t.base = e.slice(a, h)), t.ext = e.slice(o, h)), t.dir = this.dirname(e), n && (t.dir = n + t.dir), t
    }, sep: "/", delimiter: ":"
}, io = {};

function Y(e, t, s = 3) {
    if (io[t]) return;
    let i = new Error().stack;
    typeof i == "undefined" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`) : (i = i.split(`
`).splice(s).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${e}`), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`), console.warn(i))), io[t] = !0
}

function ol() {
    Y("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}

function al() {
    Y("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
}

let Yi;

function ro() {
    return typeof Yi == "undefined" && (Yi = function () {
        var s;
        const t = {stencil: !0, failIfMajorPerformanceCaveat: M.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT};
        try {
            if (!M.ADAPTER.getWebGLRenderingContext()) return !1;
            const i = M.ADAPTER.createCanvas();
            let r = i.getContext("webgl", t) || i.getContext("experimental-webgl", t);
            const n = !!((s = r == null ? void 0 : r.getContextAttributes()) != null && s.stencil);
            if (r) {
                const o = r.getExtension("WEBGL_lose_context");
                o && o.loseContext()
            }
            return r = null, n
        } catch (i) {
            return !1
        }
    }()), Yi
}

var hl = "#f0f8ff", ll = "#faebd7", cl = "#00ffff", ul = "#7fffd4", dl = "#f0ffff", fl = "#f5f5dc", pl = "#ffe4c4",
    ml = "#000000", _l = "#ffebcd", gl = "#0000ff", xl = "#8a2be2", vl = "#a52a2a", yl = "#deb887", Tl = "#5f9ea0",
    bl = "#7fff00", El = "#d2691e", wl = "#ff7f50", Al = "#6495ed", Sl = "#fff8dc", Rl = "#dc143c", Cl = "#00ffff",
    Il = "#00008b", Pl = "#008b8b", Ml = "#b8860b", Bl = "#a9a9a9", Dl = "#006400", Fl = "#a9a9a9", Nl = "#bdb76b",
    Ll = "#8b008b", Ol = "#556b2f", Ul = "#ff8c00", kl = "#9932cc", Gl = "#8b0000", Hl = "#e9967a", Xl = "#8fbc8f",
    Vl = "#483d8b", zl = "#2f4f4f", Wl = "#2f4f4f", jl = "#00ced1", $l = "#9400d3", Yl = "#ff1493", ql = "#00bfff",
    Kl = "#696969", Zl = "#696969", Ql = "#1e90ff", Jl = "#b22222", tc = "#fffaf0", ec = "#228b22", sc = "#ff00ff",
    ic = "#dcdcdc", rc = "#f8f8ff", nc = "#daa520", oc = "#ffd700", ac = "#808080", hc = "#008000", lc = "#adff2f",
    cc = "#808080", uc = "#f0fff0", dc = "#ff69b4", fc = "#cd5c5c", pc = "#4b0082", mc = "#fffff0", _c = "#f0e68c",
    gc = "#fff0f5", xc = "#e6e6fa", vc = "#7cfc00", yc = "#fffacd", Tc = "#add8e6", bc = "#f08080", Ec = "#e0ffff",
    wc = "#fafad2", Ac = "#d3d3d3", Sc = "#90ee90", Rc = "#d3d3d3", Cc = "#ffb6c1", Ic = "#ffa07a", Pc = "#20b2aa",
    Mc = "#87cefa", Bc = "#778899", Dc = "#778899", Fc = "#b0c4de", Nc = "#ffffe0", Lc = "#00ff00", Oc = "#32cd32",
    Uc = "#faf0e6", kc = "#ff00ff", Gc = "#800000", Hc = "#66cdaa", Xc = "#0000cd", Vc = "#ba55d3", zc = "#9370db",
    Wc = "#3cb371", jc = "#7b68ee", $c = "#00fa9a", Yc = "#48d1cc", qc = "#c71585", Kc = "#191970", Zc = "#f5fffa",
    Qc = "#ffe4e1", Jc = "#ffe4b5", tu = "#ffdead", eu = "#000080", su = "#fdf5e6", iu = "#808000", ru = "#6b8e23",
    nu = "#ffa500", ou = "#ff4500", au = "#da70d6", hu = "#eee8aa", lu = "#98fb98", cu = "#afeeee", uu = "#db7093",
    du = "#ffefd5", fu = "#ffdab9", pu = "#cd853f", mu = "#ffc0cb", _u = "#dda0dd", gu = "#b0e0e6", xu = "#800080",
    vu = "#663399", yu = "#ff0000", Tu = "#bc8f8f", bu = "#4169e1", Eu = "#8b4513", wu = "#fa8072", Au = "#f4a460",
    Su = "#2e8b57", Ru = "#fff5ee", Cu = "#a0522d", Iu = "#c0c0c0", Pu = "#87ceeb", Mu = "#6a5acd", Bu = "#708090",
    Du = "#708090", Fu = "#fffafa", Nu = "#00ff7f", Lu = "#4682b4", Ou = "#d2b48c", Uu = "#008080", ku = "#d8bfd8",
    Gu = "#ff6347", Hu = "#40e0d0", Xu = "#ee82ee", Vu = "#f5deb3", zu = "#ffffff", Wu = "#f5f5f5", ju = "#ffff00",
    $u = "#9acd32", Yu = {
        aliceblue: hl,
        antiquewhite: ll,
        aqua: cl,
        aquamarine: ul,
        azure: dl,
        beige: fl,
        bisque: pl,
        black: ml,
        blanchedalmond: _l,
        blue: gl,
        blueviolet: xl,
        brown: vl,
        burlywood: yl,
        cadetblue: Tl,
        chartreuse: bl,
        chocolate: El,
        coral: wl,
        cornflowerblue: Al,
        cornsilk: Sl,
        crimson: Rl,
        cyan: Cl,
        darkblue: Il,
        darkcyan: Pl,
        darkgoldenrod: Ml,
        darkgray: Bl,
        darkgreen: Dl,
        darkgrey: Fl,
        darkkhaki: Nl,
        darkmagenta: Ll,
        darkolivegreen: Ol,
        darkorange: Ul,
        darkorchid: kl,
        darkred: Gl,
        darksalmon: Hl,
        darkseagreen: Xl,
        darkslateblue: Vl,
        darkslategray: zl,
        darkslategrey: Wl,
        darkturquoise: jl,
        darkviolet: $l,
        deeppink: Yl,
        deepskyblue: ql,
        dimgray: Kl,
        dimgrey: Zl,
        dodgerblue: Ql,
        firebrick: Jl,
        floralwhite: tc,
        forestgreen: ec,
        fuchsia: sc,
        gainsboro: ic,
        ghostwhite: rc,
        goldenrod: nc,
        gold: oc,
        gray: ac,
        green: hc,
        greenyellow: lc,
        grey: cc,
        honeydew: uc,
        hotpink: dc,
        indianred: fc,
        indigo: pc,
        ivory: mc,
        khaki: _c,
        lavenderblush: gc,
        lavender: xc,
        lawngreen: vc,
        lemonchiffon: yc,
        lightblue: Tc,
        lightcoral: bc,
        lightcyan: Ec,
        lightgoldenrodyellow: wc,
        lightgray: Ac,
        lightgreen: Sc,
        lightgrey: Rc,
        lightpink: Cc,
        lightsalmon: Ic,
        lightseagreen: Pc,
        lightskyblue: Mc,
        lightslategray: Bc,
        lightslategrey: Dc,
        lightsteelblue: Fc,
        lightyellow: Nc,
        lime: Lc,
        limegreen: Oc,
        linen: Uc,
        magenta: kc,
        maroon: Gc,
        mediumaquamarine: Hc,
        mediumblue: Xc,
        mediumorchid: Vc,
        mediumpurple: zc,
        mediumseagreen: Wc,
        mediumslateblue: jc,
        mediumspringgreen: $c,
        mediumturquoise: Yc,
        mediumvioletred: qc,
        midnightblue: Kc,
        mintcream: Zc,
        mistyrose: Qc,
        moccasin: Jc,
        navajowhite: tu,
        navy: eu,
        oldlace: su,
        olive: iu,
        olivedrab: ru,
        orange: nu,
        orangered: ou,
        orchid: au,
        palegoldenrod: hu,
        palegreen: lu,
        paleturquoise: cu,
        palevioletred: uu,
        papayawhip: du,
        peachpuff: fu,
        peru: pu,
        pink: mu,
        plum: _u,
        powderblue: gu,
        purple: xu,
        rebeccapurple: vu,
        red: yu,
        rosybrown: Tu,
        royalblue: bu,
        saddlebrown: Eu,
        salmon: wu,
        sandybrown: Au,
        seagreen: Su,
        seashell: Ru,
        sienna: Cu,
        silver: Iu,
        skyblue: Pu,
        slateblue: Mu,
        slategray: Bu,
        slategrey: Du,
        snow: Fu,
        springgreen: Nu,
        steelblue: Lu,
        tan: Ou,
        teal: Uu,
        thistle: ku,
        tomato: Gu,
        turquoise: Hu,
        violet: Xu,
        wheat: Vu,
        white: zu,
        whitesmoke: Wu,
        yellow: ju,
        yellowgreen: $u
    };

function xe(e, t = []) {
    return t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255, t
}

function qi(e) {
    let t = e.toString(16);
    return t = "000000".substring(0, 6 - t.length) + t, `#${t}`
}

function Gs(e) {
    if (typeof e == "string" && (e = Yu[e.toLowerCase()] || e, e[0] === "#" && (e = e.slice(1)), e.length === 3)) {
        const [t, s, i] = e;
        e = t + t + s + s + i + i
    }
    return parseInt(e, 16)
}

function qu(e) {
    return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0)
}

function Ku() {
    const e = [], t = [];
    for (let i = 0; i < 32; i++) e[i] = i, t[i] = i;
    e[k.NORMAL_NPM] = k.NORMAL, e[k.ADD_NPM] = k.ADD, e[k.SCREEN_NPM] = k.SCREEN, t[k.NORMAL] = k.NORMAL_NPM, t[k.ADD] = k.ADD_NPM, t[k.SCREEN] = k.SCREEN_NPM;
    const s = [];
    return s.push(t), s.push(e), s
}

const Ki = Ku();

function Zi(e, t) {
    return Ki[t ? 1 : 0][e]
}

function no(e, t, s, i) {
    return s = s || new Float32Array(4), i || i === void 0 ? (s[0] = e[0] * t, s[1] = e[1] * t, s[2] = e[2] * t) : (s[0] = e[0], s[1] = e[1], s[2] = e[2]), s[3] = t, s
}

function Hs(e, t) {
    if (t === 1) return (t * 255 << 24) + e;
    if (t === 0) return 0;
    let s = e >> 16 & 255, i = e >> 8 & 255, r = e & 255;
    return s = s * t + .5 | 0, i = i * t + .5 | 0, r = r * t + .5 | 0, (t * 255 << 24) + (s << 16) + (i << 8) + r
}

function Qi(e, t, s, i) {
    return s = s || new Float32Array(4), s[0] = (e >> 16 & 255) / 255, s[1] = (e >> 8 & 255) / 255, s[2] = (e & 255) / 255, (i || i === void 0) && (s[0] *= t, s[1] *= t, s[2] *= t), s[3] = t, s
}

const oo = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

function ao(e, t = null) {
    const s = e * 6;
    if (t = t || new Uint16Array(s), t.length !== s) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${s}`);
    for (let i = 0, r = 0; i < s; i += 6, r += 4) t[i + 0] = r + 0, t[i + 1] = r + 1, t[i + 2] = r + 2, t[i + 3] = r + 0, t[i + 4] = r + 2, t[i + 5] = r + 3;
    return t
}

function Xs(e) {
    if (e.BYTES_PER_ELEMENT === 4) return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (e.BYTES_PER_ELEMENT === 2) {
        if (e instanceof Uint16Array) return "Uint16Array"
    } else if (e.BYTES_PER_ELEMENT === 1 && e instanceof Uint8Array) return "Uint8Array";
    return null
}

const Zu = {Float32Array, Uint32Array, Int32Array, Uint8Array};

function Qu(e, t) {
    let s = 0, i = 0;
    const r = {};
    for (let h = 0; h < e.length; h++) i += t[h], s += e[h].length;
    const n = new ArrayBuffer(s * 4);
    let o = null, a = 0;
    for (let h = 0; h < e.length; h++) {
        const l = t[h], c = e[h], u = Xs(c);
        r[u] || (r[u] = new Zu[u](n)), o = r[u];
        for (let d = 0; d < c.length; d++) {
            const f = (d / l | 0) * i + a, p = d % l;
            o[f + p] = c[d]
        }
        a += l
    }
    return new Float32Array(n)
}

function es(e) {
    return e += e === 0 ? 1 : 0, --e, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e + 1
}

function Ji(e) {
    return !(e & e - 1) && !!e
}

function tr(e) {
    let t = (e > 65535 ? 1 : 0) << 4;
    e >>>= t;
    let s = (e > 255 ? 1 : 0) << 3;
    return e >>>= s, t |= s, s = (e > 15 ? 1 : 0) << 2, e >>>= s, t |= s, s = (e > 3 ? 1 : 0) << 1, e >>>= s, t |= s, t | e >> 1
}

function ve(e, t, s) {
    const i = e.length;
    let r;
    if (t >= i || s === 0) return;
    s = t + s > i ? i - t : s;
    const n = i - s;
    for (r = t; r < n; ++r) e[r] = e[r + s];
    e.length = n
}

function ye(e) {
    return e === 0 ? 0 : e < 0 ? -1 : 1
}

let Ju = 0;

function le() {
    return ++Ju
}

const ho = class {
    constructor(e, t, s, i) {
        this.left = e, this.top = t, this.right = s, this.bottom = i
    }

    get width() {
        return this.right - this.left
    }

    get height() {
        return this.bottom - this.top
    }

    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
};
let Vs = ho;
Vs.EMPTY = new ho(0, 0, 0, 0);
const er = {}, vt = Object.create(null), At = Object.create(null);

function td() {
    let e;
    for (e in vt) vt[e].destroy();
    for (e in At) At[e].destroy()
}

function ed() {
    let e;
    for (e in vt) delete vt[e];
    for (e in At) delete At[e]
}

class sr {
    constructor(t, s, i) {
        this._canvas = M.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = i || M.RESOLUTION, this.resize(t, s)
    }

    clear() {
        this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }

    resize(t, s) {
        this._checkDestroyed(), this._canvas.width = Math.round(t * this.resolution), this._canvas.height = Math.round(s * this.resolution)
    }

    destroy() {
        this._context = null, this._canvas = null
    }

    get width() {
        return this._checkDestroyed(), this._canvas.width
    }

    set width(t) {
        this._checkDestroyed(), this._canvas.width = Math.round(t)
    }

    get height() {
        return this._checkDestroyed(), this._canvas.height
    }

    set height(t) {
        this._checkDestroyed(), this._canvas.height = Math.round(t)
    }

    get canvas() {
        return this._checkDestroyed(), this._canvas
    }

    get context() {
        return this._checkDestroyed(), this._context
    }

    _checkDestroyed() {
        if (this._canvas === null) throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}

function lo(e, t, s) {
    for (let i = 0, r = 4 * s * t; i < t; ++i, r += 4) if (e[r + 3] !== 0) return !1;
    return !0
}

function co(e, t, s, i, r) {
    const n = 4 * t;
    for (let o = i, a = i * n + 4 * s; o <= r; ++o, a += n) if (e[a + 3] !== 0) return !1;
    return !0
}

function uo(e) {
    const {width: t, height: s} = e, i = e.getContext("2d", {willReadFrequently: !0});
    if (i === null) throw new TypeError("Failed to get canvas 2D context");
    const n = i.getImageData(0, 0, t, s).data;
    let o = 0, a = 0, h = t - 1, l = s - 1;
    for (; a < s && lo(n, t, a);) ++a;
    if (a === s) return Vs.EMPTY;
    for (; lo(n, t, l);) --l;
    for (; co(n, t, o, a, l);) ++o;
    for (; co(n, t, h, a, l);) --h;
    return ++h, ++l, new Vs(o, a, h, l)
}

function fo(e) {
    const t = uo(e), {width: s, height: i} = t;
    let r = null;
    if (!t.isEmpty()) {
        const n = e.getContext("2d");
        if (n === null) throw new TypeError("Failed to get canvas 2D context");
        r = n.getImageData(t.left, t.top, s, i)
    }
    return {width: s, height: i, data: r}
}

function sd(e) {
    const t = oo.exec(e);
    if (t) return {
        mediaType: t[1] ? t[1].toLowerCase() : void 0,
        subType: t[2] ? t[2].toLowerCase() : void 0,
        charset: t[3] ? t[3].toLowerCase() : void 0,
        encoding: t[4] ? t[4].toLowerCase() : void 0,
        data: t[5]
    }
}

let zs;

function po(e, t = globalThis.location) {
    if (e.startsWith("data:")) return "";
    t = t || globalThis.location, zs || (zs = document.createElement("a")), zs.href = e;
    const s = so.parse(zs.href), i = !s.port && t.port === "" || s.port === t.port;
    return s.hostname !== t.hostname || !i || s.protocol !== t.protocol ? "anonymous" : ""
}

function ee(e, t = 1) {
    var i;
    const s = (i = M.RETINA_PREFIX) == null ? void 0 : i.exec(e);
    return s ? parseFloat(s[1]) : t
}

var id = {
        __proto__: null,
        isMobile: kt,
        EventEmitter: De,
        earcut: Hi,
        url: so,
        path: ft,
        sayHello: al,
        skipHello: ol,
        isWebGLSupported: ro,
        hex2rgb: xe,
        hex2string: qi,
        rgb2hex: qu,
        string2hex: Gs,
        correctBlendMode: Zi,
        premultiplyBlendMode: Ki,
        premultiplyRgba: no,
        premultiplyTint: Hs,
        premultiplyTintToRgba: Qi,
        DATA_URI: oo,
        createIndicesForQuads: ao,
        getBufferType: Xs,
        interleaveTypedArrays: Qu,
        isPow2: Ji,
        log2: tr,
        nextPow2: es,
        removeItems: ve,
        sign: ye,
        uid: le,
        deprecation: Y,
        BoundingBox: Vs,
        BaseTextureCache: At,
        ProgramCache: er,
        TextureCache: vt,
        clearTextureCache: ed,
        destroyTextureCache: td,
        CanvasRenderTarget: sr,
        getCanvasBoundingBox: uo,
        trimCanvas: fo,
        decomposeDataUri: sd,
        determineCrossOrigin: po,
        getResolutionOfUrl: ee
    },
    I = (e => (e.Renderer = "renderer", e.Application = "application", e.RendererSystem = "renderer-webgl-system", e.RendererPlugin = "renderer-webgl-plugin", e.CanvasRendererSystem = "renderer-canvas-system", e.CanvasRendererPlugin = "renderer-canvas-plugin", e.Asset = "asset", e.LoadParser = "load-parser", e.ResolveParser = "resolve-parser", e.CacheParser = "cache-parser", e.DetectionParser = "detection-parser", e))(I || {});
const ir = e => {
    if (typeof e == "function" || typeof e == "object" && e.extension) {
        if (!e.extension) throw new Error("Extension class must have an extension object");
        const t = typeof e.extension != "object" ? {type: e.extension} : e.extension;
        e = Ni(Yt({}, t), {ref: e})
    }
    if (typeof e == "object") e = Yt({}, e); else throw new Error("Invalid extension type");
    return typeof e.type == "string" && (e.type = [e.type]), e
}, mo = (e, t) => {
    var s;
    return (s = ir(e).priority) != null ? s : t
}, O = {
    _addHandlers: {}, _removeHandlers: {}, _queue: {}, remove(...e) {
        return e.map(ir).forEach(t => {
            t.type.forEach(s => {
                var i, r;
                return (r = (i = this._removeHandlers)[s]) == null ? void 0 : r.call(i, t)
            })
        }), this
    }, add(...e) {
        return e.map(ir).forEach(t => {
            t.type.forEach(s => {
                const i = this._addHandlers, r = this._queue;
                i[s] ? i[s](t) : (r[s] = r[s] || [], r[s].push(t))
            })
        }), this
    }, handle(e, t, s) {
        const i = this._addHandlers, r = this._removeHandlers;
        if (i[e] || r[e]) throw new Error(`Extension type ${e} already has a handler`);
        i[e] = t, r[e] = s;
        const n = this._queue;
        return n[e] && (n[e].forEach(o => t(o)), delete n[e]), this
    }, handleByMap(e, t) {
        return this.handle(e, s => {
            t[s.name] = s.ref
        }, s => {
            delete t[s.name]
        })
    }, handleByList(e, t, s = -1) {
        return this.handle(e, i => {
            t.includes(i.ref) || (t.push(i.ref), t.sort((r, n) => mo(n, s) - mo(r, s)))
        }, i => {
            const r = t.indexOf(i.ref);
            r !== -1 && t.splice(r, 1)
        })
    }
};

class Ws {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
    }

    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
    }

    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
    }

    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
    }

    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
    }

    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
    }

    view(t) {
        return this[`${t}View`]
    }

    destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
    }

    static sizeOf(t) {
        switch (t) {
            case"int8":
            case"uint8":
                return 1;
            case"int16":
            case"uint16":
                return 2;
            case"int32":
            case"uint32":
            case"float32":
                return 4;
            default:
                throw new Error(`${t} isn't a valid view type`)
        }
    }
}

const rd = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

function nd(e) {
    let t = "";
    for (let s = 0; s < e; ++s) s > 0 && (t += `
else `), s < e - 1 && (t += `if(test == ${s}.0){}`);
    return t
}

function _o(e, t) {
    if (e === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const s = t.createShader(t.FRAGMENT_SHADER);
    for (; ;) {
        const i = rd.replace(/%forloop%/gi, nd(e));
        if (t.shaderSource(s, i), t.compileShader(s), !t.getShaderParameter(s, t.COMPILE_STATUS)) e = e / 2 | 0; else break
    }
    return e
}

const rr = 0, nr = 1, or = 2, ar = 3, hr = 4, lr = 5;

class Jt {
    constructor() {
        this.data = 0, this.blendMode = k.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
    }

    get blend() {
        return !!(this.data & 1 << rr)
    }

    set blend(t) {
        !!(this.data & 1 << rr) !== t && (this.data ^= 1 << rr)
    }

    get offsets() {
        return !!(this.data & 1 << nr)
    }

    set offsets(t) {
        !!(this.data & 1 << nr) !== t && (this.data ^= 1 << nr)
    }

    get culling() {
        return !!(this.data & 1 << or)
    }

    set culling(t) {
        !!(this.data & 1 << or) !== t && (this.data ^= 1 << or)
    }

    get depthTest() {
        return !!(this.data & 1 << ar)
    }

    set depthTest(t) {
        !!(this.data & 1 << ar) !== t && (this.data ^= 1 << ar)
    }

    get depthMask() {
        return !!(this.data & 1 << lr)
    }

    set depthMask(t) {
        !!(this.data & 1 << lr) !== t && (this.data ^= 1 << lr)
    }

    get clockwiseFrontFace() {
        return !!(this.data & 1 << hr)
    }

    set clockwiseFrontFace(t) {
        !!(this.data & 1 << hr) !== t && (this.data ^= 1 << hr)
    }

    get blendMode() {
        return this._blendMode
    }

    set blendMode(t) {
        this.blend = t !== k.NONE, this._blendMode = t
    }

    get polygonOffset() {
        return this._polygonOffset
    }

    set polygonOffset(t) {
        this.offsets = !!t, this._polygonOffset = t
    }

    toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
    }

    static for2d() {
        const t = new Jt;
        return t.depthTest = !1, t.blend = !0, t
    }
}

const js = [];

function cr(e, t) {
    if (!e) return null;
    let s = "";
    if (typeof e == "string") {
        const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
        i && (s = i[1].toLowerCase())
    }
    for (let i = js.length - 1; i >= 0; --i) {
        const r = js[i];
        if (r.test && r.test(e, s)) return new r(e, t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}

class St {
    constructor(t) {
        this.items = [], this._name = t, this._aliasCount = 0
    }

    emit(t, s, i, r, n, o, a, h) {
        if (arguments.length > 8) throw new Error("max arguments reached");
        const {name: l, items: c} = this;
        this._aliasCount++;
        for (let u = 0, d = c.length; u < d; u++) c[u][l](t, s, i, r, n, o, a, h);
        return c === this.items && this._aliasCount--, this
    }

    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
    }

    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
    }

    remove(t) {
        const s = this.items.indexOf(t);
        return s !== -1 && (this.ensureNonAliasedItems(), this.items.splice(s, 1)), this
    }

    contains(t) {
        return this.items.includes(t)
    }

    removeAll() {
        return this.ensureNonAliasedItems(), this.items.length = 0, this
    }

    destroy() {
        this.removeAll(), this.items = null, this._name = null
    }

    get empty() {
        return this.items.length === 0
    }

    get name() {
        return this._name
    }
}

Object.defineProperties(St.prototype, {dispatch: {value: St.prototype.emit}, run: {value: St.prototype.emit}});

class Le {
    constructor(t = 0, s = 0) {
        this._width = t, this._height = s, this.destroyed = !1, this.internal = !1, this.onResize = new St("setRealSize"), this.onUpdate = new St("update"), this.onError = new St("onError")
    }

    bind(t) {
        this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }

    unbind(t) {
        this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
    }

    resize(t, s) {
        (t !== this._width || s !== this._height) && (this._width = t, this._height = s, this.onResize.emit(t, s))
    }

    get valid() {
        return !!this._width && !!this._height
    }

    update() {
        this.destroyed || this.onUpdate.emit()
    }

    load() {
        return Promise.resolve(this)
    }

    get width() {
        return this._width
    }

    get height() {
        return this._height
    }

    style(t, s, i) {
        return !1
    }

    dispose() {
    }

    destroy() {
        this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
    }

    static test(t, s) {
        return !1
    }
}

class Oe extends Le {
    constructor(t, s) {
        const {width: i, height: r} = s || {};
        if (!i || !r) throw new Error("BufferResource width or height invalid");
        super(i, r), this.data = t
    }

    upload(t, s, i) {
        const r = t.gl;
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.alphaMode === Ct.UNPACK);
        const n = s.realWidth, o = s.realHeight;
        return i.width === n && i.height === o ? r.texSubImage2D(s.target, 0, 0, 0, n, o, s.format, i.type, this.data) : (i.width = n, i.height = o, r.texImage2D(s.target, 0, i.internalFormat, n, o, 0, s.format, i.type, this.data)), !0
    }

    dispose() {
        this.data = null
    }

    static test(t) {
        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
    }
}

const od = {scaleMode: qt.NEAREST, format: R.RGBA, alphaMode: Ct.NPM}, Ue = class extends De {
    constructor(e = null, t = null) {
        super(), t = Object.assign({}, Ue.defaultOptions, t);
        const {
            alphaMode: s,
            mipmap: i,
            anisotropicLevel: r,
            scaleMode: n,
            width: o,
            height: a,
            wrapMode: h,
            format: l,
            type: c,
            target: u,
            resolution: d,
            resourceOptions: f
        } = t;
        e && !(e instanceof Le) && (e = cr(e, f), e.internal = !0), this.resolution = d || M.RESOLUTION, this.width = Math.round((o || 0) * this.resolution) / this.resolution, this.height = Math.round((a || 0) * this.resolution) / this.resolution, this._mipmap = i, this.anisotropicLevel = r, this._wrapMode = h, this._scaleMode = n, this.format = l, this.type = c, this.target = u, this.alphaMode = s, this.uid = le(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = o > 0 && a > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(e)
    }

    get realWidth() {
        return Math.round(this.width * this.resolution)
    }

    get realHeight() {
        return Math.round(this.height * this.resolution)
    }

    get mipmap() {
        return this._mipmap
    }

    set mipmap(e) {
        this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++)
    }

    get scaleMode() {
        return this._scaleMode
    }

    set scaleMode(e) {
        this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++)
    }

    get wrapMode() {
        return this._wrapMode
    }

    set wrapMode(e) {
        this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++)
    }

    setStyle(e, t) {
        let s;
        return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, s = !0), t !== void 0 && t !== this.mipmap && (this.mipmap = t, s = !0), s && this.dirtyStyleId++, this
    }

    setSize(e, t, s) {
        return s = s || this.resolution, this.setRealSize(e * s, t * s, s)
    }

    setRealSize(e, t, s) {
        return this.resolution = s || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(t) / this.resolution, this._refreshPOT(), this.update(), this
    }

    _refreshPOT() {
        this.isPowerOfTwo = Ji(this.realWidth) && Ji(this.realHeight)
    }

    setResolution(e) {
        const t = this.resolution;
        return t === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * t) / e, this.height = Math.round(this.height * t) / e, this.emit("update", this)), this._refreshPOT(), this)
    }

    setResource(e) {
        if (this.resource === e) return this;
        if (this.resource) throw new Error("Resource can be set only once");
        return e.bind(this), this.resource = e, this
    }

    update() {
        this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
    }

    onError(e) {
        this.emit("error", this, e)
    }

    destroy() {
        this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete At[this.cacheId], delete vt[this.cacheId], this.cacheId = null), this.dispose(), Ue.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
    }

    dispose() {
        this.emit("dispose", this)
    }

    castToBaseTexture() {
        return this
    }

    static from(e, t, s = M.STRICT_TEXTURE_CACHE) {
        const i = typeof e == "string";
        let r = null;
        if (i) r = e; else {
            if (!e._pixiId) {
                const o = (t == null ? void 0 : t.pixiIdPrefix) || "pixiid";
                e._pixiId = `${o}_${le()}`
            }
            r = e._pixiId
        }
        let n = At[r];
        if (i && s && !n) throw new Error(`The cacheId "${r}" does not exist in BaseTextureCache.`);
        return n || (n = new Ue(e, t), n.cacheId = r, Ue.addToCache(n, r)), n
    }

    static fromBuffer(e, t, s, i) {
        e = e || new Float32Array(t * s * 4);
        const r = new Oe(e, {width: t, height: s}), n = e instanceof Float32Array ? U.FLOAT : U.UNSIGNED_BYTE;
        return new Ue(r, Object.assign({}, od, i || {width: t, height: s, type: n}))
    }

    static addToCache(e, t) {
        t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), At[t] && At[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`), At[t] = e)
    }

    static removeFromCache(e) {
        if (typeof e == "string") {
            const t = At[e];
            if (t) {
                const s = t.textureCacheIds.indexOf(e);
                return s > -1 && t.textureCacheIds.splice(s, 1), delete At[e], t
            }
        } else if (e != null && e.textureCacheIds) {
            for (let t = 0; t < e.textureCacheIds.length; ++t) delete At[e.textureCacheIds[t]];
            return e.textureCacheIds.length = 0, e
        }
        return null
    }
};
let X = Ue;
X.defaultOptions = {
    mipmap: Lt.POW2,
    anisotropicLevel: 0,
    scaleMode: qt.LINEAR,
    wrapMode: Kt.CLAMP,
    alphaMode: Ct.UNPACK,
    target: _e.TEXTURE_2D,
    format: R.RGBA,
    type: U.UNSIGNED_BYTE
}, X._globalBatch = 0;

class $s {
    constructor() {
        this.texArray = null, this.blend = 0, this.type = Nt.TRIANGLES, this.start = 0, this.size = 0, this.data = null
    }
}

let ad = 0;

class nt {
    constructor(t, s = !0, i = !1) {
        this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = s, this.id = ad++, this.disposeRunner = new St("disposeBuffer")
    }

    update(t) {
        t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
    }

    dispose() {
        this.disposeRunner.emit(this, !1)
    }

    destroy() {
        this.dispose(), this.data = null
    }

    set index(t) {
        this.type = t ? Ut.ELEMENT_ARRAY_BUFFER : Ut.ARRAY_BUFFER
    }

    get index() {
        return this.type === Ut.ELEMENT_ARRAY_BUFFER
    }

    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)), new nt(t)
    }
}

class Cs {
    constructor(t, s = 0, i = !1, r = U.FLOAT, n, o, a, h = 1) {
        this.buffer = t, this.size = s, this.normalized = i, this.type = r, this.stride = n, this.start = o, this.instance = a, this.divisor = h
    }

    destroy() {
        this.buffer = null
    }

    static from(t, s, i, r, n) {
        return new Cs(t, s, i, r, n)
    }
}

const hd = {Float32Array, Uint32Array, Int32Array, Uint8Array};

function ld(e, t) {
    let s = 0, i = 0;
    const r = {};
    for (let h = 0; h < e.length; h++) i += t[h], s += e[h].length;
    const n = new ArrayBuffer(s * 4);
    let o = null, a = 0;
    for (let h = 0; h < e.length; h++) {
        const l = t[h], c = e[h], u = Xs(c);
        r[u] || (r[u] = new hd[u](n)), o = r[u];
        for (let d = 0; d < c.length; d++) {
            const f = (d / l | 0) * i + a, p = d % l;
            o[f + p] = c[d]
        }
        a += l
    }
    return new Float32Array(n)
}

const go = {5126: 4, 5123: 2, 5121: 1};
let cd = 0;
const ud = {Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array};

class ae {
    constructor(t = [], s = {}) {
        this.buffers = t, this.indexBuffer = null, this.attributes = s, this.glVertexArrayObjects = {}, this.id = cd++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new St("disposeGeometry"), this.refCount = 0
    }

    addAttribute(t, s, i = 0, r = !1, n, o, a, h = !1) {
        if (!s) throw new Error("You must pass a buffer when creating an attribute");
        s instanceof nt || (s instanceof Array && (s = new Float32Array(s)), s = new nt(s));
        const l = t.split("|");
        if (l.length > 1) {
            for (let u = 0; u < l.length; u++) this.addAttribute(l[u], s, i, r, n);
            return this
        }
        let c = this.buffers.indexOf(s);
        return c === -1 && (this.buffers.push(s), c = this.buffers.length - 1), this.attributes[t] = new Cs(c, i, r, n, o, a, h), this.instanced = this.instanced || h, this
    }

    getAttribute(t) {
        return this.attributes[t]
    }

    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }

    addIndex(t) {
        return t instanceof nt || (t instanceof Array && (t = new Uint16Array(t)), t = new nt(t)), t.type = Ut.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.includes(t) || this.buffers.push(t), this
    }

    getIndex() {
        return this.indexBuffer
    }

    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;
        const t = [], s = [], i = new nt;
        let r;
        for (r in this.attributes) {
            const n = this.attributes[r], o = this.buffers[n.buffer];
            t.push(o.data), s.push(n.size * go[n.type] / 4), n.buffer = 0
        }
        for (i.data = ld(t, s), r = 0; r < this.buffers.length; r++) this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
        return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this
    }

    getSize() {
        for (const t in this.attributes) {
            const s = this.attributes[t];
            return this.buffers[s.buffer].data.length / (s.stride / 4 || s.size)
        }
        return 0
    }

    dispose() {
        this.disposeRunner.emit(this, !1)
    }

    destroy() {
        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
    }

    clone() {
        const t = new ae;
        for (let s = 0; s < this.buffers.length; s++) t.buffers[s] = new nt(this.buffers[s].data.slice(0));
        for (const s in this.attributes) {
            const i = this.attributes[s];
            t.attributes[s] = new Cs(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = Ut.ELEMENT_ARRAY_BUFFER), t
    }

    static merge(t) {
        const s = new ae, i = [], r = [], n = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let h = 0; h < o.buffers.length; h++) r[h] = r[h] || 0, r[h] += o.buffers[h].data.length, n[h] = 0
        }
        for (let a = 0; a < o.buffers.length; a++) i[a] = new ud[Xs(o.buffers[a].data)](r[a]), s.buffers[a] = new nt(i[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let h = 0; h < o.buffers.length; h++) i[h].set(o.buffers[h].data, n[h]), n[h] += o.buffers[h].data.length
        }
        if (s.attributes = o.attributes, o.indexBuffer) {
            s.indexBuffer = s.buffers[o.buffers.indexOf(o.indexBuffer)], s.indexBuffer.type = Ut.ELEMENT_ARRAY_BUFFER;
            let a = 0, h = 0, l = 0, c = 0;
            for (let u = 0; u < o.buffers.length; u++) if (o.buffers[u] !== o.indexBuffer) {
                c = u;
                break
            }
            for (const u in o.attributes) {
                const d = o.attributes[u];
                (d.buffer | 0) === c && (h += d.size * go[d.type] / 4)
            }
            for (let u = 0; u < t.length; u++) {
                const d = t[u].indexBuffer.data;
                for (let f = 0; f < d.length; f++) s.indexBuffer.data[f + l] += a;
                a += t[u].buffers[c].data.length / h, l += d.length
            }
        }
        return s
    }
}

class ur extends ae {
    constructor(t = !1) {
        super(), this._buffer = new nt(null, t, !1), this._indexBuffer = new nt(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, U.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, U.FLOAT).addAttribute("aColor", this._buffer, 4, !0, U.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, U.FLOAT).addIndex(this._indexBuffer)
    }
}

const ss = Math.PI * 2, xo = 180 / Math.PI, vo = Math.PI / 180;
var pt = (e => (e[e.POLY = 0] = "POLY", e[e.RECT = 1] = "RECT", e[e.CIRC = 2] = "CIRC", e[e.ELIP = 3] = "ELIP", e[e.RREC = 4] = "RREC", e))(pt || {});

class j {
    constructor(t = 0, s = 0) {
        this.x = 0, this.y = 0, this.x = t, this.y = s
    }

    clone() {
        return new j(this.x, this.y)
    }

    copyFrom(t) {
        return this.set(t.x, t.y), this
    }

    copyTo(t) {
        return t.set(this.x, this.y), t
    }

    equals(t) {
        return t.x === this.x && t.y === this.y
    }

    set(t = 0, s = t) {
        return this.x = t, this.y = s, this
    }

    toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
    }
}

const Ys = [new j, new j, new j, new j];

class z {
    constructor(t = 0, s = 0, i = 0, r = 0) {
        this.x = Number(t), this.y = Number(s), this.width = Number(i), this.height = Number(r), this.type = pt.RECT
    }

    get left() {
        return this.x
    }

    get right() {
        return this.x + this.width
    }

    get top() {
        return this.y
    }

    get bottom() {
        return this.y + this.height
    }

    static get EMPTY() {
        return new z(0, 0, 0, 0)
    }

    clone() {
        return new z(this.x, this.y, this.width, this.height)
    }

    copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
    }

    copyTo(t) {
        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
    }

    contains(t, s) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && s >= this.y && s < this.y + this.height
    }

    intersects(t, s) {
        if (!s) {
            const b = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= b) return !1;
            const G = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > G
        }
        const i = this.left, r = this.right, n = this.top, o = this.bottom;
        if (r <= i || o <= n) return !1;
        const a = Ys[0].set(t.left, t.top), h = Ys[1].set(t.left, t.bottom), l = Ys[2].set(t.right, t.top),
            c = Ys[3].set(t.right, t.bottom);
        if (l.x <= a.x || h.y <= a.y) return !1;
        const u = Math.sign(s.a * s.d - s.b * s.c);
        if (u === 0 || (s.apply(a, a), s.apply(h, h), s.apply(l, l), s.apply(c, c), Math.max(a.x, h.x, l.x, c.x) <= i || Math.min(a.x, h.x, l.x, c.x) >= r || Math.max(a.y, h.y, l.y, c.y) <= n || Math.min(a.y, h.y, l.y, c.y) >= o)) return !1;
        const d = u * (h.y - a.y), f = u * (a.x - h.x), p = d * i + f * n, _ = d * r + f * n, m = d * i + f * o,
            x = d * r + f * o;
        if (Math.max(p, _, m, x) <= d * a.x + f * a.y || Math.min(p, _, m, x) >= d * c.x + f * c.y) return !1;
        const y = u * (a.y - l.y), g = u * (l.x - a.x), v = y * i + g * n, A = y * r + g * n, P = y * i + g * o,
            S = y * r + g * o;
        return !(Math.max(v, A, P, S) <= y * a.x + g * a.y || Math.min(v, A, P, S) >= y * c.x + g * c.y)
    }

    pad(t = 0, s = t) {
        return this.x -= t, this.y -= s, this.width += t * 2, this.height += s * 2, this
    }

    fit(t) {
        const s = Math.max(this.x, t.x), i = Math.min(this.x + this.width, t.x + t.width), r = Math.max(this.y, t.y),
            n = Math.min(this.y + this.height, t.y + t.height);
        return this.x = s, this.width = Math.max(i - s, 0), this.y = r, this.height = Math.max(n - r, 0), this
    }

    ceil(t = 1, s = .001) {
        const i = Math.ceil((this.x + this.width - s) * t) / t, r = Math.ceil((this.y + this.height - s) * t) / t;
        return this.x = Math.floor((this.x + s) * t) / t, this.y = Math.floor((this.y + s) * t) / t, this.width = i - this.x, this.height = r - this.y, this
    }

    enlarge(t) {
        const s = Math.min(this.x, t.x), i = Math.max(this.x + this.width, t.x + t.width), r = Math.min(this.y, t.y),
            n = Math.max(this.y + this.height, t.y + t.height);
        return this.x = s, this.width = i - s, this.y = r, this.height = n - r, this
    }

    toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}

class Ci {
    constructor(t = 0, s = 0, i = 0) {
        this.x = t, this.y = s, this.radius = i, this.type = pt.CIRC
    }

    clone() {
        return new Ci(this.x, this.y, this.radius)
    }

    contains(t, s) {
        if (this.radius <= 0) return !1;
        const i = this.radius * this.radius;
        let r = this.x - t, n = this.y - s;
        return r *= r, n *= n, r + n <= i
    }

    getBounds() {
        return new z(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2)
    }

    toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}

class Ii {
    constructor(t = 0, s = 0, i = 0, r = 0) {
        this.x = t, this.y = s, this.width = i, this.height = r, this.type = pt.ELIP
    }

    clone() {
        return new Ii(this.x, this.y, this.width, this.height)
    }

    contains(t, s) {
        if (this.width <= 0 || this.height <= 0) return !1;
        let i = (t - this.x) / this.width, r = (s - this.y) / this.height;
        return i *= i, r *= r, i + r <= 1
    }

    getBounds() {
        return new z(this.x - this.width, this.y - this.height, this.width, this.height)
    }

    toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}

class Pe {
    constructor(...t) {
        let s = Array.isArray(t[0]) ? t[0] : t;
        if (typeof s[0] != "number") {
            const i = [];
            for (let r = 0, n = s.length; r < n; r++) i.push(s[r].x, s[r].y);
            s = i
        }
        this.points = s, this.type = pt.POLY, this.closeStroke = !0
    }

    clone() {
        const t = this.points.slice(), s = new Pe(t);
        return s.closeStroke = this.closeStroke, s
    }

    contains(t, s) {
        let i = !1;
        const r = this.points.length / 2;
        for (let n = 0, o = r - 1; n < r; o = n++) {
            const a = this.points[n * 2], h = this.points[n * 2 + 1], l = this.points[o * 2],
                c = this.points[o * 2 + 1];
            h > s != c > s && t < (l - a) * ((s - h) / (c - h)) + a && (i = !i)
        }
        return i
    }

    toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t, s) => `${t}, ${s}`, "")}]`
    }
}

class Pi {
    constructor(t = 0, s = 0, i = 0, r = 0, n = 20) {
        this.x = t, this.y = s, this.width = i, this.height = r, this.radius = n, this.type = pt.RREC
    }

    clone() {
        return new Pi(this.x, this.y, this.width, this.height, this.radius)
    }

    contains(t, s) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (t >= this.x && t <= this.x + this.width && s >= this.y && s <= this.y + this.height) {
            const i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (s >= this.y + i && s <= this.y + this.height - i || t >= this.x + i && t <= this.x + this.width - i) return !0;
            let r = t - (this.x + i), n = s - (this.y + i);
            const o = i * i;
            if (r * r + n * n <= o || (r = t - (this.x + this.width - i), r * r + n * n <= o) || (n = s - (this.y + this.height - i), r * r + n * n <= o) || (r = t - (this.x + i), r * r + n * n <= o)) return !0
        }
        return !1
    }

    toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}

class Q {
    constructor(t = 1, s = 0, i = 0, r = 1, n = 0, o = 0) {
        this.array = null, this.a = t, this.b = s, this.c = i, this.d = r, this.tx = n, this.ty = o
    }

    fromArray(t) {
        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
    }

    set(t, s, i, r, n, o) {
        return this.a = t, this.b = s, this.c = i, this.d = r, this.tx = n, this.ty = o, this
    }

    toArray(t, s) {
        this.array || (this.array = new Float32Array(9));
        const i = s || this.array;
        return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i
    }

    apply(t, s) {
        s = s || new j;
        const i = t.x, r = t.y;
        return s.x = this.a * i + this.c * r + this.tx, s.y = this.b * i + this.d * r + this.ty, s
    }

    applyInverse(t, s) {
        s = s || new j;
        const i = 1 / (this.a * this.d + this.c * -this.b), r = t.x, n = t.y;
        return s.x = this.d * i * r + -this.c * i * n + (this.ty * this.c - this.tx * this.d) * i, s.y = this.a * i * n + -this.b * i * r + (-this.ty * this.a + this.tx * this.b) * i, s
    }

    translate(t, s) {
        return this.tx += t, this.ty += s, this
    }

    scale(t, s) {
        return this.a *= t, this.d *= s, this.c *= t, this.b *= s, this.tx *= t, this.ty *= s, this
    }

    rotate(t) {
        const s = Math.cos(t), i = Math.sin(t), r = this.a, n = this.c, o = this.tx;
        return this.a = r * s - this.b * i, this.b = r * i + this.b * s, this.c = n * s - this.d * i, this.d = n * i + this.d * s, this.tx = o * s - this.ty * i, this.ty = o * i + this.ty * s, this
    }

    append(t) {
        const s = this.a, i = this.b, r = this.c, n = this.d;
        return this.a = t.a * s + t.b * r, this.b = t.a * i + t.b * n, this.c = t.c * s + t.d * r, this.d = t.c * i + t.d * n, this.tx = t.tx * s + t.ty * r + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
    }

    setTransform(t, s, i, r, n, o, a, h, l) {
        return this.a = Math.cos(a + l) * n, this.b = Math.sin(a + l) * n, this.c = -Math.sin(a - h) * o, this.d = Math.cos(a - h) * o, this.tx = t - (i * this.a + r * this.c), this.ty = s - (i * this.b + r * this.d), this
    }

    prepend(t) {
        const s = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const i = this.a, r = this.c;
            this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = r * t.a + this.d * t.c, this.d = r * t.b + this.d * t.d
        }
        return this.tx = s * t.a + this.ty * t.c + t.tx, this.ty = s * t.b + this.ty * t.d + t.ty, this
    }

    decompose(t) {
        const s = this.a, i = this.b, r = this.c, n = this.d, o = t.pivot, a = -Math.atan2(-r, n), h = Math.atan2(i, s),
            l = Math.abs(a + h);
        return l < 1e-5 || Math.abs(ss - l) < 1e-5 ? (t.rotation = h, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = h), t.scale.x = Math.sqrt(s * s + i * i), t.scale.y = Math.sqrt(r * r + n * n), t.position.x = this.tx + (o.x * s + o.y * r), t.position.y = this.ty + (o.x * i + o.y * n), t
    }

    invert() {
        const t = this.a, s = this.b, i = this.c, r = this.d, n = this.tx, o = t * r - s * i;
        return this.a = r / o, this.b = -s / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - r * n) / o, this.ty = -(t * this.ty - s * n) / o, this
    }

    identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
    }

    clone() {
        const t = new Q;
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }

    copyTo(t) {
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }

    copyFrom(t) {
        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
    }

    toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }

    static get IDENTITY() {
        return new Q
    }

    static get TEMP_MATRIX() {
        return new Q
    }
}

const Te = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    be = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    Ee = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    we = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], dr = [], yo = [], qs = Math.sign;

function dd() {
    for (let e = 0; e < 16; e++) {
        const t = [];
        dr.push(t);
        for (let s = 0; s < 16; s++) {
            const i = qs(Te[e] * Te[s] + Ee[e] * be[s]), r = qs(be[e] * Te[s] + we[e] * be[s]),
                n = qs(Te[e] * Ee[s] + Ee[e] * we[s]), o = qs(be[e] * Ee[s] + we[e] * we[s]);
            for (let a = 0; a < 16; a++) if (Te[a] === i && be[a] === r && Ee[a] === n && we[a] === o) {
                t.push(a);
                break
            }
        }
    }
    for (let e = 0; e < 16; e++) {
        const t = new Q;
        t.set(Te[e], be[e], Ee[e], we[e], 0, 0), yo.push(t)
    }
}

dd();
const tt = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: e => Te[e],
    uY: e => be[e],
    vX: e => Ee[e],
    vY: e => we[e],
    inv: e => e & 8 ? e & 15 : -e & 7,
    add: (e, t) => dr[e][t],
    sub: (e, t) => dr[e][tt.inv(t)],
    rotate180: e => e ^ 4,
    isVertical: e => (e & 3) === 2,
    byDirection: (e, t) => Math.abs(e) * 2 <= Math.abs(t) ? t >= 0 ? tt.S : tt.N : Math.abs(t) * 2 <= Math.abs(e) ? e > 0 ? tt.E : tt.W : t > 0 ? e > 0 ? tt.SE : tt.SW : e > 0 ? tt.NE : tt.NW,
    matrixAppendRotationInv: (e, t, s = 0, i = 0) => {
        const r = yo[tt.inv(t)];
        r.tx = s, r.ty = i, e.append(r)
    }
};

class ne {
    constructor(t, s, i = 0, r = 0) {
        this._x = i, this._y = r, this.cb = t, this.scope = s
    }

    clone(t = this.cb, s = this.scope) {
        return new ne(t, s, this._x, this._y)
    }

    set(t = 0, s = t) {
        return (this._x !== t || this._y !== s) && (this._x = t, this._y = s, this.cb.call(this.scope)), this
    }

    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
    }

    copyTo(t) {
        return t.set(this._x, this._y), t
    }

    equals(t) {
        return t.x === this._x && t.y === this._y
    }

    toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`
    }

    get x() {
        return this._x
    }

    set x(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope))
    }

    get y() {
        return this._y
    }

    set y(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope))
    }
}

const To = class {
    constructor() {
        this.worldTransform = new Q, this.localTransform = new Q, this.position = new ne(this.onChange, this, 0, 0), this.scale = new ne(this.onChange, this, 1, 1), this.pivot = new ne(this.onChange, this, 0, 0), this.skew = new ne(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
    }

    onChange() {
        this._localID++
    }

    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
    }

    toString() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }

    updateLocalTransform() {
        const e = this.localTransform;
        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1)
    }

    updateTransform(e) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
            const s = e.worldTransform, i = this.worldTransform;
            i.a = t.a * s.a + t.b * s.c, i.b = t.a * s.b + t.b * s.d, i.c = t.c * s.a + t.d * s.c, i.d = t.c * s.b + t.d * s.d, i.tx = t.tx * s.a + t.ty * s.c + s.tx, i.ty = t.tx * s.b + t.ty * s.d + s.ty, this._parentID = e._worldID, this._worldID++
        }
    }

    setFromMatrix(e) {
        e.decompose(this), this._localID++
    }

    get rotation() {
        return this._rotation
    }

    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this.updateSkew())
    }
};
let is = To;
is.IDENTITY = new To;
var fd = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, pd = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;

function bo(e, t, s) {
    const i = e.createShader(t);
    return e.shaderSource(i, s), e.compileShader(i), i
}

function fr(e) {
    const t = new Array(e);
    for (let s = 0; s < t.length; s++) t[s] = !1;
    return t
}

function Eo(e, t) {
    switch (e) {
        case"float":
            return 0;
        case"vec2":
            return new Float32Array(2 * t);
        case"vec3":
            return new Float32Array(3 * t);
        case"vec4":
            return new Float32Array(4 * t);
        case"int":
        case"uint":
        case"sampler2D":
        case"sampler2DArray":
            return 0;
        case"ivec2":
            return new Int32Array(2 * t);
        case"ivec3":
            return new Int32Array(3 * t);
        case"ivec4":
            return new Int32Array(4 * t);
        case"uvec2":
            return new Uint32Array(2 * t);
        case"uvec3":
            return new Uint32Array(3 * t);
        case"uvec4":
            return new Uint32Array(4 * t);
        case"bool":
            return !1;
        case"bvec2":
            return fr(2 * t);
        case"bvec3":
            return fr(3 * t);
        case"bvec4":
            return fr(4 * t);
        case"mat2":
            return new Float32Array([1, 0, 0, 1]);
        case"mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case"mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}

const Ae = [{
    test: e => e.type === "float" && e.size === 1 && !e.isArray, code: e => `
            if(uv["${e}"] !== ud["${e}"].value)
            {
                ud["${e}"].value = uv["${e}"]
                gl.uniform1f(ud["${e}"].location, uv["${e}"])
            }
            `
}, {
    test: (e, t) => (e.type === "sampler2D" || e.type === "samplerCube" || e.type === "sampler2DArray") && e.size === 1 && !e.isArray && (t == null || t.castToBaseTexture !== void 0),
    code: e => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${e}"], t);

            if(ud["${e}"].value !== t)
            {
                ud["${e}"].value = t;
                gl.uniform1i(ud["${e}"].location, t);
; // eslint-disable-line max-len
            }`
}, {
    test: (e, t) => e.type === "mat3" && e.size === 1 && !e.isArray && t.a !== void 0, code: e => `
            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));
            `, codeUbo: e => `
                var ${e}_matrix = uv.${e}.toArray(true);

                data[offset] = ${e}_matrix[0];
                data[offset+1] = ${e}_matrix[1];
                data[offset+2] = ${e}_matrix[2];
        
                data[offset + 4] = ${e}_matrix[3];
                data[offset + 5] = ${e}_matrix[4];
                data[offset + 6] = ${e}_matrix[5];
        
                data[offset + 8] = ${e}_matrix[6];
                data[offset + 9] = ${e}_matrix[7];
                data[offset + 10] = ${e}_matrix[8];
            `
}, {
    test: (e, t) => e.type === "vec2" && e.size === 1 && !e.isArray && t.x !== void 0, code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${e}"].location, v.x, v.y);
                }`, codeUbo: e => `
                v = uv.${e};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
}, {
    test: e => e.type === "vec2" && e.size === 1 && !e.isArray, code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);
                }
            `
}, {
    test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.width !== void 0, code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)
                }`, codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
}, {
    test: e => e.type === "vec4" && e.size === 1 && !e.isArray, code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])
                }`
}], md = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, _d = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
};

function gd(e, t) {
    var i;
    const s = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const r in e.uniforms) {
        const n = t[r];
        if (!n) {
            (i = e.uniforms[r]) != null && i.group && (e.uniforms[r].ubo ? s.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${r}, '${r}');
                    `) : s.push(`
                        renderer.shader.syncUniformGroup(uv.${r}, syncData);
                    `));
            continue
        }
        const o = e.uniforms[r];
        let a = !1;
        for (let h = 0; h < Ae.length; h++) if (Ae[h].test(n, o)) {
            s.push(Ae[h].code(r, o)), a = !0;
            break
        }
        if (!a) {
            const l = (n.size === 1 && !n.isArray ? md : _d)[n.type].replace("location", `ud["${r}"].location`);
            s.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${l};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", s.join(`
`))
}

const wo = {};
let ke = wo;

function Ao() {
    if (ke === wo || (ke == null ? void 0 : ke.isContextLost())) {
        const e = M.ADAPTER.createCanvas();
        let t;
        M.PREFER_ENV >= he.WEBGL2 && (t = e.getContext("webgl2", {})), t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), ke = t
    }
    return ke
}

let Ks;

function xd() {
    if (!Ks) {
        Ks = wt.MEDIUM;
        const e = Ao();
        e && e.getShaderPrecisionFormat && (Ks = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? wt.HIGH : wt.MEDIUM)
    }
    return Ks
}

function So(e, t) {
    const s = e.getShaderSource(t).split(`
`).map((l, c) => `${c}: ${l}`), i = e.getShaderInfoLog(t), r = i.split(`
`), n = {},
        o = r.map(l => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(l => l && !n[l] ? (n[l] = !0, !0) : !1),
        a = [""];
    o.forEach(l => {
        s[l - 1] = `%c${s[l - 1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    });
    const h = s.join(`
`);
    a[0] = h, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
}

function vd(e, t, s, i) {
    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(s, e.COMPILE_STATUS) || So(e, s), e.getShaderParameter(i, e.COMPILE_STATUS) || So(e, i), console.error("PixiJS Error: Could not initialize shader."), e.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
}

const yd = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};

function Ro(e) {
    return yd[e]
}

let Zs = null;
const Co = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};

function Io(e, t) {
    if (!Zs) {
        const s = Object.keys(Co);
        Zs = {};
        for (let i = 0; i < s.length; ++i) {
            const r = s[i];
            Zs[e[r]] = Co[r]
        }
    }
    return Zs[t]
}

function Po(e, t, s) {
    if (e.substring(0, 9) !== "precision") {
        let i = t;
        return t === wt.HIGH && s !== wt.HIGH && (i = wt.MEDIUM), `precision ${i} float;
${e}`
    } else if (s !== wt.HIGH && e.substring(0, 15) === "precision highp") return e.replace("precision highp", "precision mediump");
    return e
}

let rs;

function Mo() {
    if (typeof rs == "boolean") return rs;
    try {
        rs = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({a: "b"}, "a", "b") === !0
    } catch (e) {
        rs = !1
    }
    return rs
}

let Td = 0;
const Qs = {}, Ge = class {
    constructor(e, t, s = "pixi-shader", i = {}) {
        this.extra = {}, this.id = Td++, this.vertexSrc = e || Ge.defaultVertexSrc, this.fragmentSrc = t || Ge.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = i, this.vertexSrc.substring(0, 8) !== "#version" && (s = s.replace(/\s+/g, "-"), Qs[s] ? (Qs[s]++, s += `-${Qs[s]}`) : Qs[s] = 1, this.vertexSrc = `#define SHADER_NAME ${s}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${s}
${this.fragmentSrc}`, this.vertexSrc = Po(this.vertexSrc, Ge.defaultVertexPrecision, wt.HIGH), this.fragmentSrc = Po(this.fragmentSrc, Ge.defaultFragmentPrecision, xd())), this.glPrograms = {}, this.syncUniforms = null
    }

    static get defaultVertexSrc() {
        return pd
    }

    static get defaultFragmentSrc() {
        return fd
    }

    static from(e, t, s) {
        const i = e + t;
        let r = er[i];
        return r || (er[i] = r = new Ge(e, t, s)), r
    }
};
let Pt = Ge;
Pt.defaultVertexPrecision = wt.HIGH, Pt.defaultFragmentPrecision = kt.apple.device ? wt.HIGH : wt.MEDIUM;
let bd = 0;

class Ft {
    constructor(t, s, i) {
        this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = bd++, this.static = !!s, this.ubo = !!i, t instanceof nt ? (this.buffer = t, this.buffer.type = Ut.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new nt(new Float32Array(1)), this.buffer.type = Ut.UNIFORM_BUFFER, this.autoManage = !0))
    }

    update() {
        this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
    }

    add(t, s, i) {
        if (!this.ubo) this.uniforms[t] = new Ft(s, i); else throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }

    static from(t, s, i) {
        return new Ft(t, s, i)
    }

    static uboFrom(t, s) {
        return new Ft(t, s != null ? s : !0, !0)
    }
}

class Wt {
    constructor(t, s) {
        this.uniformBindCount = 0, this.program = t, s ? s instanceof Ft ? this.uniformGroup = s : this.uniformGroup = new Ft(s) : this.uniformGroup = new Ft({}), this.disposeRunner = new St("disposeShader")
    }

    checkUniformExists(t, s) {
        if (s.uniforms[t]) return !0;
        for (const i in s.uniforms) {
            const r = s.uniforms[i];
            if (r.group && this.checkUniformExists(t, r)) return !0
        }
        return !1
    }

    destroy() {
        this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy()
    }

    get uniforms() {
        return this.uniformGroup.uniforms
    }

    static from(t, s, i) {
        const r = Pt.from(t, s);
        return new Wt(r, i)
    }
}

class Bo {
    constructor(t, s) {
        if (this.vertexSrc = t, this.fragTemplate = s, this.programCache = {}, this.defaultGroupCache = {}, !s.includes("%count%")) throw new Error('Fragment template must contain "%count%".');
        if (!s.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".')
    }

    generateShader(t) {
        if (!this.programCache[t]) {
            const i = new Int32Array(t);
            for (let n = 0; n < t; n++) i[n] = n;
            this.defaultGroupCache[t] = Ft.from({uSamplers: i}, !0);
            let r = this.fragTemplate;
            r = r.replace(/%count%/gi, `${t}`), r = r.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new Pt(this.vertexSrc, r)
        }
        const s = {tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Q, default: this.defaultGroupCache[t]};
        return new Wt(this.programCache[t], s)
    }

    generateSampleSrc(t) {
        let s = "";
        s += `
`, s += `
`;
        for (let i = 0; i < t; i++) i > 0 && (s += `
else `), i < t - 1 && (s += `if(vTextureId < ${i}.5)`), s += `
{`, s += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`, s += `
}`;
        return s += `
`, s += `
`, s
    }
}

class Js {
    constructor() {
        this.elements = [], this.ids = [], this.count = 0
    }

    clear() {
        for (let t = 0; t < this.count; t++) this.elements[t] = null;
        this.count = 0
    }
}

function Ed() {
    return !kt.apple.device
}

function wd(e) {
    let t = !0;
    const s = M.ADAPTER.getNavigator();
    if (kt.tablet || kt.phone) {
        if (kt.apple.device) {
            const i = s.userAgent.match(/OS (\d+)_(\d+)?/);
            i && parseInt(i[1], 10) < 11 && (t = !1)
        }
        if (kt.android.device) {
            const i = s.userAgent.match(/Android\s([0-9.]*)/);
            i && parseInt(i[1], 10) < 7 && (t = !1)
        }
    }
    return t ? e : 4
}

class ns {
    constructor(t) {
        this.renderer = t
    }

    flush() {
    }

    destroy() {
        this.renderer = null
    }

    start() {
    }

    stop() {
        this.flush()
    }

    render(t) {
    }
}

var Ad = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, Sd = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const Ht = class extends ns {
    constructor(e) {
        super(e), this.setShaderGenerator(), this.geometryClass = ur, this.vertexSize = 6, this.state = Jt.for2d(), this.size = Ht.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), e.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
    }

    static get defaultMaxTextures() {
        var e;
        return this._defaultMaxTextures = (e = this._defaultMaxTextures) != null ? e : wd(32), this._defaultMaxTextures
    }

    static set defaultMaxTextures(e) {
        this._defaultMaxTextures = e
    }

    static get canUploadSameBuffer() {
        var e;
        return this._canUploadSameBuffer = (e = this._canUploadSameBuffer) != null ? e : Ed(), this._canUploadSameBuffer
    }

    static set canUploadSameBuffer(e) {
        this._canUploadSameBuffer = e
    }

    get MAX_TEXTURES() {
        return Y("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures
    }

    static get defaultVertexSrc() {
        return Sd
    }

    static get defaultFragmentTemplate() {
        return Ad
    }

    setShaderGenerator({vertex: e = Ht.defaultVertexSrc, fragment: t = Ht.defaultFragmentTemplate} = {}) {
        this.shaderGenerator = new Bo(e, t)
    }

    contextChange() {
        const e = this.renderer.gl;
        M.PREFER_ENV === he.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), Ht.defaultMaxTextures), this.maxTextures = _o(this.maxTextures, e)), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] = new this.geometryClass;
        this.initFlushBuffers()
    }

    initFlushBuffers() {
        const {_drawCallPool: e, _textureArrayPool: t} = Ht, s = this.size / 4,
            i = Math.floor(s / this.maxTextures) + 1;
        for (; e.length < s;) e.push(new $s);
        for (; t.length < i;) t.push(new Js);
        for (let r = 0; r < this.maxTextures; r++) this._tempBoundTextures[r] = null
    }

    onPrerender() {
        this._flushId = 0
    }

    render(e) {
        !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e)
    }

    buildTexturesAndDrawCalls() {
        const {_bufferedTextures: e, maxTextures: t} = this, s = Ht._textureArrayPool, i = this.renderer.batch,
            r = this._tempBoundTextures, n = this.renderer.textureGC.count;
        let o = ++X._globalBatch, a = 0, h = s[0], l = 0;
        i.copyBoundTextures(r, t);
        for (let c = 0; c < this._bufferSize; ++c) {
            const u = e[c];
            e[c] = null, u._batchEnabled !== o && (h.count >= t && (i.boundArray(h, r, o, t), this.buildDrawCalls(h, l, c), l = c, h = s[++a], ++o), u._batchEnabled = o, u.touched = n, h.elements[h.count++] = u)
        }
        h.count > 0 && (i.boundArray(h, r, o, t), this.buildDrawCalls(h, l, this._bufferSize), ++a, ++o);
        for (let c = 0; c < r.length; c++) r[c] = null;
        X._globalBatch = o
    }

    buildDrawCalls(e, t, s) {
        const {_bufferedElements: i, _attributeBuffer: r, _indexBuffer: n, vertexSize: o} = this, a = Ht._drawCallPool;
        let h = this._dcIndex, l = this._aIndex, c = this._iIndex, u = a[h];
        u.start = this._iIndex, u.texArray = e;
        for (let d = t; d < s; ++d) {
            const f = i[d], p = f._texture.baseTexture, _ = Ki[p.alphaMode ? 1 : 0][f.blendMode];
            i[d] = null, t < d && u.blend !== _ && (u.size = c - u.start, t = d, u = a[++h], u.texArray = e, u.start = c), this.packInterleavedGeometry(f, r, n, l, c), l += f.vertexData.length / 2 * o, c += f.indices.length, u.blend = _
        }
        t < s && (u.size = c - u.start, ++h), this._dcIndex = h, this._aIndex = l, this._iIndex = c
    }

    bindAndClearTexArray(e) {
        const t = this.renderer.texture;
        for (let s = 0; s < e.count; s++) t.bind(e.elements[s], e.ids[s]), e.elements[s] = null;
        e.count = 0
    }

    updateGeometry() {
        const {_packedGeometries: e, _attributeBuffer: t, _indexBuffer: s} = this;
        Ht.canUploadSameBuffer ? (e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
    }

    drawBatches() {
        const e = this._dcIndex, {gl: t, state: s} = this.renderer, i = Ht._drawCallPool;
        let r = null;
        for (let n = 0; n < e; n++) {
            const {texArray: o, type: a, size: h, start: l, blend: c} = i[n];
            r !== o && (r = o, this.bindAndClearTexArray(o)), this.state.blendMode = c, s.set(this.state), t.drawElements(a, h, t.UNSIGNED_SHORT, l * 2)
        }
    }

    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
    }

    start() {
        this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), Ht.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }

    stop() {
        this.flush()
    }

    destroy() {
        for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy()
    }

    getAttributeBuffer(e) {
        const t = es(Math.ceil(e / 8)), s = tr(t), i = t * 8;
        this._aBuffers.length <= s && (this._iBuffers.length = s + 1);
        let r = this._aBuffers[i];
        return r || (this._aBuffers[i] = r = new Ws(i * this.vertexSize * 4)), r
    }

    getIndexBuffer(e) {
        const t = es(Math.ceil(e / 12)), s = tr(t), i = t * 12;
        this._iBuffers.length <= s && (this._iBuffers.length = s + 1);
        let r = this._iBuffers[s];
        return r || (this._iBuffers[s] = r = new Uint16Array(i)), r
    }

    packInterleavedGeometry(e, t, s, i, r) {
        const {uint32View: n, float32View: o} = t, a = i / this.vertexSize, h = e.uvs, l = e.indices, c = e.vertexData,
            u = e._texture.baseTexture._batchLocation, d = Math.min(e.worldAlpha, 1),
            f = d < 1 && e._texture.baseTexture.alphaMode ? Hs(e._tintRGB, d) : e._tintRGB + (d * 255 << 24);
        for (let p = 0; p < c.length; p += 2) o[i++] = c[p], o[i++] = c[p + 1], o[i++] = h[p], o[i++] = h[p + 1], n[i++] = f, o[i++] = u;
        for (let p = 0; p < l.length; p++) s[r++] = a + l[p]
    }
};
let Mt = Ht;
Mt.defaultBatchSize = 4096, Mt.extension = {
    name: "batch",
    type: I.RendererPlugin
}, Mt._drawCallPool = [], Mt._textureArrayPool = [], O.add(Mt);
var Rd = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, Cd = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const os = class extends Wt {
    constructor(e, t, s) {
        const i = Pt.from(e || os.defaultVertexSrc, t || os.defaultFragmentSrc);
        super(i, s), this.padding = 0, this.resolution = os.defaultResolution, this.multisample = os.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new Jt
    }

    apply(e, t, s, i, r) {
        e.applyFilter(this, t, s, i)
    }

    get blendMode() {
        return this.state.blendMode
    }

    set blendMode(e) {
        this.state.blendMode = e
    }

    get resolution() {
        return this._resolution
    }

    set resolution(e) {
        this._resolution = e
    }

    static get defaultVertexSrc() {
        return Cd
    }

    static get defaultFragmentSrc() {
        return Rd
    }
};
let mt = os;
mt.defaultResolution = 1, mt.defaultMultisample = st.NONE;

class pr {
    constructor() {
        this.clearBeforeRender = !0, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 1], this._backgroundColorString = "#000000", this.color = this._backgroundColor, this.alpha = 1
    }

    init(t) {
        this.clearBeforeRender = t.clearBeforeRender, t.color && (this.color = typeof t.color == "string" ? Gs(t.color) : t.color), this.alpha = t.alpha
    }

    get color() {
        return this._backgroundColor
    }

    set color(t) {
        this._backgroundColor = t, this._backgroundColorString = qi(t), xe(t, this._backgroundColorRgba)
    }

    get alpha() {
        return this._backgroundColorRgba[3]
    }

    set alpha(t) {
        this._backgroundColorRgba[3] = t
    }

    get colorRgba() {
        return this._backgroundColorRgba
    }

    get colorString() {
        return this._backgroundColorString
    }

    destroy() {
    }
}

pr.extension = {type: [I.RendererSystem, I.CanvasRendererSystem], name: "background"}, O.add(pr);

class mr {
    constructor(t) {
        this.renderer = t, this.emptyRenderer = new ns(t), this.currentRenderer = this.emptyRenderer
    }

    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
    }

    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }

    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }

    copyBoundTextures(t, s) {
        const {boundTextures: i} = this.renderer.texture;
        for (let r = s - 1; r >= 0; --r) t[r] = i[r] || null, t[r] && (t[r]._batchLocation = r)
    }

    boundArray(t, s, i, r) {
        const {elements: n, ids: o, count: a} = t;
        let h = 0;
        for (let l = 0; l < a; l++) {
            const c = n[l], u = c._batchLocation;
            if (u >= 0 && u < r && s[u] === c) {
                o[l] = u;
                continue
            }
            for (; h < r;) {
                const d = s[h];
                if (d && d._batchEnabled === i && d._batchLocation === h) {
                    h++;
                    continue
                }
                o[l] = h, c._batchLocation = h, s[h] = c;
                break
            }
        }
    }

    destroy() {
        this.renderer = null
    }
}

mr.extension = {type: I.RendererSystem, name: "batch"}, O.add(mr);
let Do = 0;

class _r {
    constructor(t) {
        this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {uint32Indices: !1}, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
    }

    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }

    contextChange(t) {
        this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = Do++
    }

    init(t) {
        if (t.context) this.initFromContext(t.context); else {
            const s = this.renderer.background.alpha < 1, i = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.useContextAlpha = t.useContextAlpha, this.powerPreference = t.powerPreference, this.initFromOptions({
                alpha: s,
                premultipliedAlpha: i,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }

    initFromContext(t) {
        this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = Do++, this.renderer.runners.contextChange.emit(t);
        const s = this.renderer.view;
        s.addEventListener !== void 0 && (s.addEventListener("webglcontextlost", this.handleContextLost, !1), s.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }

    initFromOptions(t) {
        const s = this.createContext(this.renderer.view, t);
        this.initFromContext(s)
    }

    createContext(t, s) {
        let i;
        if (M.PREFER_ENV >= he.WEBGL2 && (i = t.getContext("webgl2", s)), i) this.webGLVersion = 2; else if (this.webGLVersion = 1, i = t.getContext("webgl", s) || t.getContext("experimental-webgl", s), !i) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = i, this.getExtensions(), this.gl
    }

    getExtensions() {
        const {gl: t} = this, s = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, s, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, s, {colorBufferFloat: t.getExtension("EXT_color_buffer_float")})
    }

    handleContextLost(t) {
        t.preventDefault(), setTimeout(() => {
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }, 0)
    }

    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }

    destroy() {
        const t = this.renderer.view;
        this.renderer = null, t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }

    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }

    validateContext(t) {
        const s = t.getContextAttributes(),
            i = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        i && (this.webGLVersion = 2), s && !s.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = i || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = r, r || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}

_r.extension = {type: I.RendererSystem, name: "context"}, O.add(_r);

class Id extends Oe {
    upload(t, s, i) {
        const r = t.gl;
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.alphaMode === Ct.UNPACK);
        const n = s.realWidth, o = s.realHeight;
        return i.width === n && i.height === o ? r.texSubImage2D(s.target, 0, 0, 0, n, o, s.format, i.type, this.data) : (i.width = n, i.height = o, r.texImage2D(s.target, 0, i.internalFormat, n, o, 0, s.format, i.type, this.data)), !0
    }
}

class ti {
    constructor(t, s) {
        this.width = Math.round(t || 100), this.height = Math.round(s || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new St("disposeFramebuffer"), this.multisample = st.NONE
    }

    get colorTexture() {
        return this.colorTextures[0]
    }

    addColorTexture(t = 0, s) {
        return this.colorTextures[t] = s || new X(null, {
            scaleMode: qt.NEAREST,
            resolution: 1,
            mipmap: Lt.OFF,
            width: this.width,
            height: this.height
        }), this.dirtyId++, this.dirtyFormat++, this
    }

    addDepthTexture(t) {
        return this.depthTexture = t || new X(new Id(null, {
            width: this.width,
            height: this.height
        }), {
            scaleMode: qt.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: Lt.OFF,
            format: R.DEPTH_COMPONENT,
            type: U.UNSIGNED_SHORT
        }), this.dirtyId++, this.dirtyFormat++, this
    }

    enableDepth() {
        return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
    }

    enableStencil() {
        return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
    }

    resize(t, s) {
        if (t = Math.round(t), s = Math.round(s), !(t === this.width && s === this.height)) {
            this.width = t, this.height = s, this.dirtyId++, this.dirtySize++;
            for (let i = 0; i < this.colorTextures.length; i++) {
                const r = this.colorTextures[i], n = r.resolution;
                r.setSize(t / n, s / n)
            }
            if (this.depthTexture) {
                const i = this.depthTexture.resolution;
                this.depthTexture.setSize(t / i, s / i)
            }
        }
    }

    dispose() {
        this.disposeRunner.emit(this, !1)
    }

    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
    }
}

class gr extends X {
    constructor(t = {}) {
        var s;
        if (typeof t == "number") {
            const i = arguments[0], r = arguments[1], n = arguments[2], o = arguments[3];
            t = {width: i, height: r, scaleMode: n, resolution: o}
        }
        t.width = t.width || 100, t.height = t.height || 100, (s = t.multisample) != null || (t.multisample = st.NONE), super(null, t), this.mipmap = Lt.OFF, this.valid = !0, this.clearColor = [0, 0, 0, 0], this.framebuffer = new ti(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = t.multisample, this.maskStack = [], this.filterStack = [{}]
    }

    resize(t, s) {
        this.framebuffer.resize(t * this.resolution, s * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }

    dispose() {
        this.framebuffer.dispose(), super.dispose()
    }

    destroy() {
        super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
    }
}

class se extends Le {
    constructor(t) {
        const s = t, i = s.naturalWidth || s.videoWidth || s.width, r = s.naturalHeight || s.videoHeight || s.height;
        super(i, r), this.source = t, this.noSubImage = !1
    }

    static crossOrigin(t, s, i) {
        i === void 0 && !s.startsWith("data:") ? t.crossOrigin = po(s) : i !== !1 && (t.crossOrigin = typeof i == "string" ? i : "anonymous")
    }

    upload(t, s, i, r) {
        const n = t.gl, o = s.realWidth, a = s.realHeight;
        if (r = r || this.source, typeof HTMLImageElement != "undefined" && r instanceof HTMLImageElement) {
            if (!r.complete || r.naturalWidth === 0) return !1
        } else if (typeof HTMLVideoElement != "undefined" && r instanceof HTMLVideoElement && r.readyState <= 1 && r.buffered.length === 0) return !1;
        return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.alphaMode === Ct.UNPACK), !this.noSubImage && s.target === n.TEXTURE_2D && i.width === o && i.height === a ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, s.format, i.type, r) : (i.width = o, i.height = a, n.texImage2D(s.target, 0, i.internalFormat, s.format, i.type, r)), !0
    }

    update() {
        if (this.destroyed) return;
        const t = this.source, s = t.naturalWidth || t.videoWidth || t.width,
            i = t.naturalHeight || t.videoHeight || t.height;
        this.resize(s, i), super.update()
    }

    dispose() {
        this.source = null
    }
}

class xr extends se {
    constructor(t, s) {
        var i;
        if (s = s || {}, typeof t == "string") {
            const r = new Image;
            se.crossOrigin(r, t, s.crossorigin), r.src = t, t = r
        }
        super(t), !t.complete && !!this._width && !!this._height && (this._width = 0, this._height = 0), this.url = t.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = ((i = s.createBitmap) != null ? i : M.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof s.alphaMode == "number" ? s.alphaMode : null, this.bitmap = null, this._load = null, s.autoLoad !== !1 && this.load()
    }

    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise((s, i) => {
            const r = this.source;
            this.url = r.src;
            const n = () => {
                this.destroyed || (r.onload = null, r.onerror = null, this.resize(r.width, r.height), this._load = null, this.createBitmap ? s(this.process()) : s(this))
            };
            r.complete && r.src ? n() : (r.onload = n, r.onerror = o => {
                i(o), this.onError.emit(o)
            })
        }), this._load)
    }

    process() {
        const t = this.source;
        if (this._process !== null) return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap) return Promise.resolve(this);
        const s = globalThis.createImageBitmap, i = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {mode: i ? "cors" : "no-cors"}).then(r => r.blob()).then(r => s(r, 0, 0, t.width, t.height, {premultiplyAlpha: this.alphaMode === null || this.alphaMode === Ct.UNPACK ? "premultiply" : "none"})).then(r => this.destroyed ? Promise.reject() : (this.bitmap = r, this.update(), this._process = null, Promise.resolve(this))), this._process
    }

    upload(t, s, i) {
        if (typeof this.alphaMode == "number" && (s.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(t, s, i);
        if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
        if (super.upload(t, s, i, this.bitmap), !this.preserveBitmap) {
            let r = !0;
            const n = s._glTextures;
            for (const o in n) {
                const a = n[o];
                if (a !== i && a.dirtyId !== s.dirtyId) {
                    r = !1;
                    break
                }
            }
            r && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
        }
        return !0
    }

    dispose() {
        this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
    }

    static test(t) {
        return typeof HTMLImageElement != "undefined" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}

class vr {
    constructor() {
        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
    }

    set(t, s, i) {
        const r = s.width, n = s.height;
        if (i) {
            const o = t.width / 2 / r, a = t.height / 2 / n, h = t.x / r + o, l = t.y / n + a;
            i = tt.add(i, tt.NW), this.x0 = h + o * tt.uX(i), this.y0 = l + a * tt.uY(i), i = tt.add(i, 2), this.x1 = h + o * tt.uX(i), this.y1 = l + a * tt.uY(i), i = tt.add(i, 2), this.x2 = h + o * tt.uX(i), this.y2 = l + a * tt.uY(i), i = tt.add(i, 2), this.x3 = h + o * tt.uX(i), this.y3 = l + a * tt.uY(i)
        } else this.x0 = t.x / r, this.y0 = t.y / n, this.x1 = (t.x + t.width) / r, this.y1 = t.y / n, this.x2 = (t.x + t.width) / r, this.y2 = (t.y + t.height) / n, this.x3 = t.x / r, this.y3 = (t.y + t.height) / n;
        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
    }

    toString() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
    }
}

const Fo = new vr;

function ei(e) {
    e.destroy = function () {
    }, e.on = function () {
    }, e.once = function () {
    }, e.emit = function () {
    }
}

class B extends De {
    constructor(t, s, i, r, n, o) {
        if (super(), this.noFrame = !1, s || (this.noFrame = !0, s = new z(0, 0, 1, 1)), t instanceof B && (t = t.baseTexture), this.baseTexture = t, this._frame = s, this.trim = r, this.valid = !1, this._uvs = Fo, this.uvMatrix = null, this.orig = i || s, this._rotate = Number(n || 0), n === !0) this._rotate = 2; else if (this._rotate % 2 !== 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new j(o.x, o.y) : new j(0, 0), this._updateID = 0, this.textureCacheIds = [], t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = s : t.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }

    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }

    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid) return;
            this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
        } else this.frame = this._frame;
        this.emit("update", this)
    }

    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {resource: s} = this.baseTexture;
                (s == null ? void 0 : s.url) && vt[s.url] && B.removeFromCache(s.url), this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
        }
        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, B.removeFromCache(this), this.textureCacheIds = null
    }

    clone() {
        var r;
        const t = this._frame.clone(), s = this._frame === this.orig ? t : this.orig.clone(),
            i = new B(this.baseTexture, !this.noFrame && t, s, (r = this.trim) == null ? void 0 : r.clone(), this.rotate, this.defaultAnchor);
        return this.noFrame && (i._frame = t), i
    }

    updateUvs() {
        this._uvs === Fo && (this._uvs = new vr), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
    }

    static from(t, s = {}, i = M.STRICT_TEXTURE_CACHE) {
        const r = typeof t == "string";
        let n = null;
        if (r) n = t; else if (t instanceof X) {
            if (!t.cacheId) {
                const a = (s == null ? void 0 : s.pixiIdPrefix) || "pixiid";
                t.cacheId = `${a}-${le()}`, X.addToCache(t, t.cacheId)
            }
            n = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = (s == null ? void 0 : s.pixiIdPrefix) || "pixiid";
                t._pixiId = `${a}_${le()}`
            }
            n = t._pixiId
        }
        let o = vt[n];
        if (r && i && !o) throw new Error(`The cacheId "${n}" does not exist in TextureCache.`);
        return !o && !(t instanceof X) ? (s.resolution || (s.resolution = ee(t)), o = new B(new X(t, s)), o.baseTexture.cacheId = n, X.addToCache(o.baseTexture, n), B.addToCache(o, n)) : !o && t instanceof X && (o = new B(t), B.addToCache(o, n)), o
    }

    static fromURL(t, s) {
        const i = Object.assign({autoLoad: !1}, s == null ? void 0 : s.resourceOptions),
            r = B.from(t, Object.assign({resourceOptions: i}, s), !1), n = r.baseTexture.resource;
        return r.baseTexture.valid ? Promise.resolve(r) : n.load().then(() => Promise.resolve(r))
    }

    static fromBuffer(t, s, i, r) {
        return new B(X.fromBuffer(t, s, i, r))
    }

    static fromLoader(t, s, i, r) {
        const n = new X(t, Object.assign({
            scaleMode: X.defaultOptions.scaleMode,
            resolution: ee(s)
        }, r)), {resource: o} = n;
        o instanceof xr && (o.url = s);
        const a = new B(n);
        return i || (i = s), X.addToCache(a.baseTexture, i), B.addToCache(a, i), i !== s && (X.addToCache(a.baseTexture, s), B.addToCache(a, s)), a.baseTexture.valid ? Promise.resolve(a) : new Promise(h => {
            a.baseTexture.once("loaded", () => h(a))
        })
    }

    static addToCache(t, s) {
        s && (t.textureCacheIds.includes(s) || t.textureCacheIds.push(s), vt[s] && vt[s] !== t && console.warn(`Texture added to the cache with an id [${s}] that already had an entry`), vt[s] = t)
    }

    static removeFromCache(t) {
        if (typeof t == "string") {
            const s = vt[t];
            if (s) {
                const i = s.textureCacheIds.indexOf(t);
                return i > -1 && s.textureCacheIds.splice(i, 1), delete vt[t], s
            }
        } else if (t != null && t.textureCacheIds) {
            for (let s = 0; s < t.textureCacheIds.length; ++s) vt[t.textureCacheIds[s]] === t && delete vt[t.textureCacheIds[s]];
            return t.textureCacheIds.length = 0, t
        }
        return null
    }

    get resolution() {
        return this.baseTexture.resolution
    }

    get frame() {
        return this._frame
    }

    set frame(t) {
        this._frame = t, this.noFrame = !1;
        const {x: s, y: i, width: r, height: n} = t, o = s + r > this.baseTexture.width,
            a = i + n > this.baseTexture.height;
        if (o || a) {
            const h = o && a ? "and" : "or", l = `X: ${s} + ${r} = ${s + r} > ${this.baseTexture.width}`,
                c = `Y: ${i} + ${n} = ${i + n} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${l} ${h} ${c}`)
        }
        this.valid = r && n && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs()
    }

    get rotate() {
        return this._rotate
    }

    set rotate(t) {
        this._rotate = t, this.valid && this.updateUvs()
    }

    get width() {
        return this.orig.width
    }

    get height() {
        return this.orig.height
    }

    castToBaseTexture() {
        return this.baseTexture
    }

    static get EMPTY() {
        return B._EMPTY || (B._EMPTY = new B(new X), ei(B._EMPTY), ei(B._EMPTY.baseTexture)), B._EMPTY
    }

    static get WHITE() {
        if (!B._WHITE) {
            const t = M.ADAPTER.createCanvas(16, 16), s = t.getContext("2d");
            t.width = 16, t.height = 16, s.fillStyle = "white", s.fillRect(0, 0, 16, 16), B._WHITE = new B(X.from(t)), ei(B._WHITE), ei(B._WHITE.baseTexture)
        }
        return B._WHITE
    }
}

class oe extends B {
    constructor(t, s) {
        super(t, s), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
    }

    get framebuffer() {
        return this.baseTexture.framebuffer
    }

    get multisample() {
        return this.framebuffer.multisample
    }

    set multisample(t) {
        this.framebuffer.multisample = t
    }

    resize(t, s, i = !0) {
        const r = this.baseTexture.resolution, n = Math.round(t * r) / r, o = Math.round(s * r) / r;
        this.valid = n > 0 && o > 0, this._frame.width = this.orig.width = n, this._frame.height = this.orig.height = o, i && this.baseTexture.resize(n, o), this.updateUvs()
    }

    setResolution(t) {
        const {baseTexture: s} = this;
        s.resolution !== t && (s.setResolution(t), this.resize(s.width, s.height, !1))
    }

    static create(t) {
        return new oe(new gr(t))
    }
}

class yr {
    constructor(t) {
        this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
    }

    createTexture(t, s, i = st.NONE) {
        const r = new gr(Object.assign({width: t, height: s, resolution: 1, multisample: i}, this.textureOptions));
        return new oe(r)
    }

    getOptimalTexture(t, s, i = 1, r = st.NONE) {
        let n;
        t = Math.ceil(t * i - 1e-6), s = Math.ceil(s * i - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || s !== this._pixelsHeight ? (t = es(t), s = es(s), n = ((t & 65535) << 16 | s & 65535) >>> 0, r > 1 && (n += r * 4294967296)) : n = r > 1 ? -r : -1, this.texturePool[n] || (this.texturePool[n] = []);
        let o = this.texturePool[n].pop();
        return o || (o = this.createTexture(t, s, r)), o.filterPoolKey = n, o.setResolution(i), o
    }

    getFilterTexture(t, s, i) {
        const r = this.getOptimalTexture(t.width, t.height, s || t.resolution, i || st.NONE);
        return r.filterFrame = t.filterFrame, r
    }

    returnTexture(t) {
        const s = t.filterPoolKey;
        t.filterFrame = null, this.texturePool[s].push(t)
    }

    returnFilterTexture(t) {
        this.returnTexture(t)
    }

    clear(t) {
        if (t = t !== !1, t) for (const s in this.texturePool) {
            const i = this.texturePool[s];
            if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0)
        }
        this.texturePool = {}
    }

    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const s in this.texturePool) {
                if (!(Number(s) < 0)) continue;
                const i = this.texturePool[s];
                if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0);
                this.texturePool[s] = []
            }
            this._pixelsWidth = t.width, this._pixelsHeight = t.height
        }
    }
}

yr.SCREEN_KEY = -1;

class No extends ae {
    constructor() {
        super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}

class Tr extends ae {
    constructor() {
        super(), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new nt(this.vertices), this.uvBuffer = new nt(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }

    map(t, s) {
        let i = 0, r = 0;
        return this.uvs[0] = i, this.uvs[1] = r, this.uvs[2] = i + s.width / t.width, this.uvs[3] = r, this.uvs[4] = i + s.width / t.width, this.uvs[5] = r + s.height / t.height, this.uvs[6] = i, this.uvs[7] = r + s.height / t.height, i = s.x, r = s.y, this.vertices[0] = i, this.vertices[1] = r, this.vertices[2] = i + s.width, this.vertices[3] = r, this.vertices[4] = i + s.width, this.vertices[5] = r + s.height, this.vertices[6] = i, this.vertices[7] = r + s.height, this.invalidate(), this
    }

    invalidate() {
        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
    }
}

class Lo {
    constructor() {
        this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = st.NONE, this.sourceFrame = new z, this.destinationFrame = new z, this.bindingSourceFrame = new z, this.bindingDestinationFrame = new z, this.filters = [], this.transform = null
    }

    clear() {
        this.target = null, this.filters = null, this.renderTexture = null
    }
}

const si = [new j, new j, new j, new j], br = new Q;

class Er {
    constructor(t) {
        this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new yr, this.statePool = [], this.quad = new No, this.quadUv = new Tr, this.tempRect = new z, this.activeState = {}, this.globalUniforms = new Ft({
            outputFrame: new z,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        }, !0), this.forceClear = !1, this.useMaxPadding = !1
    }

    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }

    push(t, s) {
        var p, _;
        const i = this.renderer, r = this.defaultFilterStack, n = this.statePool.pop() || new Lo,
            o = this.renderer.renderTexture;
        let a = s[0].resolution, h = s[0].multisample, l = s[0].padding, c = s[0].autoFit,
            u = (p = s[0].legacy) != null ? p : !0;
        for (let m = 1; m < s.length; m++) {
            const x = s[m];
            a = Math.min(a, x.resolution), h = Math.min(h, x.multisample), l = this.useMaxPadding ? Math.max(l, x.padding) : l + x.padding, c = c && x.autoFit, u = u || ((_ = x.legacy) != null ? _ : !0)
        }
        r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current), r.push(n), n.resolution = a, n.multisample = h, n.legacy = u, n.target = t, n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), n.sourceFrame.pad(l);
        const d = this.tempRect.copyFrom(o.sourceFrame);
        i.projection.transform && this.transformAABB(br.copyFrom(i.projection.transform).invert(), d), c ? (n.sourceFrame.fit(d), (n.sourceFrame.width <= 0 || n.sourceFrame.height <= 0) && (n.sourceFrame.width = 0, n.sourceFrame.height = 0)) : n.sourceFrame.intersects(d) || (n.sourceFrame.width = 0, n.sourceFrame.height = 0), this.roundFrame(n.sourceFrame, o.current ? o.current.resolution : i.resolution, o.sourceFrame, o.destinationFrame, i.projection.transform), n.renderTexture = this.getOptimalFilterTexture(n.sourceFrame.width, n.sourceFrame.height, a, h), n.filters = s, n.destinationFrame.width = n.renderTexture.width, n.destinationFrame.height = n.renderTexture.height;
        const f = this.tempRect;
        f.x = 0, f.y = 0, f.width = n.sourceFrame.width, f.height = n.sourceFrame.height, n.renderTexture.filterFrame = n.sourceFrame, n.bindingSourceFrame.copyFrom(o.sourceFrame), n.bindingDestinationFrame.copyFrom(o.destinationFrame), n.transform = i.projection.transform, i.projection.transform = null, o.bind(n.renderTexture, n.sourceFrame, f), i.framebuffer.clear(0, 0, 0, 0)
    }

    pop() {
        const t = this.defaultFilterStack, s = t.pop(), i = s.filters;
        this.activeState = s;
        const r = this.globalUniforms.uniforms;
        r.outputFrame = s.sourceFrame, r.resolution = s.resolution;
        const n = r.inputSize, o = r.inputPixel, a = r.inputClamp;
        if (n[0] = s.destinationFrame.width, n[1] = s.destinationFrame.height, n[2] = 1 / n[0], n[3] = 1 / n[1], o[0] = Math.round(n[0] * s.resolution), o[1] = Math.round(n[1] * s.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = .5 * o[2], a[1] = .5 * o[3], a[2] = s.sourceFrame.width * n[2] - .5 * o[2], a[3] = s.sourceFrame.height * n[3] - .5 * o[3], s.legacy) {
            const l = r.filterArea;
            l[0] = s.destinationFrame.width, l[1] = s.destinationFrame.height, l[2] = s.sourceFrame.x, l[3] = s.sourceFrame.y, r.filterClamp = r.inputClamp
        }
        this.globalUniforms.update();
        const h = t[t.length - 1];
        if (this.renderer.framebuffer.blit(), i.length === 1) i[0].apply(this, s.renderTexture, h.renderTexture, Ot.BLEND, s), this.returnFilterTexture(s.renderTexture); else {
            let l = s.renderTexture, c = this.getOptimalFilterTexture(l.width, l.height, s.resolution);
            c.filterFrame = l.filterFrame;
            let u = 0;
            for (u = 0; u < i.length - 1; ++u) {
                u === 1 && s.multisample > 1 && (c = this.getOptimalFilterTexture(l.width, l.height, s.resolution), c.filterFrame = l.filterFrame), i[u].apply(this, l, c, Ot.CLEAR, s);
                const d = l;
                l = c, c = d
            }
            i[u].apply(this, l, h.renderTexture, Ot.BLEND, s), u > 1 && s.multisample > 1 && this.returnFilterTexture(s.renderTexture), this.returnFilterTexture(l), this.returnFilterTexture(c)
        }
        s.clear(), this.statePool.push(s)
    }

    bindAndClear(t, s = Ot.CLEAR) {
        const {renderTexture: i, state: r} = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t != null && t.filterFrame) {
            const o = this.tempRect;
            o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, i.bind(t, t.filterFrame, o)
        } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? i.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const n = r.stateId & 1 || this.forceClear;
        (s === Ot.CLEAR || s === Ot.BLIT && n) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }

    applyFilter(t, s, i, r) {
        const n = this.renderer;
        n.state.set(t.state), this.bindAndClear(i, r), t.uniforms.uSampler = s, t.uniforms.filterGlobals = this.globalUniforms, n.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(s._frame, s.filterFrame), n.geometry.bind(this.quadUv), n.geometry.draw(Nt.TRIANGLES)) : (n.geometry.bind(this.quad), n.geometry.draw(Nt.TRIANGLE_STRIP))
    }

    calculateSpriteMatrix(t, s) {
        const {sourceFrame: i, destinationFrame: r} = this.activeState, {orig: n} = s._texture,
            o = t.set(r.width, 0, 0, r.height, i.x, i.y), a = s.worldTransform.copyTo(Q.TEMP_MATRIX);
        return a.invert(), o.prepend(a), o.scale(1 / n.width, 1 / n.height), o.translate(s.anchor.x, s.anchor.y), o
    }

    destroy() {
        this.renderer = null, this.texturePool.clear(!1)
    }

    getOptimalFilterTexture(t, s, i = 1, r = st.NONE) {
        return this.texturePool.getOptimalTexture(t, s, i, r)
    }

    getFilterTexture(t, s, i) {
        if (typeof t == "number") {
            const n = t;
            t = s, s = n
        }
        t = t || this.activeState.renderTexture;
        const r = this.texturePool.getOptimalTexture(t.width, t.height, s || t.resolution, i || st.NONE);
        return r.filterFrame = t.filterFrame, r
    }

    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }

    emptyPool() {
        this.texturePool.clear(!0)
    }

    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }

    transformAABB(t, s) {
        const i = si[0], r = si[1], n = si[2], o = si[3];
        i.set(s.left, s.top), r.set(s.left, s.bottom), n.set(s.right, s.top), o.set(s.right, s.bottom), t.apply(i, i), t.apply(r, r), t.apply(n, n), t.apply(o, o);
        const a = Math.min(i.x, r.x, n.x, o.x), h = Math.min(i.y, r.y, n.y, o.y), l = Math.max(i.x, r.x, n.x, o.x),
            c = Math.max(i.y, r.y, n.y, o.y);
        s.x = a, s.y = h, s.width = l - a, s.height = c - h
    }

    roundFrame(t, s, i, r, n) {
        if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
            if (n) {
                const {a: o, b: a, c: h, d: l} = n;
                if ((Math.abs(a) > 1e-4 || Math.abs(h) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(l) > 1e-4)) return
            }
            n = n ? br.copyFrom(n) : br.identity(), n.translate(-i.x, -i.y).scale(r.width / i.width, r.height / i.height).translate(r.x, r.y), this.transformAABB(n, t), t.ceil(s), this.transformAABB(n.invert(), t)
        }
    }
}

Er.extension = {type: I.RendererSystem, name: "filter"}, O.add(Er);

class Oo {
    constructor(t) {
        this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = st.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
    }
}

const Pd = new z;

class wr {
    constructor(t) {
        this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new ti(10, 10), this.msaaSamples = null
    }

    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new z, this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
            let s = this.renderer.context.extensions.drawBuffers, i = this.renderer.context.extensions.depthTexture;
            M.PREFER_ENV === he.WEBGL_LEGACY && (s = null, i = null), s ? t.drawBuffers = r => s.drawBuffersWEBGL(r) : (this.hasMRT = !1, t.drawBuffers = () => {
            }), i || (this.writeDepthTexture = !1)
        } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }

    bind(t, s, i = 0) {
        const {gl: r} = this;
        if (t) {
            const n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t, r.bindFramebuffer(r.FRAMEBUFFER, n.framebuffer)), n.mipLevel !== i && (t.dirtyId++, t.dirtyFormat++, n.mipLevel = i), n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId, n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat, n.dirtySize = t.dirtySize, this.updateFramebuffer(t, i)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), s) {
                const o = s.width >> i, a = s.height >> i, h = o / s.width;
                this.setViewport(s.x * h, s.y * h, o, a)
            } else {
                const o = t.width >> i, a = t.height >> i;
                this.setViewport(0, 0, o, a)
            }
        } else this.current && (this.current = null, r.bindFramebuffer(r.FRAMEBUFFER, null)), s ? this.setViewport(s.x, s.y, s.width, s.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }

    setViewport(t, s, i, r) {
        const n = this.viewport;
        t = Math.round(t), s = Math.round(s), i = Math.round(i), r = Math.round(r), (n.width !== i || n.height !== r || n.x !== t || n.y !== s) && (n.x = t, n.y = s, n.width = i, n.height = r, this.gl.viewport(t, s, i, r))
    }

    get size() {
        return this.current ? {x: 0, y: 0, width: this.current.width, height: this.current.height} : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }

    clear(t, s, i, r, n = Bs.COLOR | Bs.DEPTH) {
        const {gl: o} = this;
        o.clearColor(t, s, i, r), o.clear(n)
    }

    initFramebuffer(t) {
        const {gl: s} = this, i = new Oo(s.createFramebuffer());
        return i.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(t), t.disposeRunner.add(this), i
    }

    resizeFramebuffer(t) {
        const {gl: s} = this, i = t.glFramebuffers[this.CONTEXT_UID];
        i.stencil && (s.bindRenderbuffer(s.RENDERBUFFER, i.stencil), i.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, i.multisample, s.DEPTH24_STENCIL8, t.width, t.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, t.width, t.height));
        const r = t.colorTextures;
        let n = r.length;
        s.drawBuffers || (n = Math.min(n, 1));
        for (let o = 0; o < n; o++) {
            const a = r[o], h = a.parentTextureArray || a;
            this.renderer.texture.bind(h, 0), o === 0 && i.msaaBuffer && (s.bindRenderbuffer(s.RENDERBUFFER, i.msaaBuffer), s.renderbufferStorageMultisample(s.RENDERBUFFER, i.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }

    updateFramebuffer(t, s) {
        const {gl: i} = this, r = t.glFramebuffers[this.CONTEXT_UID], n = t.colorTextures;
        let o = n.length;
        i.drawBuffers || (o = Math.min(o, 1)), r.multisample > 1 && this.canMultisampleFramebuffer(t) ? r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer() : r.msaaBuffer && (i.deleteRenderbuffer(r.msaaBuffer), r.msaaBuffer = null, r.blitFramebuffer && (r.blitFramebuffer.dispose(), r.blitFramebuffer = null));
        const a = [];
        for (let h = 0; h < o; h++) {
            const l = n[h], c = l.parentTextureArray || l;
            this.renderer.texture.bind(c, 0), h === 0 && r.msaaBuffer ? (i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer), i.renderbufferStorageMultisample(i.RENDERBUFFER, r.multisample, c._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, r.msaaBuffer)) : (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + h, l.target, c._glTextures[this.CONTEXT_UID].texture, s), a.push(i.COLOR_ATTACHMENT0 + h))
        }
        if (a.length > 1 && i.drawBuffers(a), t.depthTexture && this.writeDepthTexture) {
            const l = t.depthTexture;
            this.renderer.texture.bind(l, 0), i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, s)
        }
        (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (r.stencil = r.stencil || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, r.stencil), r.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, r.multisample, i.DEPTH24_STENCIL8, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t.width, t.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, r.stencil)) : r.stencil && (i.deleteRenderbuffer(r.stencil), r.stencil = null)
    }

    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }

    detectSamples(t) {
        const {msaaSamples: s} = this;
        let i = st.NONE;
        if (t <= 1 || s === null) return i;
        for (let r = 0; r < s.length; r++) if (s[r] <= t) {
            i = s[r];
            break
        }
        return i === 1 && (i = st.NONE), i
    }

    blit(t, s, i) {
        const {current: r, renderer: n, gl: o, CONTEXT_UID: a} = this;
        if (n.context.webGLVersion !== 2 || !r) return;
        const h = r.glFramebuffers[a];
        if (!h) return;
        if (!t) {
            if (!h.msaaBuffer) return;
            const c = r.colorTextures[0];
            if (!c) return;
            h.blitFramebuffer || (h.blitFramebuffer = new ti(r.width, r.height), h.blitFramebuffer.addColorTexture(0, c)), t = h.blitFramebuffer, t.colorTextures[0] !== c && (t.colorTextures[0] = c, t.dirtyId++, t.dirtyFormat++), (t.width !== r.width || t.height !== r.height) && (t.width = r.width, t.height = r.height, t.dirtyId++, t.dirtySize++)
        }
        s || (s = Pd, s.width = r.width, s.height = r.height), i || (i = s);
        const l = s.width === i.width && s.height === i.height;
        this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, h.framebuffer), o.blitFramebuffer(s.left, s.top, s.right, s.bottom, i.left, i.top, i.right, i.bottom, o.COLOR_BUFFER_BIT, l ? o.NEAREST : o.LINEAR)
    }

    disposeFramebuffer(t, s) {
        const i = t.glFramebuffers[this.CONTEXT_UID], r = this.gl;
        if (!i) return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const n = this.managedFramebuffers.indexOf(t);
        n >= 0 && this.managedFramebuffers.splice(n, 1), t.disposeRunner.remove(this), s || (r.deleteFramebuffer(i.framebuffer), i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer), i.stencil && r.deleteRenderbuffer(i.stencil)), i.blitFramebuffer && i.blitFramebuffer.dispose()
    }

    disposeAll(t) {
        const s = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let i = 0; i < s.length; i++) this.disposeFramebuffer(s[i], t)
    }

    forceStencil() {
        const t = this.current;
        if (!t) return;
        const s = t.glFramebuffers[this.CONTEXT_UID];
        if (!s || s.stencil) return;
        t.stencil = !0;
        const i = t.width, r = t.height, n = this.gl, o = n.createRenderbuffer();
        n.bindRenderbuffer(n.RENDERBUFFER, o), s.msaaBuffer ? n.renderbufferStorageMultisample(n.RENDERBUFFER, s.multisample, n.DEPTH24_STENCIL8, i, r) : n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, i, r), s.stencil = o, n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, o)
    }

    reset() {
        this.current = this.unknownFramebuffer, this.viewport = new z
    }

    destroy() {
        this.renderer = null
    }
}

wr.extension = {type: I.RendererSystem, name: "framebuffer"}, O.add(wr);
const Ar = {5126: 4, 5123: 2, 5121: 1};

class Sr {
    constructor(t) {
        this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
    }

    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl, s = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, s.webGLVersion !== 2) {
            let i = this.renderer.context.extensions.vertexArrayObject;
            M.PREFER_ENV === he.WEBGL_LEGACY && (i = null), i ? (t.createVertexArray = () => i.createVertexArrayOES(), t.bindVertexArray = r => i.bindVertexArrayOES(r), t.deleteVertexArray = r => i.deleteVertexArrayOES(r)) : (this.hasVao = !1, t.createVertexArray = () => null, t.bindVertexArray = () => null, t.deleteVertexArray = () => null)
        }
        if (s.webGLVersion !== 2) {
            const i = t.getExtension("ANGLE_instanced_arrays");
            i ? (t.vertexAttribDivisor = (r, n) => i.vertexAttribDivisorANGLE(r, n), t.drawElementsInstanced = (r, n, o, a, h) => i.drawElementsInstancedANGLE(r, n, o, a, h), t.drawArraysInstanced = (r, n, o, a) => i.drawArraysInstancedANGLE(r, n, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = s.webGLVersion === 2 || !!s.extensions.uint32ElementIndex
    }

    bind(t, s) {
        s = s || this.renderer.shader.shader;
        const {gl: i} = this;
        let r = t.glVertexArrayObjects[this.CONTEXT_UID], n = !1;
        r || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}, n = !0);
        const o = r[s.program.id] || this.initGeometryVao(t, s, n);
        this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, s.program)), this.updateBuffers()
    }

    reset() {
        this.unbind()
    }

    updateBuffers() {
        const t = this._activeGeometry, s = this.renderer.buffer;
        for (let i = 0; i < t.buffers.length; i++) {
            const r = t.buffers[i];
            s.update(r)
        }
    }

    checkCompatibility(t, s) {
        const i = t.attributes, r = s.attributeData;
        for (const n in r) if (!i[n]) throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)
    }

    getSignature(t, s) {
        const i = t.attributes, r = s.attributeData, n = ["g", t.id];
        for (const o in i) r[o] && n.push(o, r[o].location);
        return n.join("-")
    }

    initGeometryVao(t, s, i = !0) {
        const r = this.gl, n = this.CONTEXT_UID, o = this.renderer.buffer, a = s.program;
        a.glPrograms[n] || this.renderer.shader.generateProgram(s), this.checkCompatibility(t, a);
        const h = this.getSignature(t, a), l = t.glVertexArrayObjects[this.CONTEXT_UID];
        let c = l[h];
        if (c) return l[a.id] = c, c;
        const u = t.buffers, d = t.attributes, f = {}, p = {};
        for (const _ in u) f[_] = 0, p[_] = 0;
        for (const _ in d) !d[_].size && a.attributeData[_] ? d[_].size = a.attributeData[_].size : d[_].size || console.warn(`PIXI Geometry attribute '${_}' size cannot be determined (likely the bound shader does not have the attribute)`), f[d[_].buffer] += d[_].size * Ar[d[_].type];
        for (const _ in d) {
            const m = d[_], x = m.size;
            m.stride === void 0 && (f[m.buffer] === x * Ar[m.type] ? m.stride = 0 : m.stride = f[m.buffer]), m.start === void 0 && (m.start = p[m.buffer], p[m.buffer] += x * Ar[m.type])
        }
        c = r.createVertexArray(), r.bindVertexArray(c);
        for (let _ = 0; _ < u.length; _++) {
            const m = u[_];
            o.bind(m), i && m._glBuffers[n].refCount++
        }
        return this.activateVao(t, a), l[a.id] = c, l[h] = c, r.bindVertexArray(null), o.unbind(Ut.ARRAY_BUFFER), c
    }

    disposeGeometry(t, s) {
        var a;
        if (!this.managedGeometries[t.id]) return;
        delete this.managedGeometries[t.id];
        const i = t.glVertexArrayObjects[this.CONTEXT_UID], r = this.gl, n = t.buffers,
            o = (a = this.renderer) == null ? void 0 : a.buffer;
        if (t.disposeRunner.remove(this), !!i) {
            if (o) for (let h = 0; h < n.length; h++) {
                const l = n[h]._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--, l.refCount === 0 && !s && o.dispose(n[h], s))
            }
            if (!s) {
                for (const h in i) if (h[0] === "g") {
                    const l = i[h];
                    this._activeVao === l && this.unbind(), r.deleteVertexArray(l)
                }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }

    disposeAll(t) {
        const s = Object.keys(this.managedGeometries);
        for (let i = 0; i < s.length; i++) this.disposeGeometry(this.managedGeometries[s[i]], t)
    }

    activateVao(t, s) {
        const i = this.gl, r = this.CONTEXT_UID, n = this.renderer.buffer, o = t.buffers, a = t.attributes;
        t.indexBuffer && n.bind(t.indexBuffer);
        let h = null;
        for (const l in a) {
            const c = a[l], u = o[c.buffer], d = u._glBuffers[r];
            if (s.attributeData[l]) {
                h !== d && (n.bind(u), h = d);
                const f = s.attributeData[l].location;
                if (i.enableVertexAttribArray(f), i.vertexAttribPointer(f, c.size, c.type || i.FLOAT, c.normalized, c.stride, c.start), c.instance) if (this.hasInstance) i.vertexAttribDivisor(f, c.divisor); else throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }

    draw(t, s, i, r) {
        const {gl: n} = this, o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT, h = a === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? n.drawElementsInstanced(t, s || o.indexBuffer.data.length, h, (i || 0) * a, r || 1) : n.drawElements(t, s || o.indexBuffer.data.length, h, (i || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else o.instanced ? n.drawArraysInstanced(t, i, s || o.getSize(), r || 1) : n.drawArrays(t, i, s || o.getSize());
        return this
    }

    unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
    }

    destroy() {
        this.renderer = null
    }
}

Sr.extension = {type: I.RendererSystem, name: "geometry"}, O.add(Sr);
const Uo = new Q;

class ii {
    constructor(t, s) {
        this._texture = t, this.mapCoord = new Q, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof s == "undefined" ? .5 : s, this.isSimple = !1
    }

    get texture() {
        return this._texture
    }

    set texture(t) {
        this._texture = t, this._textureID = -1
    }

    multiplyUvs(t, s) {
        s === void 0 && (s = t);
        const i = this.mapCoord;
        for (let r = 0; r < t.length; r += 2) {
            const n = t[r], o = t[r + 1];
            s[r] = n * i.a + o * i.c + i.tx, s[r + 1] = n * i.b + o * i.d + i.ty
        }
        return s
    }

    update(t) {
        const s = this._texture;
        if (!s || !s.valid || !t && this._textureID === s._updateID) return !1;
        this._textureID = s._updateID, this._updateID++;
        const i = s._uvs;
        this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
        const r = s.orig, n = s.trim;
        n && (Uo.set(r.width / n.width, 0, 0, r.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(Uo));
        const o = s.baseTexture, a = this.uClampFrame, h = this.clampMargin / o.resolution, l = this.clampOffset;
        return a[0] = (s._frame.x + h + l) / o.width, a[1] = (s._frame.y + h + l) / o.height, a[2] = (s._frame.x + s._frame.width - h + l) / o.width, a[3] = (s._frame.y + s._frame.height - h + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = s._frame.width === o.width && s._frame.height === o.height && s.rotate === 0, !0
    }
}

var Md = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, Bd = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;

class ko extends mt {
    constructor(t, s, i) {
        let r = null;
        typeof t != "string" && s === void 0 && i === void 0 && (r = t, t = void 0, s = void 0, i = void 0), super(t || Bd, s || Md, i), this.maskSprite = r, this.maskMatrix = new Q
    }

    get maskSprite() {
        return this._maskSprite
    }

    set maskSprite(t) {
        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
    }

    apply(t, s, i, r) {
        const n = this._maskSprite, o = n._texture;
        !o.valid || (o.uvMatrix || (o.uvMatrix = new ii(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, s, i, r))
    }
}

class Go {
    constructor(t = null) {
        this.type = ht.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = mt.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null
    }

    get filter() {
        return this._filters ? this._filters[0] : null
    }

    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }

    reset() {
        this.pooled && (this.maskObject = null, this.type = ht.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
    }

    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
    }
}

class Rr {
    constructor(t) {
        this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
    }

    setMaskStack(t) {
        this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
    }

    push(t, s) {
        let i = s;
        if (!i.isMaskData) {
            const n = this.maskDataPool.pop() || new Go;
            n.pooled = !0, n.maskObject = s, i = n
        }
        const r = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (i.copyCountersOrReset(r), i._colorMask = r ? r._colorMask : 15, i.autoDetect && this.detect(i), i._target = t, i.type !== ht.SPRITE && this.maskStack.push(i), i.enabled) switch (i.type) {
            case ht.SCISSOR:
                this.renderer.scissor.push(i);
                break;
            case ht.STENCIL:
                this.renderer.stencil.push(i);
                break;
            case ht.SPRITE:
                i.copyCountersOrReset(null), this.pushSpriteMask(i);
                break;
            case ht.COLOR:
                this.pushColorMask(i);
                break;
            default:
                break
        }
        i.type === ht.SPRITE && this.maskStack.push(i)
    }

    pop(t) {
        const s = this.maskStack.pop();
        if (!(!s || s._target !== t)) {
            if (s.enabled) switch (s.type) {
                case ht.SCISSOR:
                    this.renderer.scissor.pop(s);
                    break;
                case ht.STENCIL:
                    this.renderer.stencil.pop(s.maskObject);
                    break;
                case ht.SPRITE:
                    this.popSpriteMask(s);
                    break;
                case ht.COLOR:
                    this.popColorMask(s);
                    break;
                default:
                    break
            }
            if (s.reset(), s.pooled && this.maskDataPool.push(s), this.maskStack.length !== 0) {
                const i = this.maskStack[this.maskStack.length - 1];
                i.type === ht.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject)
            }
        }
    }

    detect(t) {
        const s = t.maskObject;
        s ? s.isSprite ? t.type = ht.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = ht.SCISSOR : t.type = ht.STENCIL : t.type = ht.COLOR
    }

    pushSpriteMask(t) {
        var c, u;
        const {maskObject: s} = t, i = t._target;
        let r = t._filters;
        r || (r = this.alphaMaskPool[this.alphaMaskIndex], r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new ko]));
        const n = this.renderer, o = n.renderTexture;
        let a, h;
        if (o.current) {
            const d = o.current;
            a = t.resolution || d.resolution, h = (c = t.multisample) != null ? c : d.multisample
        } else a = t.resolution || n.resolution, h = (u = t.multisample) != null ? u : n.multisample;
        r[0].resolution = a, r[0].multisample = h, r[0].maskSprite = s;
        const l = i.filterArea;
        i.filterArea = s.getBounds(!0), n.filter.push(i, r), i.filterArea = l, t._filters || this.alphaMaskIndex++
    }

    popSpriteMask(t) {
        this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }

    pushColorMask(t) {
        const s = t._colorMask, i = t._colorMask = s & t.colorMask;
        i !== s && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }

    popColorMask(t) {
        const s = t._colorMask,
            i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        i !== s && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0)
    }

    destroy() {
        this.renderer = null
    }
}

Rr.extension = {type: I.RendererSystem, name: "mask"}, O.add(Rr);

class Ho {
    constructor(t) {
        this.renderer = t, this.maskStack = [], this.glConst = 0
    }

    getStackLength() {
        return this.maskStack.length
    }

    setMaskStack(t) {
        const {gl: s} = this.renderer, i = this.getStackLength();
        this.maskStack = t;
        const r = this.getStackLength();
        r !== i && (r === 0 ? s.disable(this.glConst) : (s.enable(this.glConst), this._useCurrent()))
    }

    _useCurrent() {
    }

    destroy() {
        this.renderer = null, this.maskStack = null
    }
}

const Xo = new Q, Vo = [], ri = class extends Ho {
    constructor(e) {
        super(e), this.glConst = M.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
    }

    getStackLength() {
        const e = this.maskStack[this.maskStack.length - 1];
        return e ? e._scissorCounter : 0
    }

    calcScissorRect(e) {
        var o;
        if (e._scissorRectLocal) return;
        const t = e._scissorRect, {maskObject: s} = e, {renderer: i} = this, r = i.renderTexture,
            n = s.getBounds(!0, (o = Vo.pop()) != null ? o : new z);
        this.roundFrameToPixels(n, r.current ? r.current.resolution : i.resolution, r.sourceFrame, r.destinationFrame, i.projection.transform), t && n.fit(t), e._scissorRectLocal = n
    }

    static isMatrixRotated(e) {
        if (!e) return !1;
        const {a: t, b: s, c: i, d: r} = e;
        return (Math.abs(s) > 1e-4 || Math.abs(i) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(r) > 1e-4)
    }

    testScissor(e) {
        const {maskObject: t} = e;
        if (!t.isFastRect || !t.isFastRect() || ri.isMatrixRotated(t.worldTransform) || ri.isMatrixRotated(this.renderer.projection.transform)) return !1;
        this.calcScissorRect(e);
        const s = e._scissorRectLocal;
        return s.width > 0 && s.height > 0
    }

    roundFrameToPixels(e, t, s, i, r) {
        ri.isMatrixRotated(r) || (r = r ? Xo.copyFrom(r) : Xo.identity(), r.translate(-s.x, -s.y).scale(i.width / s.width, i.height / s.height).translate(i.x, i.y), this.renderer.filter.transformAABB(r, e), e.fit(i), e.x = Math.round(e.x * t), e.y = Math.round(e.y * t), e.width = Math.round(e.width * t), e.height = Math.round(e.height * t))
    }

    push(e) {
        e._scissorRectLocal || this.calcScissorRect(e);
        const {gl: t} = this.renderer;
        e._scissorRect || t.enable(t.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent()
    }

    pop(e) {
        const {gl: t} = this.renderer;
        e && Vo.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
    }

    _useCurrent() {
        const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let t;
        this.renderer.renderTexture.current ? t = e.y : t = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
    }
};
let Cr = ri;
Cr.extension = {type: I.RendererSystem, name: "scissor"}, O.add(Cr);

class Ir extends Ho {
    constructor(t) {
        super(t), this.glConst = M.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }

    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }

    push(t) {
        const s = t.maskObject, {gl: i} = this.renderer, r = t._stencilCounter;
        r === 0 && (this.renderer.framebuffer.forceStencil(), i.clearStencil(0), i.clear(i.STENCIL_BUFFER_BIT), i.enable(i.STENCIL_TEST)), t._stencilCounter++;
        const n = t._colorMask;
        n !== 0 && (t._colorMask = 0, i.colorMask(!1, !1, !1, !1)), i.stencilFunc(i.EQUAL, r, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.INCR), s.renderable = !0, s.render(this.renderer), this.renderer.batch.flush(), s.renderable = !1, n !== 0 && (t._colorMask = n, i.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)), this._useCurrent()
    }

    pop(t) {
        const s = this.renderer.gl;
        if (this.getStackLength() === 0) s.disable(s.STENCIL_TEST); else {
            const i = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null,
                r = i ? i._colorMask : 15;
            r !== 0 && (i._colorMask = 0, s.colorMask(!1, !1, !1, !1)), s.stencilOp(s.KEEP, s.KEEP, s.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, r !== 0 && (i._colorMask = r, s.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)), this._useCurrent()
        }
    }

    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}

Ir.extension = {type: I.RendererSystem, name: "stencil"}, O.add(Ir);

class Pr {
    constructor(t) {
        this.renderer = t, this.plugins = {}, Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1, get() {
                    return Y("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), t.extract
                }
            }, prepare: {
                enumerable: !1, get() {
                    return Y("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), t.prepare
                }
            }, interaction: {
                enumerable: !1, get() {
                    return Y("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), t.events
                }
            }
        })
    }

    init(t) {
        for (const s in t) this.plugins[s] = new t[s](this.renderer)
    }

    destroy() {
        for (const t in this.plugins) this.plugins[t].destroy(), this.plugins[t] = null
    }
}

Pr.extension = {type: [I.RendererSystem, I.CanvasRendererSystem], name: "_plugin"}, O.add(Pr);

class Mr {
    constructor(t) {
        this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Q, this.transform = null
    }

    update(t, s, i, r) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = s || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, r), this.transform && this.projectionMatrix.append(this.transform);
        const n = this.renderer;
        n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, n.globalUniforms.update(), n.shader.shader && n.shader.syncUniformGroup(n.shader.shader.uniforms.globals)
    }

    calculateProjection(t, s, i, r) {
        const n = this.projectionMatrix, o = r ? -1 : 1;
        n.identity(), n.a = 1 / s.width * 2, n.d = o * (1 / s.height * 2), n.tx = -1 - s.x * n.a, n.ty = -o - s.y * n.d
    }

    setTransform(t) {
    }

    destroy() {
        this.renderer = null
    }
}

Mr.extension = {type: I.RendererSystem, name: "projection"}, O.add(Mr);
const Dd = new is;

class Br {
    constructor(t) {
        this.renderer = t, this._tempMatrix = new Q
    }

    generateTexture(t, s) {
        const h = s || {}, {region: i} = h, r = Li(h, ["region"]), n = i || t.getLocalBounds(null, !0);
        n.width === 0 && (n.width = 1), n.height === 0 && (n.height = 1);
        const o = oe.create(Yt({width: n.width, height: n.height}, r));
        this._tempMatrix.tx = -n.x, this._tempMatrix.ty = -n.y;
        const a = t.transform;
        return t.transform = Dd, this.renderer.render(t, {
            renderTexture: o,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }), t.transform = a, o
    }

    destroy() {
    }
}

Br.extension = {type: [I.RendererSystem, I.CanvasRendererSystem], name: "textureGenerator"}, O.add(Br);
const Se = new z, as = new z;

class Dr {
    constructor(t) {
        this.renderer = t, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new z, this.destinationFrame = new z, this.viewportFrame = new z
    }

    bind(t = null, s, i) {
        const r = this.renderer;
        this.current = t;
        let n, o, a;
        t ? (n = t.baseTexture, a = n.resolution, s || (Se.width = t.frame.width, Se.height = t.frame.height, s = Se), i || (as.x = t.frame.x, as.y = t.frame.y, as.width = s.width, as.height = s.height, i = as), o = n.framebuffer) : (a = r.resolution, s || (Se.width = r._view.screen.width, Se.height = r._view.screen.height, s = Se), i || (i = Se, i.width = s.width, i.height = s.height));
        const h = this.viewportFrame;
        h.x = i.x * a, h.y = i.y * a, h.width = i.width * a, h.height = i.height * a, t || (h.y = r.view.height - (h.y + h.height)), h.ceil(), this.renderer.framebuffer.bind(o, h), this.renderer.projection.update(i, s, a, !o), t ? this.renderer.mask.setMaskStack(n.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(s), this.destinationFrame.copyFrom(i)
    }

    clear(t, s) {
        this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.renderer.background.colorRgba;
        const i = this.destinationFrame, r = this.current ? this.current.baseTexture : this.renderer._view.screen,
            n = i.width !== r.width || i.height !== r.height;
        if (n) {
            let {x: o, y: a, width: h, height: l} = this.viewportFrame;
            o = Math.round(o), a = Math.round(a), h = Math.round(h), l = Math.round(l), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(o, a, h, l)
        }
        this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], s), n && this.renderer.scissor.pop()
    }

    resize() {
        this.bind(null)
    }

    reset() {
        this.bind(null)
    }

    destroy() {
        this.renderer = null
    }
}

Dr.extension = {type: I.RendererSystem, name: "renderTexture"}, O.add(Dr);

class Fd {
}

class zo {
    constructor(t, s) {
        this.program = t, this.uniformData = s, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
    }

    destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
    }
}

function Nd(e, t) {
    const s = {}, i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let r = 0; r < i; r++) {
        const n = t.getActiveAttrib(e, r);
        if (n.name.startsWith("gl_")) continue;
        const o = Io(t, n.type), a = {type: o, name: n.name, size: Ro(o), location: t.getAttribLocation(e, n.name)};
        s[n.name] = a
    }
    return s
}

function Ld(e, t) {
    const s = {}, i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; r++) {
        const n = t.getActiveUniform(e, r), o = n.name.replace(/\[.*?\]$/, ""), a = !!n.name.match(/\[.*?\]$/),
            h = Io(t, n.type);
        s[o] = {name: o, index: r, type: h, size: n.size, isArray: a, value: Eo(h, n.size)}
    }
    return s
}

function Wo(e, t) {
    var h;
    const s = bo(e, e.VERTEX_SHADER, t.vertexSrc), i = bo(e, e.FRAGMENT_SHADER, t.fragmentSrc), r = e.createProgram();
    e.attachShader(r, s), e.attachShader(r, i);
    const n = (h = t.extra) == null ? void 0 : h.transformFeedbackVaryings;
    if (n && (typeof e.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(r, n.names, n.bufferMode === "separate" ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)), e.linkProgram(r), e.getProgramParameter(r, e.LINK_STATUS) || vd(e, r, s, i), t.attributeData = Nd(r, e), t.uniformData = Ld(r, e), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const l = Object.keys(t.attributeData);
        l.sort((c, u) => c > u ? 1 : -1);
        for (let c = 0; c < l.length; c++) t.attributeData[l[c]].location = c, e.bindAttribLocation(r, c, l[c]);
        e.linkProgram(r)
    }
    e.deleteShader(s), e.deleteShader(i);
    const o = {};
    for (const l in t.uniformData) {
        const c = t.uniformData[l];
        o[l] = {location: e.getUniformLocation(r, l), value: Eo(c.type, c.size)}
    }
    return new zo(r, o)
}

function Od(e, t, s, i, r) {
    s.buffer.update(r)
}

const Ud = {
    float: `
        data[offset] = v;
    `, vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `, vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `, vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `, mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `, mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `, mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, jo = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
};

function $o(e) {
    const t = e.map(n => ({data: n, offset: 0, dataLen: 0, dirty: 0}));
    let s = 0, i = 0, r = 0;
    for (let n = 0; n < t.length; n++) {
        const o = t[n];
        if (s = jo[o.data.type], o.data.size > 1 && (s = Math.max(s, 16) * o.data.size), o.dataLen = s, i % s !== 0 && i < 16) {
            const a = i % s % 16;
            i += a, r += a
        }
        i + s > 16 ? (r = Math.ceil(r / 16) * 16, o.offset = r, r += s, i = s) : (o.offset = r, i += s, r += s)
    }
    return r = Math.ceil(r / 16) * 16, {uboElements: t, size: r}
}

function Yo(e, t) {
    const s = [];
    for (const i in e) t[i] && s.push(t[i]);
    return s.sort((i, r) => i.index - r.index), s
}

function qo(e, t) {
    if (!e.autoManage) return {size: 0, syncFunc: Od};
    const s = Yo(e.uniforms, t), {uboElements: i, size: r} = $o(s), n = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < i.length; o++) {
        const a = i[o], h = e.uniforms[a.data.name], l = a.data.name;
        let c = !1;
        for (let u = 0; u < Ae.length; u++) {
            const d = Ae[u];
            if (d.codeUbo && d.test(a.data, h)) {
                n.push(`offset = ${a.offset / 4};`, Ae[u].codeUbo(a.data.name, h)), c = !0;
                break
            }
        }
        if (!c) if (a.data.size > 1) {
            const u = Ro(a.data.type), d = Math.max(jo[a.data.type] / 16, 1), f = u / d, p = (4 - f % 4) % 4;
            n.push(`
                cv = ud.${l}.value;
                v = uv.${l};
                offset = ${a.offset / 4};

                t = 0;

                for(var i=0; i < ${a.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
        } else {
            const u = Ud[a.data.type];
            n.push(`
                cv = ud.${l}.value;
                v = uv.${l};
                offset = ${a.offset / 4};
                ${u};
                `)
        }
    }
    return n.push(`
       renderer.buffer.update(buffer);
    `), {
        size: r, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", n.join(`
`))
    }
}

let kd = 0;
const ni = {textureCount: 0, uboCount: 0};

class Fr {
    constructor(t) {
        this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = kd++
    }

    systemCheck() {
        if (!Mo()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }

    contextChange(t) {
        this.gl = t, this.reset()
    }

    bind(t, s) {
        t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
        const i = t.program, r = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t, this.program !== i && (this.program = i, this.gl.useProgram(r.program)), s || (ni.textureCount = 0, ni.uboCount = 0, this.syncUniformGroup(t.uniformGroup, ni)), r
    }

    setUniforms(t) {
        const s = this.shader.program, i = s.glPrograms[this.renderer.CONTEXT_UID];
        s.syncUniforms(i.uniformData, t, this.renderer)
    }

    syncUniformGroup(t, s) {
        const i = this.getGlProgram();
        (!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) && (i.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, i, s))
    }

    syncUniforms(t, s, i) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(s.uniformData, t.uniforms, this.renderer, i)
    }

    createSyncGroups(t) {
        const s = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[s] || (this.cache[s] = gd(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[s], t.syncUniforms[this.shader.program.id]
    }

    syncUniformBufferGroup(t, s) {
        const i = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const r = i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, s);
            t.buffer.update(), r(i.uniformData, t.uniforms, this.renderer, ni, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, i.uniformBufferBindings[s])
    }

    createSyncBufferGroup(t, s, i) {
        const {gl: r} = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const n = this.gl.getUniformBlockIndex(s.program, i);
        s.uniformBufferBindings[i] = this.shader.uniformBindCount, r.uniformBlockBinding(s.program, n, this.shader.uniformBindCount), this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = qo(t, this.shader.program.uniformData)), t.autoManage) {
            const h = new Float32Array(a.size / 4);
            t.buffer.update(h)
        }
        return s.uniformGroups[t.id] = a.syncFunc, s.uniformGroups[t.id]
    }

    getSignature(t, s, i) {
        const r = t.uniforms, n = [`${i}-`];
        for (const o in r) n.push(o), s[o] && n.push(s[o].type);
        return n.join("-")
    }

    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }

    generateProgram(t) {
        const s = this.gl, i = t.program, r = Wo(s, i);
        return i.glPrograms[this.renderer.CONTEXT_UID] = r, r
    }

    reset() {
        this.program = null, this.shader = null
    }

    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }

    destroy() {
        this.renderer = null, this.destroyed = !0
    }
}

Fr.extension = {type: I.RendererSystem, name: "shader"}, O.add(Fr);

class Nr {
    constructor(t) {
        this.renderer = t
    }

    run(t) {
        const s = this.renderer;
        s.emitWithCustomOptions(s.runners.init, t), t.hello && console.log(`PixiJS 7.1.2 - ${s.rendererLogId} - https://pixijs.com`), s.resize(this.renderer.screen.width, this.renderer.screen.height)
    }

    destroy() {
    }
}

Nr.extension = {type: [I.RendererSystem, I.CanvasRendererSystem], name: "startup"}, O.add(Nr);

function Gd(e, t = []) {
    return t[k.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.ADD] = [e.ONE, e.ONE], t[k.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.NONE] = [0, 0], t[k.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], t[k.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[k.SRC_IN] = [e.DST_ALPHA, e.ZERO], t[k.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], t[k.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[k.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], t[k.DST_IN] = [e.ZERO, e.SRC_ALPHA], t[k.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], t[k.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], t[k.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[k.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], t
}

const Hd = 0, Xd = 1, Vd = 2, zd = 3, Wd = 4, jd = 5, Lr = class {
    constructor() {
        this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = k.NONE, this._blendEq = !1, this.map = [], this.map[Hd] = this.setBlend, this.map[Xd] = this.setOffset, this.map[Vd] = this.setCullFace, this.map[zd] = this.setDepthTest, this.map[Wd] = this.setFrontFace, this.map[jd] = this.setDepthMask, this.checks = [], this.defaultState = new Jt, this.defaultState.blend = !0
    }

    contextChange(e) {
        this.gl = e, this.blendModes = Gd(e), this.set(this.defaultState), this.reset()
    }

    set(e) {
        if (e = e || this.defaultState, this.stateId !== e.data) {
            let t = this.stateId ^ e.data, s = 0;
            for (; t;) t & 1 && this.map[s].call(this, !!(e.data & 1 << s)), t = t >> 1, s++;
            this.stateId = e.data
        }
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
    }

    forceState(e) {
        e = e || this.defaultState;
        for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & 1 << t));
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
        this.stateId = e.data
    }

    setBlend(e) {
        this.updateCheck(Lr.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
    }

    setOffset(e) {
        this.updateCheck(Lr.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
    }

    setDepthTest(e) {
        this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
    }

    setDepthMask(e) {
        this.gl.depthMask(e)
    }

    setCullFace(e) {
        this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
    }

    setFrontFace(e) {
        this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
    }

    setBlendMode(e) {
        if (e === this.blendMode) return;
        this.blendMode = e;
        const t = this.blendModes[e], s = this.gl;
        t.length === 2 ? s.blendFunc(t[0], t[1]) : s.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, s.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, s.blendEquationSeparate(s.FUNC_ADD, s.FUNC_ADD))
    }

    setPolygonOffset(e, t) {
        this.gl.polygonOffset(e, t)
    }

    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
    }

    updateCheck(e, t) {
        const s = this.checks.indexOf(e);
        t && s === -1 ? this.checks.push(e) : !t && s !== -1 && this.checks.splice(s, 1)
    }

    static checkBlendMode(e, t) {
        e.setBlendMode(t.blendMode)
    }

    static checkPolygonOffset(e, t) {
        e.setPolygonOffset(1, t.polygonOffset)
    }

    destroy() {
        this.gl = null
    }
};
let Or = Lr;
Or.extension = {type: I.RendererSystem, name: "state"}, O.add(Or);

class Ko extends De {
    constructor() {
        super(...arguments), this.runners = {}, this._systemsHash = {}
    }

    setup(t) {
        var r;
        this.addRunners(...t.runners);
        const s = ((r = t.priority) != null ? r : []).filter(n => t.systems[n]),
            i = [...s, ...Object.keys(t.systems).filter(n => !s.includes(n))];
        for (const n of i) this.addSystem(t.systems[n], n)
    }

    addRunners(...t) {
        t.forEach(s => {
            this.runners[s] = new St(s)
        })
    }

    addSystem(t, s) {
        const i = new t(this);
        if (this[s]) throw new Error(`Whoops! The name "${s}" is already in use`);
        this[s] = i, this._systemsHash[s] = i;
        for (const r in this.runners) this.runners[r].add(i);
        return this
    }

    emitWithCustomOptions(t, s) {
        const i = Object.keys(this._systemsHash);
        t.items.forEach(r => {
            const n = i.find(o => this._systemsHash[o] === r);
            r[t.name](s[n])
        })
    }

    destroy() {
        Object.values(this.runners).forEach(t => {
            t.destroy()
        }), this._systemsHash = {}
    }
}

const oi = class {
    constructor(e) {
        this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = oi.defaultMaxIdle, this.checkCountMax = oi.defaultCheckCountMax, this.mode = oi.defaultMode
    }

    postrender() {
        !this.renderer.objectRenderer.renderingToScreen || (this.count++, this.mode !== Fs.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
    }

    run() {
        const e = this.renderer.texture, t = e.managedTextures;
        let s = !1;
        for (let i = 0; i < t.length; i++) {
            const r = t[i];
            !r.framebuffer && this.count - r.touched > this.maxIdle && (e.destroyTexture(r, !0), t[i] = null, s = !0)
        }
        if (s) {
            let i = 0;
            for (let r = 0; r < t.length; r++) t[r] !== null && (t[i++] = t[r]);
            t.length = i
        }
    }

    unload(e) {
        const t = this.renderer.texture, s = e._texture;
        s && !s.framebuffer && t.destroyTexture(s);
        for (let i = e.children.length - 1; i >= 0; i--) this.unload(e.children[i])
    }

    destroy() {
        this.renderer = null
    }
};
let Bt = oi;
Bt.defaultMode = Fs.AUTO, Bt.defaultMaxIdle = 60 * 60, Bt.defaultCheckCountMax = 60 * 10, Bt.extension = {
    type: I.RendererSystem,
    name: "textureGC"
}, O.add(Bt);

class ai {
    constructor(t) {
        this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = U.UNSIGNED_BYTE, this.internalFormat = R.RGBA, this.samplerType = 0
    }
}

function $d(e) {
    let t;
    return "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [U.UNSIGNED_BYTE]: {
            [R.RGBA]: e.RGBA8,
            [R.RGB]: e.RGB8,
            [R.RG]: e.RG8,
            [R.RED]: e.R8,
            [R.RGBA_INTEGER]: e.RGBA8UI,
            [R.RGB_INTEGER]: e.RGB8UI,
            [R.RG_INTEGER]: e.RG8UI,
            [R.RED_INTEGER]: e.R8UI,
            [R.ALPHA]: e.ALPHA,
            [R.LUMINANCE]: e.LUMINANCE,
            [R.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [U.BYTE]: {
            [R.RGBA]: e.RGBA8_SNORM,
            [R.RGB]: e.RGB8_SNORM,
            [R.RG]: e.RG8_SNORM,
            [R.RED]: e.R8_SNORM,
            [R.RGBA_INTEGER]: e.RGBA8I,
            [R.RGB_INTEGER]: e.RGB8I,
            [R.RG_INTEGER]: e.RG8I,
            [R.RED_INTEGER]: e.R8I
        },
        [U.UNSIGNED_SHORT]: {
            [R.RGBA_INTEGER]: e.RGBA16UI,
            [R.RGB_INTEGER]: e.RGB16UI,
            [R.RG_INTEGER]: e.RG16UI,
            [R.RED_INTEGER]: e.R16UI,
            [R.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
        },
        [U.SHORT]: {
            [R.RGBA_INTEGER]: e.RGBA16I,
            [R.RGB_INTEGER]: e.RGB16I,
            [R.RG_INTEGER]: e.RG16I,
            [R.RED_INTEGER]: e.R16I
        },
        [U.UNSIGNED_INT]: {
            [R.RGBA_INTEGER]: e.RGBA32UI,
            [R.RGB_INTEGER]: e.RGB32UI,
            [R.RG_INTEGER]: e.RG32UI,
            [R.RED_INTEGER]: e.R32UI,
            [R.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
        },
        [U.INT]: {
            [R.RGBA_INTEGER]: e.RGBA32I,
            [R.RGB_INTEGER]: e.RGB32I,
            [R.RG_INTEGER]: e.RG32I,
            [R.RED_INTEGER]: e.R32I
        },
        [U.FLOAT]: {
            [R.RGBA]: e.RGBA32F,
            [R.RGB]: e.RGB32F,
            [R.RG]: e.RG32F,
            [R.RED]: e.R32F,
            [R.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
        },
        [U.HALF_FLOAT]: {[R.RGBA]: e.RGBA16F, [R.RGB]: e.RGB16F, [R.RG]: e.RG16F, [R.RED]: e.R16F},
        [U.UNSIGNED_SHORT_5_6_5]: {[R.RGB]: e.RGB565},
        [U.UNSIGNED_SHORT_4_4_4_4]: {[R.RGBA]: e.RGBA4},
        [U.UNSIGNED_SHORT_5_5_5_1]: {[R.RGBA]: e.RGB5_A1},
        [U.UNSIGNED_INT_2_10_10_10_REV]: {[R.RGBA]: e.RGB10_A2, [R.RGBA_INTEGER]: e.RGB10_A2UI},
        [U.UNSIGNED_INT_10F_11F_11F_REV]: {[R.RGB]: e.R11F_G11F_B10F},
        [U.UNSIGNED_INT_5_9_9_9_REV]: {[R.RGB]: e.RGB9_E5},
        [U.UNSIGNED_INT_24_8]: {[R.DEPTH_STENCIL]: e.DEPTH24_STENCIL8},
        [U.FLOAT_32_UNSIGNED_INT_24_8_REV]: {[R.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8}
    } : t = {
        [U.UNSIGNED_BYTE]: {
            [R.RGBA]: e.RGBA,
            [R.RGB]: e.RGB,
            [R.ALPHA]: e.ALPHA,
            [R.LUMINANCE]: e.LUMINANCE,
            [R.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [U.UNSIGNED_SHORT_5_6_5]: {[R.RGB]: e.RGB},
        [U.UNSIGNED_SHORT_4_4_4_4]: {[R.RGBA]: e.RGBA},
        [U.UNSIGNED_SHORT_5_5_5_1]: {[R.RGBA]: e.RGBA}
    }, t
}

class Ur {
    constructor(t) {
        this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new X, this.hasIntegerTextures = !1
    }

    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = $d(t);
        const s = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = s;
        for (let r = 0; r < s; r++) this.boundTextures[r] = null;
        this.emptyTextures = {};
        const i = new ai(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, i.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = i, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new ai(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let r = 0; r < 6; r++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let r = 0; r < this.boundTextures.length; r++) this.bind(null, r)
    }

    bind(t, s = 0) {
        const {gl: i} = this;
        if (t = t == null ? void 0 : t.castToBaseTexture(), (t == null ? void 0 : t.valid) && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[s] !== t && (this.currentLocation !== s && (this.currentLocation = s, i.activeTexture(i.TEXTURE0 + s)), i.bindTexture(t.target, r.texture)), r.dirtyId !== t.dirtyId ? (this.currentLocation !== s && (this.currentLocation = s, i.activeTexture(i.TEXTURE0 + s)), this.updateTexture(t)) : r.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[s] = t
        } else this.currentLocation !== s && (this.currentLocation = s, i.activeTexture(i.TEXTURE0 + s)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[s] = null
    }

    reset() {
        this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
    }

    unbind(t) {
        const {gl: s, boundTextures: i} = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let r = 0; r < i.length; r++) i[r] === this.unknownTexture && this.bind(null, r)
        }
        for (let r = 0; r < i.length; r++) i[r] === t && (this.currentLocation !== r && (s.activeTexture(s.TEXTURE0 + r), this.currentLocation = r), s.bindTexture(t.target, this.emptyTextures[t.target].texture), i[r] = null)
    }

    ensureSamplerType(t) {
        const {boundTextures: s, hasIntegerTextures: i, CONTEXT_UID: r} = this;
        if (!!i) for (let n = t - 1; n >= 0; --n) {
            const o = s[n];
            o && o._glTextures[r].samplerType !== Ds.FLOAT && this.renderer.texture.unbind(o)
        }
    }

    initTexture(t) {
        const s = new ai(this.gl.createTexture());
        return s.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = s, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), s
    }

    initTextureType(t, s) {
        var i, r;
        s.internalFormat = (r = (i = this.internalFormats[t.type]) == null ? void 0 : i[t.format]) != null ? r : t.format, this.webGLVersion === 2 && t.type === U.HALF_FLOAT ? s.type = this.gl.HALF_FLOAT : s.type = t.type
    }

    updateTexture(t) {
        var r;
        const s = t._glTextures[this.CONTEXT_UID];
        if (!s) return;
        const i = this.renderer;
        if (this.initTextureType(t, s), (r = t.resource) != null && r.upload(i, t, s)) s.samplerType !== Ds.FLOAT && (this.hasIntegerTextures = !0); else {
            const n = t.realWidth, o = t.realHeight, a = i.gl;
            (s.width !== n || s.height !== o || s.dirtyId < 0) && (s.width = n, s.height = o, a.texImage2D(t.target, 0, s.internalFormat, n, o, 0, t.format, s.type, null))
        }
        t.dirtyStyleId !== s.dirtyStyleId && this.updateTextureStyle(t), s.dirtyId = t.dirtyId
    }

    destroyTexture(t, s) {
        const {gl: i} = this;
        if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !s)) {
            const r = this.managedTextures.indexOf(t);
            r !== -1 && ve(this.managedTextures, r, 1)
        }
    }

    updateTextureStyle(t) {
        var i;
        const s = t._glTextures[this.CONTEXT_UID];
        !s || ((t.mipmap === Lt.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? s.mipmap = !1 : s.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? s.wrapMode = Kt.CLAMP : s.wrapMode = t.wrapMode, (i = t.resource) != null && i.style(this.renderer, t, s) || this.setStyle(t, s), s.dirtyStyleId = t.dirtyStyleId)
    }

    setStyle(t, s) {
        const i = this.gl;
        if (s.mipmap && t.mipmap !== Lt.ON_MANUAL && i.generateMipmap(t.target), i.texParameteri(t.target, i.TEXTURE_WRAP_S, s.wrapMode), i.texParameteri(t.target, i.TEXTURE_WRAP_T, s.wrapMode), s.mipmap) {
            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === qt.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
            const r = this.renderer.context.extensions.anisotropicFiltering;
            if (r && t.anisotropicLevel > 0 && t.scaleMode === qt.LINEAR) {
                const n = Math.min(t.anisotropicLevel, i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, n)
            }
        } else i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === qt.LINEAR ? i.LINEAR : i.NEAREST);
        i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === qt.LINEAR ? i.LINEAR : i.NEAREST)
    }

    destroy() {
        this.renderer = null
    }
}

Ur.extension = {type: I.RendererSystem, name: "texture"}, O.add(Ur);

class kr {
    constructor(t) {
        this.renderer = t
    }

    contextChange() {
        this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }

    bind(t) {
        const {gl: s, CONTEXT_UID: i} = this, r = t._glTransformFeedbacks[i] || this.createGLTransformFeedback(t);
        s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, r)
    }

    unbind() {
        const {gl: t} = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }

    beginTransformFeedback(t, s) {
        const {gl: i, renderer: r} = this;
        s && r.shader.bind(s), i.beginTransformFeedback(t)
    }

    endTransformFeedback() {
        const {gl: t} = this;
        t.endTransformFeedback()
    }

    createGLTransformFeedback(t) {
        const {gl: s, renderer: i, CONTEXT_UID: r} = this, n = s.createTransformFeedback();
        t._glTransformFeedbacks[r] = n, s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, n);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            !a || (i.buffer.update(a), a._glBuffers[r].refCount++, s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[r].buffer || null))
        }
        return s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), t.disposeRunner.add(this), n
    }

    disposeTransformFeedback(t, s) {
        const i = t._glTransformFeedbacks[this.CONTEXT_UID], r = this.gl;
        t.disposeRunner.remove(this);
        const n = this.renderer.buffer;
        if (n) for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            if (!a) continue;
            const h = a._glBuffers[this.CONTEXT_UID];
            h && (h.refCount--, h.refCount === 0 && !s && n.dispose(a, s))
        }
        !i || (s || r.deleteTransformFeedback(i), delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }

    destroy() {
        this.renderer = null
    }
}

kr.extension = {type: I.RendererSystem, name: "transformFeedback"}, O.add(kr);

class Gr {
    constructor(t) {
        this.renderer = t
    }

    init(t) {
        this.screen = new z(0, 0, t.width, t.height), this.element = t.view || M.ADAPTER.createCanvas(), this.resolution = t.resolution || M.RESOLUTION, this.autoDensity = !!t.autoDensity
    }

    resizeView(t, s) {
        this.element.width = Math.round(t * this.resolution), this.element.height = Math.round(s * this.resolution);
        const i = this.element.width / this.resolution, r = this.element.height / this.resolution;
        this.screen.width = i, this.screen.height = r, this.autoDensity && (this.element.style.width = `${i}px`, this.element.style.height = `${r}px`), this.renderer.emit("resize", i, r), this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }

    destroy(t) {
        var s;
        t && ((s = this.element.parentNode) == null || s.removeChild(this.element)), this.renderer = null, this.element = null, this.screen = null
    }
}

Gr.extension = {
    type: [I.RendererSystem, I.CanvasRendererSystem],
    name: "_view"
}, O.add(Gr), M.PREFER_ENV = he.WEBGL2, M.STRICT_TEXTURE_CACHE = !1, Object.defineProperties(M, {
    WRAP_MODE: {
        get() {
            return X.defaultOptions.wrapMode
        }, set(e) {
            Y("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), X.defaultOptions.wrapMode = e
        }
    }, SCALE_MODE: {
        get() {
            return X.defaultOptions.scaleMode
        }, set(e) {
            Y("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), X.defaultOptions.scaleMode = e
        }
    }, MIPMAP_TEXTURES: {
        get() {
            return X.defaultOptions.mipmap
        }, set(e) {
            Y("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), X.defaultOptions.mipmap = e
        }
    }, ANISOTROPIC_LEVEL: {
        get() {
            return X.defaultOptions.anisotropicLevel
        }, set(e) {
            Y("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"), X.defaultOptions.anisotropicLevel = e
        }
    }, FILTER_RESOLUTION: {
        get() {
            return Y("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), mt.defaultResolution
        }, set(e) {
            mt.defaultResolution = e
        }
    }, FILTER_MULTISAMPLE: {
        get() {
            return Y("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), mt.defaultMultisample
        }, set(e) {
            mt.defaultMultisample = e
        }
    }, SPRITE_MAX_TEXTURES: {
        get() {
            return Mt.defaultMaxTextures
        }, set(e) {
            Y("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), Mt.defaultMaxTextures = e
        }
    }, SPRITE_BATCH_SIZE: {
        get() {
            return Mt.defaultBatchSize
        }, set(e) {
            Y("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), Mt.defaultBatchSize = e
        }
    }, CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return Mt.canUploadSameBuffer
        }, set(e) {
            Y("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), Mt.canUploadSameBuffer = e
        }
    }, GC_MODE: {
        get() {
            return Bt.defaultMode
        }, set(e) {
            Y("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), Bt.defaultMode = e
        }
    }, GC_MAX_IDLE: {
        get() {
            return Bt.defaultMaxIdle
        }, set(e) {
            Y("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), Bt.defaultMaxIdle = e
        }
    }, GC_MAX_CHECK_COUNT: {
        get() {
            return Bt.defaultCheckCountMax
        }, set(e) {
            Y("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), Bt.defaultCheckCountMax = e
        }
    }, PRECISION_VERTEX: {
        get() {
            return Pt.defaultVertexPrecision
        }, set(e) {
            Y("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), Pt.defaultVertexPrecision = e
        }
    }, PRECISION_FRAGMENT: {
        get() {
            return Pt.defaultFragmentPrecision
        }, set(e) {
            Y("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), Pt.defaultFragmentPrecision = e
        }
    }
});
var ce = (e => (e[e.HIGH = 25] = "HIGH", e[e.NORMAL = 0] = "NORMAL", e[e.LOW = -25] = "LOW", e[e.UTILITY = -50] = "UTILITY", e))(ce || {});

class Hr {
    constructor(t, s = null, i = 0, r = !1) {
        this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = s, this.priority = i, this.once = r
    }

    match(t, s = null) {
        return this.fn === t && this.context === s
    }

    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const s = this.next;
        return this.once && this.destroy(!0), this._destroyed && (this.next = null), s
    }

    connect(t) {
        this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
    }

    destroy(t = !1) {
        this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        const s = this.next;
        return this.next = t ? null : s, this.previous = null, s
    }
}

const Rt = class {
    constructor() {
        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Hr(null, null, 1 / 0), this.deltaMS = 1 / Rt.targetFPMS, this.elapsedMS = 1 / Rt.targetFPMS, this._tick = e => {
            this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }

    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
    }

    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
    }

    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }

    add(e, t, s = ce.NORMAL) {
        return this._addListener(new Hr(e, t, s))
    }

    addOnce(e, t, s = ce.NORMAL) {
        return this._addListener(new Hr(e, t, s, !0))
    }

    _addListener(e) {
        let t = this._head.next, s = this._head;
        if (!t) e.connect(s); else {
            for (; t;) {
                if (e.priority > t.priority) {
                    e.connect(s);
                    break
                }
                s = t, t = t.next
            }
            e.previous || e.connect(s)
        }
        return this._startIfPossible(), this
    }

    remove(e, t) {
        let s = this._head.next;
        for (; s;) s.match(e, t) ? s = s.destroy() : s = s.next;
        return this._head.next || this._cancelIfNeeded(), this
    }

    get count() {
        if (!this._head) return 0;
        let e = 0, t = this._head;
        for (; t = t.next;) e++;
        return e
    }

    start() {
        this.started || (this.started = !0, this._requestIfNeeded())
    }

    stop() {
        this.started && (this.started = !1, this._cancelIfNeeded())
    }

    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;) e = e.destroy(!0);
            this._head.destroy(), this._head = null
        }
    }

    update(e = performance.now()) {
        let t;
        if (e > this.lastTime) {
            if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                const r = e - this._lastFrame | 0;
                if (r < this._minElapsedMS) return;
                this._lastFrame = e - r % this._minElapsedMS
            }
            this.deltaMS = t, this.deltaTime = this.deltaMS * Rt.targetFPMS;
            const s = this._head;
            let i = s.next;
            for (; i;) i = i.emit(this.deltaTime);
            s.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }

    get FPS() {
        return 1e3 / this.elapsedMS
    }

    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }

    set minFPS(e) {
        const t = Math.min(this.maxFPS, e), s = Math.min(Math.max(0, t) / 1e3, Rt.targetFPMS);
        this._maxElapsedMS = 1 / s
    }

    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }

    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0; else {
            const t = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (t / 1e3)
        }
    }

    static get shared() {
        if (!Rt._shared) {
            const e = Rt._shared = new Rt;
            e.autoStart = !0, e._protected = !0
        }
        return Rt._shared
    }

    static get system() {
        if (!Rt._system) {
            const e = Rt._system = new Rt;
            e.autoStart = !0, e._protected = !0
        }
        return Rt._system
    }
};
let ct = Rt;
ct.targetFPMS = .06, Object.defineProperties(M, {
    TARGET_FPMS: {
        get() {
            return ct.targetFPMS
        }, set(e) {
            Y("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), ct.targetFPMS = e
        }
    }
});

class Xr {
    static init(t) {
        t = Object.assign({autoStart: !0, sharedTicker: !1}, t), Object.defineProperty(this, "ticker", {
            set(s) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = s, s && s.add(this.render, this, ce.LOW)
            }, get() {
                return this._ticker
            }
        }), this.stop = () => {
            this._ticker.stop()
        }, this.start = () => {
            this._ticker.start()
        }, this._ticker = null, this.ticker = t.sharedTicker ? ct.shared : new ct, t.autoStart && this.start()
    }

    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null, t.destroy()
        }
    }
}

Xr.extension = I.Application, O.add(Xr);
const Zo = [];
O.handleByList(I.Renderer, Zo);

function Qo(e) {
    for (const t of Zo) if (t.test(e)) return new t(e);
    throw new Error("Unable to auto-detect a suitable renderer.")
}

var Yd = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, qd = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const Jo = Yd, Vr = qd;

class zr {
    constructor(t) {
        this.renderer = t
    }

    contextChange(t) {
        let s;
        if (this.renderer.context.webGLVersion === 1) {
            const i = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null), s = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, i)
        } else {
            const i = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), s = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, i)
        }
        s >= st.HIGH ? this.multisample = st.HIGH : s >= st.MEDIUM ? this.multisample = st.MEDIUM : s >= st.LOW ? this.multisample = st.LOW : this.multisample = st.NONE
    }

    destroy() {
    }
}

zr.extension = {type: I.RendererSystem, name: "_multisample"}, O.add(zr);

class Kd {
    constructor(t) {
        this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
    }
}

class Wr {
    constructor(t) {
        this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
    }

    destroy() {
        this.renderer = null
    }

    contextChange() {
        this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }

    bind(t) {
        const {gl: s, CONTEXT_UID: i} = this, r = t._glBuffers[i] || this.createGLBuffer(t);
        s.bindBuffer(t.type, r.buffer)
    }

    unbind(t) {
        const {gl: s} = this;
        s.bindBuffer(t, null)
    }

    bindBufferBase(t, s) {
        const {gl: i, CONTEXT_UID: r} = this;
        if (this.boundBufferBases[s] !== t) {
            const n = t._glBuffers[r] || this.createGLBuffer(t);
            this.boundBufferBases[s] = t, i.bindBufferBase(i.UNIFORM_BUFFER, s, n.buffer)
        }
    }

    bindBufferRange(t, s, i) {
        const {gl: r, CONTEXT_UID: n} = this;
        i = i || 0;
        const o = t._glBuffers[n] || this.createGLBuffer(t);
        r.bindBufferRange(r.UNIFORM_BUFFER, s || 0, o.buffer, i * 256, 256)
    }

    update(t) {
        const {gl: s, CONTEXT_UID: i} = this, r = t._glBuffers[i] || this.createGLBuffer(t);
        if (t._updateID !== r.updateID) if (r.updateID = t._updateID, s.bindBuffer(t.type, r.buffer), r.byteLength >= t.data.byteLength) s.bufferSubData(t.type, 0, t.data); else {
            const n = t.static ? s.STATIC_DRAW : s.DYNAMIC_DRAW;
            r.byteLength = t.data.byteLength, s.bufferData(t.type, t.data, n)
        }
    }

    dispose(t, s) {
        if (!this.managedBuffers[t.id]) return;
        delete this.managedBuffers[t.id];
        const i = t._glBuffers[this.CONTEXT_UID], r = this.gl;
        t.disposeRunner.remove(this), i && (s || r.deleteBuffer(i.buffer), delete t._glBuffers[this.CONTEXT_UID])
    }

    disposeAll(t) {
        const s = Object.keys(this.managedBuffers);
        for (let i = 0; i < s.length; i++) this.dispose(this.managedBuffers[s[i]], t)
    }

    createGLBuffer(t) {
        const {CONTEXT_UID: s, gl: i} = this;
        return t._glBuffers[s] = new Kd(i.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[s]
    }
}

Wr.extension = {type: I.RendererSystem, name: "buffer"}, O.add(Wr);

class jr {
    constructor(t) {
        this.renderer = t
    }

    render(t, s) {
        const i = this.renderer;
        let r, n, o, a;
        if (s && (r = s.renderTexture, n = s.clear, o = s.transform, a = s.skipUpdateTransform), this.renderingToScreen = !r, i.runners.prerender.emit(), i.emit("prerender"), i.projection.transform = o, !i.context.isLost) {
            if (r || (this.lastObjectRendered = t), !a) {
                const h = t.enableTempParent();
                t.updateTransform(), t.disableTempParent(h)
            }
            i.renderTexture.bind(r), i.batch.currentRenderer.start(), (n != null ? n : i.background.clearBeforeRender) && i.renderTexture.clear(), t.render(i), i.batch.currentRenderer.flush(), r && (s.blit && i.framebuffer.blit(), r.baseTexture.update()), i.runners.postrender.emit(), i.projection.transform = null, i.emit("postrender")
        }
    }

    destroy() {
        this.renderer = null, this.lastObjectRendered = null
    }
}

jr.extension = {type: I.RendererSystem, name: "objectRenderer"}, O.add(jr);
const $r = class extends Ko {
    constructor(e) {
        var i;
        super(), e = Object.assign({}, M.RENDER_OPTIONS, e), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new Ft({projectionMatrix: new Q}, !0);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: $r.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(t), "useContextAlpha" in e && (Y("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), e.premultipliedAlpha = e.useContextAlpha && e.useContextAlpha !== "notMultiplied", e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha);
        const s = {
            hello: e.hello,
            _plugin: $r.__plugins,
            background: {
                alpha: e.backgroundAlpha,
                color: (i = e.background) != null ? i : e.backgroundColor,
                clearBeforeRender: e.clearBeforeRender
            },
            _view: {
                height: e.height,
                width: e.width,
                autoDensity: e.autoDensity,
                resolution: e.resolution,
                view: e.view
            },
            context: {
                antialias: e.antialias,
                context: e.context,
                powerPreference: e.powerPreference,
                premultipliedAlpha: e.premultipliedAlpha,
                preserveDrawingBuffer: e.preserveDrawingBuffer
            }
        };
        this.options = e, this.startup.run(s)
    }

    static test(e) {
        return e != null && e.forceCanvas ? !1 : ro()
    }

    render(e, t) {
        this.objectRenderer.render(e, t)
    }

    resize(e, t) {
        this._view.resizeView(e, t)
    }

    reset() {
        return this.runners.reset.emit(), this
    }

    clear() {
        this.renderTexture.bind(), this.renderTexture.clear()
    }

    destroy(e = !1) {
        this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {_view: e}), super.destroy()
    }

    get plugins() {
        return this._plugin.plugins
    }

    get multisample() {
        return this._multisample.multisample
    }

    get width() {
        return this._view.element.width
    }

    get height() {
        return this._view.element.height
    }

    get resolution() {
        return this._view.resolution
    }

    set resolution(e) {
        this._view.resolution = e, this.runners.resolutionChange.emit(e)
    }

    get autoDensity() {
        return this._view.autoDensity
    }

    get view() {
        return this._view.element
    }

    get screen() {
        return this._view.screen
    }

    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }

    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }

    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }

    get clearBeforeRender() {
        return Y("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender
    }

    get useContextAlpha() {
        return Y("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha
    }

    get preserveDrawingBuffer() {
        return Y("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer
    }

    get backgroundColor() {
        return Y("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
    }

    set backgroundColor(e) {
        Y("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = e
    }

    get backgroundAlpha() {
        return Y("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.color
    }

    set backgroundAlpha(e) {
        Y("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = e
    }

    get powerPreference() {
        return Y("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference
    }

    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
};
let Re = $r;
Re.extension = {
    type: I.Renderer,
    priority: 1
}, Re.__plugins = {}, Re.__systems = {}, O.handleByMap(I.RendererPlugin, Re.__plugins), O.handleByMap(I.RendererSystem, Re.__systems), O.add(Re);

class Yr extends Le {
    constructor(t, s) {
        const {width: i, height: r} = s || {};
        super(i, r), this.items = [], this.itemDirtyIds = [];
        for (let n = 0; n < t; n++) {
            const o = new X;
            this.items.push(o), this.itemDirtyIds.push(-2)
        }
        this.length = t, this._load = null, this.baseTexture = null
    }

    initFromArray(t, s) {
        for (let i = 0; i < this.length; i++) !t[i] || (t[i].castToBaseTexture ? this.addBaseTextureAt(t[i].castToBaseTexture(), i) : t[i] instanceof Le ? this.addResourceAt(t[i], i) : this.addResourceAt(cr(t[i], s), i))
    }

    dispose() {
        for (let t = 0, s = this.length; t < s; t++) this.items[t].destroy();
        this.items = null, this.itemDirtyIds = null, this._load = null
    }

    addResourceAt(t, s) {
        if (!this.items[s]) throw new Error(`Index ${s} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height), this.items[s].setResource(t), this
    }

    bind(t) {
        if (this.baseTexture !== null) throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let s = 0; s < this.length; s++) this.items[s].parentTextureArray = t, this.items[s].on("update", t.update, t)
    }

    unbind(t) {
        super.unbind(t);
        for (let s = 0; s < this.length; s++) this.items[s].parentTextureArray = null, this.items[s].off("update", t.update, t)
    }

    load() {
        if (this._load) return this._load;
        const s = this.items.map(i => i.resource).filter(i => i).map(i => i.load());
        return this._load = Promise.all(s).then(() => {
            const {realWidth: i, realHeight: r} = this.items[0];
            return this.resize(i, r), Promise.resolve(this)
        }), this._load
    }
}

class ta extends Yr {
    constructor(t, s) {
        const {width: i, height: r} = s || {};
        let n, o;
        Array.isArray(t) ? (n = t, o = t.length) : o = t, super(o, {width: i, height: r}), n && this.initFromArray(n, s)
    }

    addBaseTextureAt(t, s) {
        if (t.resource) this.addResourceAt(t.resource, s); else throw new Error("ArrayResource does not support RenderTexture");
        return this
    }

    bind(t) {
        super.bind(t), t.target = _e.TEXTURE_2D_ARRAY
    }

    upload(t, s, i) {
        const {length: r, itemDirtyIds: n, items: o} = this, {gl: a} = t;
        i.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, i.internalFormat, this._width, this._height, r, 0, s.format, i.type, null);
        for (let h = 0; h < r; h++) {
            const l = o[h];
            n[h] < l.dirtyId && (n[h] = l.dirtyId, l.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, h, l.resource.width, l.resource.height, 1, s.format, i.type, l.resource.source))
        }
        return !0
    }
}

class ea extends se {
    constructor(t) {
        super(t)
    }

    static test(t) {
        const {OffscreenCanvas: s} = globalThis;
        return s && t instanceof s ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}

const hs = class extends Yr {
    constructor(e, t) {
        const {width: s, height: i, autoLoad: r, linkBaseTexture: n} = t || {};
        if (e && e.length !== hs.SIDES) throw new Error(`Invalid length. Got ${e.length}, expected 6`);
        super(6, {width: s, height: i});
        for (let o = 0; o < hs.SIDES; o++) this.items[o].target = _e.TEXTURE_CUBE_MAP_POSITIVE_X + o;
        this.linkBaseTexture = n !== !1, e && this.initFromArray(e, t), r !== !1 && this.load()
    }

    bind(e) {
        super.bind(e), e.target = _e.TEXTURE_CUBE_MAP
    }

    addBaseTextureAt(e, t, s) {
        if (s === void 0 && (s = this.linkBaseTexture), !this.items[t]) throw new Error(`Index ${t} is out of bounds`);
        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0) if (e.resource) this.addResourceAt(e.resource, t); else throw new Error("CubeResource does not support copying of renderTexture."); else e.target = _e.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.parentTextureArray = this.baseTexture, this.items[t] = e;
        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[t] = e, this
    }

    upload(e, t, s) {
        const i = this.itemDirtyIds;
        for (let r = 0; r < hs.SIDES; r++) {
            const n = this.items[r];
            (i[r] < n.dirtyId || s.dirtyId < t.dirtyId) && (n.valid && n.resource ? (n.resource.upload(e, n, s), i[r] = n.dirtyId) : i[r] < -1 && (e.gl.texImage2D(n.target, 0, s.internalFormat, t.realWidth, t.realHeight, 0, t.format, s.type, null), i[r] = -1))
        }
        return !0
    }

    static test(e) {
        return Array.isArray(e) && e.length === hs.SIDES
    }
};
let qr = hs;
qr.SIDES = 6;

class Me extends se {
    constructor(t, s) {
        var n;
        s = s || {};
        let i, r;
        typeof t == "string" ? (i = Me.EMPTY, r = t) : (i = t, r = null), super(i), this.url = r, this.crossOrigin = (n = s.crossOrigin) != null ? n : !0, this.alphaMode = typeof s.alphaMode == "number" ? s.alphaMode : null, this._load = null, s.autoLoad !== !1 && this.load()
    }

    load() {
        return this._load ? this._load : (this._load = new Promise(async (t, s) => {
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const i = await M.ADAPTER.fetch(this.url, {mode: this.crossOrigin ? "cors" : "no-cors"});
                if (this.destroyed) return;
                const r = await i.blob();
                if (this.destroyed) return;
                const n = await createImageBitmap(r, {premultiplyAlpha: this.alphaMode === null || this.alphaMode === Ct.UNPACK ? "premultiply" : "none"});
                if (this.destroyed) return;
                this.source = n, this.update(), t(this)
            } catch (i) {
                if (this.destroyed) return;
                s(i), this.onError.emit(i)
            }
        }), this._load)
    }

    upload(t, s, i) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (s.alphaMode = this.alphaMode), super.upload(t, s, i)) : (this.load(), !1)
    }

    dispose() {
        this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null
    }

    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap != "undefined" && (typeof t == "string" || t instanceof ImageBitmap)
    }

    static get EMPTY() {
        var t;
        return Me._EMPTY = (t = Me._EMPTY) != null ? t : M.ADAPTER.createCanvas(0, 0), Me._EMPTY
    }
}

const hi = class extends se {
    constructor(e, t) {
        t = t || {}, super(M.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = e, this.scale = t.scale || 1, this._overrideWidth = t.width, this._overrideHeight = t.height, this._resolve = null, this._crossorigin = t.crossorigin, this._load = null, t.autoLoad !== !1 && this.load()
    }

    load() {
        return this._load ? this._load : (this._load = new Promise(e => {
            if (this._resolve = () => {
                this.resize(this.source.width, this.source.height), e(this)
            }, hi.SVG_XML.test(this.svg.trim())) {
                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }), this._load)
    }

    _loadSvg() {
        const e = new Image;
        se.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = t => {
            !this._resolve || (e.onerror = null, this.onError.emit(t))
        }, e.onload = () => {
            if (!this._resolve) return;
            const t = e.width, s = e.height;
            if (!t || !s) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let i = t * this.scale, r = s * this.scale;
            (this._overrideWidth || this._overrideHeight) && (i = this._overrideWidth || this._overrideHeight / s * t, r = this._overrideHeight || this._overrideWidth / t * s), i = Math.round(i), r = Math.round(r);
            const n = this.source;
            n.width = i, n.height = r, n._pixiId = `canvas_${le()}`, n.getContext("2d").drawImage(e, 0, 0, t, s, 0, 0, i, r), this._resolve(), this._resolve = null
        }
    }

    static getSize(e) {
        const t = hi.SVG_SIZE.exec(e), s = {};
        return t && (s[t[1]] = Math.round(parseFloat(t[3])), s[t[5]] = Math.round(parseFloat(t[7]))), s
    }

    dispose() {
        super.dispose(), this._resolve = null, this._crossorigin = null
    }

    static test(e, t) {
        return t === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && hi.SVG_XML.test(e)
    }
};
let He = hi;
He.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, He.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const Kr = class extends se {
    constructor(e, t) {
        if (t = t || {}, !(e instanceof HTMLVideoElement)) {
            const s = document.createElement("video");
            s.setAttribute("preload", "auto"), s.setAttribute("webkit-playsinline", ""), s.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
            const i = e[0].src || e[0];
            se.crossOrigin(s, i, t.crossorigin);
            for (let r = 0; r < e.length; ++r) {
                const n = document.createElement("source");
                let {src: o, mime: a} = e[r];
                o = o || e[r];
                const h = o.split("?").shift().toLowerCase(), l = h.slice(h.lastIndexOf(".") + 1);
                a = a || Kr.MIME_TYPES[l] || `video/${l}`, n.src = o, n.type = a, s.appendChild(n)
            }
            e = s
        }
        super(e), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), t.autoLoad !== !1 && this.load()
    }

    update(e = 0) {
        if (!this.destroyed) {
            const t = ct.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }

    load() {
        if (this._load) return this._load;
        const e = this.source;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise(t => {
            this.valid ? t(this) : (this._resolve = t, e.load())
        }), this._load
    }

    _onError(e) {
        this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e)
    }

    _isSourcePlaying() {
        const e = this.source;
        return !e.paused && !e.ended && this._isSourceReady()
    }

    _isSourceReady() {
        return this.source.readyState > 2
    }

    _onPlayStart() {
        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (ct.shared.add(this.update, this), this._isConnectedToTicker = !0)
    }

    _onPlayStop() {
        this._isConnectedToTicker && (ct.shared.remove(this.update, this), this._isConnectedToTicker = !1)
    }

    _onCanPlay() {
        const e = this.source;
        e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
        const t = this.valid;
        this.resize(e.videoWidth, e.videoHeight), !t && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
    }

    dispose() {
        this._isConnectedToTicker && (ct.shared.remove(this.update, this), this._isConnectedToTicker = !1);
        const e = this.source;
        e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.dispose()
    }

    get autoUpdate() {
        return this._autoUpdate
    }

    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (ct.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (ct.shared.add(this.update, this), this._isConnectedToTicker = !0))
    }

    get updateFPS() {
        return this._updateFPS
    }

    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e)
    }

    static test(e, t) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || Kr.TYPES.includes(t)
    }
};
let li = Kr;
li.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], li.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
}, js.push(Me, xr, ea, li, He, Oe, qr, ta);

class Zd {
    constructor() {
        this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new St("disposeTransformFeedback")
    }

    bindBuffer(t, s) {
        this.buffers[t] = s
    }

    destroy() {
        this.disposeRunner.emit(this, !1)
    }
}

const Qd = "7.1.2";

class ls {
    constructor() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
    }

    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }

    clear() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
    }

    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? z.EMPTY : (t = t || new z(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
    }

    addPoint(t) {
        this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
    }

    addPointMatrix(t, s) {
        const {a: i, b: r, c: n, d: o, tx: a, ty: h} = t, l = i * s.x + n * s.y + a, c = r * s.x + o * s.y + h;
        this.minX = Math.min(this.minX, l), this.maxX = Math.max(this.maxX, l), this.minY = Math.min(this.minY, c), this.maxY = Math.max(this.maxY, c)
    }

    addQuad(t) {
        let s = this.minX, i = this.minY, r = this.maxX, n = this.maxY, o = t[0], a = t[1];
        s = o < s ? o : s, i = a < i ? a : i, r = o > r ? o : r, n = a > n ? a : n, o = t[2], a = t[3], s = o < s ? o : s, i = a < i ? a : i, r = o > r ? o : r, n = a > n ? a : n, o = t[4], a = t[5], s = o < s ? o : s, i = a < i ? a : i, r = o > r ? o : r, n = a > n ? a : n, o = t[6], a = t[7], s = o < s ? o : s, i = a < i ? a : i, r = o > r ? o : r, n = a > n ? a : n, this.minX = s, this.minY = i, this.maxX = r, this.maxY = n
    }

    addFrame(t, s, i, r, n) {
        this.addFrameMatrix(t.worldTransform, s, i, r, n)
    }

    addFrameMatrix(t, s, i, r, n) {
        const o = t.a, a = t.b, h = t.c, l = t.d, c = t.tx, u = t.ty;
        let d = this.minX, f = this.minY, p = this.maxX, _ = this.maxY, m = o * s + h * i + c, x = a * s + l * i + u;
        d = m < d ? m : d, f = x < f ? x : f, p = m > p ? m : p, _ = x > _ ? x : _, m = o * r + h * i + c, x = a * r + l * i + u, d = m < d ? m : d, f = x < f ? x : f, p = m > p ? m : p, _ = x > _ ? x : _, m = o * s + h * n + c, x = a * s + l * n + u, d = m < d ? m : d, f = x < f ? x : f, p = m > p ? m : p, _ = x > _ ? x : _, m = o * r + h * n + c, x = a * r + l * n + u, d = m < d ? m : d, f = x < f ? x : f, p = m > p ? m : p, _ = x > _ ? x : _, this.minX = d, this.minY = f, this.maxX = p, this.maxY = _
    }

    addVertexData(t, s, i) {
        let r = this.minX, n = this.minY, o = this.maxX, a = this.maxY;
        for (let h = s; h < i; h += 2) {
            const l = t[h], c = t[h + 1];
            r = l < r ? l : r, n = c < n ? c : n, o = l > o ? l : o, a = c > a ? c : a
        }
        this.minX = r, this.minY = n, this.maxX = o, this.maxY = a
    }

    addVertices(t, s, i, r) {
        this.addVerticesMatrix(t.worldTransform, s, i, r)
    }

    addVerticesMatrix(t, s, i, r, n = 0, o = n) {
        const a = t.a, h = t.b, l = t.c, c = t.d, u = t.tx, d = t.ty;
        let f = this.minX, p = this.minY, _ = this.maxX, m = this.maxY;
        for (let x = i; x < r; x += 2) {
            const y = s[x], g = s[x + 1], v = a * y + l * g + u, A = c * g + h * y + d;
            f = Math.min(f, v - n), _ = Math.max(_, v + n), p = Math.min(p, A - o), m = Math.max(m, A + o)
        }
        this.minX = f, this.minY = p, this.maxX = _, this.maxY = m
    }

    addBounds(t) {
        const s = this.minX, i = this.minY, r = this.maxX, n = this.maxY;
        this.minX = t.minX < s ? t.minX : s, this.minY = t.minY < i ? t.minY : i, this.maxX = t.maxX > r ? t.maxX : r, this.maxY = t.maxY > n ? t.maxY : n
    }

    addBoundsMask(t, s) {
        const i = t.minX > s.minX ? t.minX : s.minX, r = t.minY > s.minY ? t.minY : s.minY,
            n = t.maxX < s.maxX ? t.maxX : s.maxX, o = t.maxY < s.maxY ? t.maxY : s.maxY;
        if (i <= n && r <= o) {
            const a = this.minX, h = this.minY, l = this.maxX, c = this.maxY;
            this.minX = i < a ? i : a, this.minY = r < h ? r : h, this.maxX = n > l ? n : l, this.maxY = o > c ? o : c
        }
    }

    addBoundsMatrix(t, s) {
        this.addFrameMatrix(s, t.minX, t.minY, t.maxX, t.maxY)
    }

    addBoundsArea(t, s) {
        const i = t.minX > s.x ? t.minX : s.x, r = t.minY > s.y ? t.minY : s.y,
            n = t.maxX < s.x + s.width ? t.maxX : s.x + s.width, o = t.maxY < s.y + s.height ? t.maxY : s.y + s.height;
        if (i <= n && r <= o) {
            const a = this.minX, h = this.minY, l = this.maxX, c = this.maxY;
            this.minX = i < a ? i : a, this.minY = r < h ? r : h, this.maxX = n > l ? n : l, this.maxY = o > c ? o : c
        }
    }

    pad(t = 0, s = t) {
        this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= s, this.maxY += s)
    }

    addFramePad(t, s, i, r, n, o) {
        t -= n, s -= o, i += n, r += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < s ? this.minY : s, this.maxY = this.maxY > r ? this.maxY : r
    }
}

class et extends De {
    constructor() {
        super(), this.tempDisplayObjectParent = null, this.transform = new is, this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new ls, this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
    }

    static mixin(t) {
        const s = Object.keys(t);
        for (let i = 0; i < s.length; ++i) {
            const r = s[i];
            Object.defineProperty(et.prototype, r, Object.getOwnPropertyDescriptor(t, r))
        }
    }

    get destroyed() {
        return this._destroyed
    }

    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }

    updateTransform() {
        this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
    }

    getBounds(t, s) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), s || (this._boundsRect || (this._boundsRect = new z), s = this._boundsRect), this._bounds.getRectangle(s)
    }

    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new z), t = this._localBoundsRect), this._localBounds || (this._localBounds = new ls);
        const s = this.transform, i = this.parent;
        this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
        const r = this._bounds, n = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = i, this.transform = s, this._bounds = r, this._bounds.updateID += this._boundsID - n, o
    }

    toGlobal(t, s, i = !1) {
        return i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, s)
    }

    toLocal(t, s, i, r) {
        return s && (t = s.toGlobal(t, i, r)), r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, i)
    }

    setParent(t) {
        if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
        return t.addChild(this), t
    }

    removeFromParent() {
        var t;
        (t = this.parent) == null || t.removeChild(this)
    }

    setTransform(t = 0, s = 0, i = 1, r = 1, n = 0, o = 0, a = 0, h = 0, l = 0) {
        return this.position.x = t, this.position.y = s, this.scale.x = i || 1, this.scale.y = r || 1, this.rotation = n, this.skew.x = o, this.skew.y = a, this.pivot.x = h, this.pivot.y = l, this
    }

    destroy(t) {
        this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners()
    }

    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new sa), this.tempDisplayObjectParent
    }

    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent, t
    }

    disableTempParent(t) {
        this.parent = t
    }

    get x() {
        return this.position.x
    }

    set x(t) {
        this.transform.position.x = t
    }

    get y() {
        return this.position.y
    }

    set y(t) {
        this.transform.position.y = t
    }

    get worldTransform() {
        return this.transform.worldTransform
    }

    get localTransform() {
        return this.transform.localTransform
    }

    get position() {
        return this.transform.position
    }

    set position(t) {
        this.transform.position.copyFrom(t)
    }

    get scale() {
        return this.transform.scale
    }

    set scale(t) {
        this.transform.scale.copyFrom(t)
    }

    get pivot() {
        return this.transform.pivot
    }

    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }

    get skew() {
        return this.transform.skew
    }

    set skew(t) {
        this.transform.skew.copyFrom(t)
    }

    get rotation() {
        return this.transform.rotation
    }

    set rotation(t) {
        this.transform.rotation = t
    }

    get angle() {
        return this.transform.rotation * xo
    }

    set angle(t) {
        this.transform.rotation = t * vo
    }

    get zIndex() {
        return this._zIndex
    }

    set zIndex(t) {
        this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
    }

    get worldVisible() {
        let t = this;
        do {
            if (!t.visible) return !1;
            t = t.parent
        } while (t);
        return !0
    }

    get mask() {
        return this._mask
    }

    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const s = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                s && (s._maskRefCount--, s._maskRefCount === 0 && (s.renderable = !0, s.isMask = !1))
            }
            if (this._mask = t, this._mask) {
                const s = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                s && (s._maskRefCount === 0 && (s.renderable = !1, s.isMask = !0), s._maskRefCount++)
            }
        }
    }
}

class sa extends et {
    constructor() {
        super(...arguments), this.sortDirty = null
    }
}

et.prototype.displayObjectUpdateTransform = et.prototype.updateTransform;
const Jd = new Q;

function tf(e, t) {
    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
}

const Zr = class extends et {
    constructor() {
        super(), this.children = [], this.sortableChildren = Zr.defaultSortableChildren, this.sortDirty = !1
    }

    onChildrenChange(e) {
    }

    addChild(...e) {
        if (e.length > 1) for (let t = 0; t < e.length; t++) this.addChild(e[t]); else {
            const t = e[0];
            t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this)
        }
        return e[0]
    }

    addChildAt(e, t) {
        if (t < 0 || t > this.children.length) throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
        return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(t, 0, e), this._boundsID++, this.onChildrenChange(t), e.emit("added", this), this.emit("childAdded", e, this, t), e
    }

    swapChildren(e, t) {
        if (e === t) return;
        const s = this.getChildIndex(e), i = this.getChildIndex(t);
        this.children[s] = t, this.children[i] = e, this.onChildrenChange(s < i ? s : i)
    }

    getChildIndex(e) {
        const t = this.children.indexOf(e);
        if (t === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
        return t
    }

    setChildIndex(e, t) {
        if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
        const s = this.getChildIndex(e);
        ve(this.children, s, 1), this.children.splice(t, 0, e), this.onChildrenChange(t)
    }

    getChildAt(e) {
        if (e < 0 || e >= this.children.length) throw new Error(`getChildAt: Index (${e}) does not exist.`);
        return this.children[e]
    }

    removeChild(...e) {
        if (e.length > 1) for (let t = 0; t < e.length; t++) this.removeChild(e[t]); else {
            const t = e[0], s = this.children.indexOf(t);
            if (s === -1) return null;
            t.parent = null, t.transform._parentID = -1, ve(this.children, s, 1), this._boundsID++, this.onChildrenChange(s), t.emit("removed", this), this.emit("childRemoved", t, this, s)
        }
        return e[0]
    }

    removeChildAt(e) {
        const t = this.getChildAt(e);
        return t.parent = null, t.transform._parentID = -1, ve(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), t.emit("removed", this), this.emit("childRemoved", t, this, e), t
    }

    removeChildren(e = 0, t = this.children.length) {
        const s = e, i = t, r = i - s;
        let n;
        if (r > 0 && r <= i) {
            n = this.children.splice(s, r);
            for (let o = 0; o < n.length; ++o) n[o].parent = null, n[o].transform && (n[o].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(e);
            for (let o = 0; o < n.length; ++o) n[o].emit("removed", this), this.emit("childRemoved", n[o], this, o);
            return n
        } else if (r === 0 && this.children.length === 0) return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }

    sortChildren() {
        let e = !1;
        for (let t = 0, s = this.children.length; t < s; ++t) {
            const i = this.children[t];
            i._lastSortedIndex = t, !e && i.zIndex !== 0 && (e = !0)
        }
        e && this.children.length > 1 && this.children.sort(tf), this.sortDirty = !1
    }

    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let e = 0, t = this.children.length; e < t; ++e) {
            const s = this.children[e];
            s.visible && s.updateTransform()
        }
    }

    calculateBounds() {
        this._bounds.clear(), this._calculateBounds();
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            if (!(!t.visible || !t.renderable)) if (t.calculateBounds(), t._mask) {
                const s = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                s ? (s.calculateBounds(), this._bounds.addBoundsMask(t._bounds, s._bounds)) : this._bounds.addBounds(t._bounds)
            } else t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds)
        }
        this._bounds.updateID = this._boundsID
    }

    getLocalBounds(e, t = !1) {
        const s = super.getLocalBounds(e);
        if (!t) for (let i = 0, r = this.children.length; i < r; ++i) {
            const n = this.children[i];
            n.visible && n.updateTransform()
        }
        return s
    }

    _calculateBounds() {
    }

    _renderWithCulling(e) {
        const t = e.renderTexture.sourceFrame;
        if (!(t.width > 0 && t.height > 0)) return;
        let s, i;
        this.cullArea ? (s = this.cullArea, i = this.worldTransform) : this._render !== Zr.prototype._render && (s = this.getBounds(!0));
        const r = e.projection.transform;
        if (r && (i ? (i = Jd.copyFrom(i), i.prepend(r)) : i = r), s && t.intersects(s, i)) this._render(e); else if (this.cullArea) return;
        for (let n = 0, o = this.children.length; n < o; ++n) {
            const a = this.children[n], h = a.cullable;
            a.cullable = h || !this.cullArea, a.render(e), a.cullable = h
        }
    }

    render(e) {
        var t;
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable)) if (this._mask || ((t = this.filters) == null ? void 0 : t.length)) this.renderAdvanced(e); else if (this.cullable) this._renderWithCulling(e); else {
            this._render(e);
            for (let s = 0, i = this.children.length; s < i; ++s) this.children[s].render(e)
        }
    }

    renderAdvanced(e) {
        var r, n, o;
        const t = this.filters, s = this._mask;
        if (t) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (let a = 0; a < t.length; a++) t[a].enabled && this._enabledFilters.push(t[a])
        }
        const i = t && ((r = this._enabledFilters) == null ? void 0 : r.length) || s && (!s.isMaskData || s.enabled && (s.autoDetect || s.type !== ht.NONE));
        if (i && e.batch.flush(), t && ((n = this._enabledFilters) == null ? void 0 : n.length) && e.filter.push(this, this._enabledFilters), s && e.mask.push(this, this._mask), this.cullable) this._renderWithCulling(e); else {
            this._render(e);
            for (let a = 0, h = this.children.length; a < h; ++a) this.children[a].render(e)
        }
        i && e.batch.flush(), s && e.mask.pop(this), t && ((o = this._enabledFilters) == null ? void 0 : o.length) && e.filter.pop()
    }

    _render(e) {
    }

    destroy(e) {
        super.destroy(), this.sortDirty = !1;
        const t = typeof e == "boolean" ? e : e == null ? void 0 : e.children,
            s = this.removeChildren(0, this.children.length);
        if (t) for (let i = 0; i < s.length; ++i) s[i].destroy(e)
    }

    get width() {
        return this.scale.x * this.getLocalBounds().width
    }

    set width(e) {
        const t = this.getLocalBounds().width;
        t !== 0 ? this.scale.x = e / t : this.scale.x = 1, this._width = e
    }

    get height() {
        return this.scale.y * this.getLocalBounds().height
    }

    set height(e) {
        const t = this.getLocalBounds().height;
        t !== 0 ? this.scale.y = e / t : this.scale.y = 1, this._height = e
    }
};
let bt = Zr;
bt.defaultSortableChildren = !1, bt.prototype.containerUpdateTransform = bt.prototype.updateTransform, Object.defineProperties(M, {
    SORTABLE_CHILDREN: {
        get() {
            return bt.defaultSortableChildren
        }, set(e) {
            Y("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), bt.defaultSortableChildren = e
        }
    }
});
const cs = new j, ef = new Uint16Array([0, 1, 2, 0, 2, 3]);

class pe extends bt {
    constructor(t) {
        super(), this._anchor = new ne(this._onAnchorUpdate, this, t ? t.defaultAnchor.x : 0, t ? t.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = k.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = t || B.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = ef, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = M.ROUND_PIXELS
    }

    _onTextureUpdate() {
        this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = ye(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = ye(this.scale.y) * this._height / this._texture.orig.height)
    }

    _onAnchorUpdate() {
        this._transformID = -1, this._transformTrimmedID = -1
    }

    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID) return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
        const s = this.transform.worldTransform, i = s.a, r = s.b, n = s.c, o = s.d, a = s.tx, h = s.ty,
            l = this.vertexData, c = t.trim, u = t.orig, d = this._anchor;
        let f = 0, p = 0, _ = 0, m = 0;
        if (c ? (p = c.x - d._x * u.width, f = p + c.width, m = c.y - d._y * u.height, _ = m + c.height) : (p = -d._x * u.width, f = p + u.width, m = -d._y * u.height, _ = m + u.height), l[0] = i * p + n * m + a, l[1] = o * m + r * p + h, l[2] = i * f + n * m + a, l[3] = o * m + r * f + h, l[4] = i * f + n * _ + a, l[5] = o * _ + r * f + h, l[6] = i * p + n * _ + a, l[7] = o * _ + r * p + h, this._roundPixels) {
            const x = M.RESOLUTION;
            for (let y = 0; y < l.length; ++y) l[y] = Math.round(l[y] * x) / x
        }
    }

    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8); else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
        this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
        const t = this._texture, s = this.vertexTrimmedData, i = t.orig, r = this._anchor,
            n = this.transform.worldTransform, o = n.a, a = n.b, h = n.c, l = n.d, c = n.tx, u = n.ty,
            d = -r._x * i.width, f = d + i.width, p = -r._y * i.height, _ = p + i.height;
        s[0] = o * d + h * p + c, s[1] = l * p + a * d + u, s[2] = o * f + h * p + c, s[3] = l * p + a * f + u, s[4] = o * f + h * _ + c, s[5] = l * _ + a * f + u, s[6] = o * d + h * _ + c, s[7] = l * _ + a * d + u
    }

    _render(t) {
        this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
    }

    _calculateBounds() {
        const t = this._texture.trim, s = this._texture.orig;
        !t || t.width === s.width && t.height === s.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
    }

    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new ls), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new z), t = this._localBoundsRect), this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }

    containsPoint(t) {
        this.worldTransform.applyInverse(t, cs);
        const s = this._texture.orig.width, i = this._texture.orig.height, r = -s * this.anchor.x;
        let n = 0;
        return cs.x >= r && cs.x < r + s && (n = -i * this.anchor.y, cs.y >= n && cs.y < n + i)
    }

    destroy(t) {
        if (super.destroy(t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof t == "boolean" ? t : t == null ? void 0 : t.texture) {
            const i = typeof t == "boolean" ? t : t == null ? void 0 : t.baseTexture;
            this._texture.destroy(!!i)
        }
        this._texture = null
    }

    static from(t, s) {
        const i = t instanceof B ? t : B.from(t, s);
        return new pe(i)
    }

    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
    }

    get roundPixels() {
        return this._roundPixels
    }

    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }

    set width(t) {
        const s = ye(this.scale.x) || 1;
        this.scale.x = s * t / this._texture.orig.width, this._width = t
    }

    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }

    set height(t) {
        const s = ye(this.scale.y) || 1;
        this.scale.y = s * t / this._texture.orig.height, this._height = t
    }

    get anchor() {
        return this._anchor
    }

    set anchor(t) {
        this._anchor.copyFrom(t)
    }

    get tint() {
        return this._tint
    }

    set tint(t) {
        this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }

    get texture() {
        return this._texture
    }

    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || B.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}

const ia = new Q;
et.prototype._cacheAsBitmap = !1, et.prototype._cacheData = null, et.prototype._cacheAsBitmapResolution = null, et.prototype._cacheAsBitmapMultisample = null;

class sf {
    constructor() {
        this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
    }
}

Object.defineProperties(et.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        }, set(e) {
            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    }, cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        }, set(e) {
            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    }, cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        }, set(e) {
            if (this._cacheAsBitmap === e) return;
            this._cacheAsBitmap = e;
            let t;
            e ? (this._cacheData || (this._cacheData = new sf), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea)
        }
    }
}), et.prototype._renderCached = function (t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
}, et.prototype._initCachedDisplayObject = function (t) {
    var d, f, p;
    if ((d = this._cacheData) != null && d.sprite) return;
    const s = this.alpha;
    this.alpha = 1, t.batch.flush();
    const i = this.getLocalBounds(null, !0).clone();
    if ((f = this.filters) != null && f.length) {
        const _ = this.filters[0].padding;
        i.pad(_)
    }
    i.ceil(M.RESOLUTION);
    const r = t.renderTexture.current, n = t.renderTexture.sourceFrame.clone(),
        o = t.renderTexture.destinationFrame.clone(), a = t.projection.transform, h = oe.create({
            width: i.width,
            height: i.height,
            resolution: this.cacheAsBitmapResolution || t.resolution,
            multisample: (p = this.cacheAsBitmapMultisample) != null ? p : t.multisample
        }), l = `cacheAsBitmap_${le()}`;
    this._cacheData.textureCacheId = l, X.addToCache(h.baseTexture, l), B.addToCache(h, l);
    const c = this.transform.localTransform.copyTo(ia).invert().translate(-i.x, -i.y);
    this.render = this._cacheData.originalRender, t.render(this, {
        renderTexture: h,
        clear: !0,
        transform: c,
        skipUpdateTransform: !1
    }), t.framebuffer.blit(), t.projection.transform = a, t.renderTexture.bind(r, n, o), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = s;
    const u = new pe(h);
    u.transform.worldTransform = this.transform.worldTransform, u.anchor.x = -(i.x / i.width), u.anchor.y = -(i.y / i.height), u.alpha = s, u._bounds = this._bounds, this._cacheData.sprite = u, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = u.containsPoint.bind(u)
}, et.prototype._renderCachedCanvas = function (t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
}, et.prototype._initCachedDisplayObjectCanvas = function (t) {
    var c;
    if ((c = this._cacheData) != null && c.sprite) return;
    const s = this.getLocalBounds(null, !0), i = this.alpha;
    this.alpha = 1;
    const r = t.canvasContext.activeContext, n = t._projTransform;
    s.ceil(M.RESOLUTION);
    const o = oe.create({width: s.width, height: s.height}), a = `cacheAsBitmap_${le()}`;
    this._cacheData.textureCacheId = a, X.addToCache(o.baseTexture, a), B.addToCache(o, a);
    const h = ia;
    this.transform.localTransform.copyTo(h), h.invert(), h.tx -= s.x, h.ty -= s.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
        renderTexture: o,
        clear: !0,
        transform: h,
        skipUpdateTransform: !1
    }), t.canvasContext.activeContext = r, t._projTransform = n, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    const l = new pe(o);
    l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -(s.x / s.width), l.anchor.y = -(s.y / s.height), l.alpha = i, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l)
}, et.prototype._calculateCachedBounds = function () {
    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
}, et.prototype._getCachedLocalBounds = function () {
    return this._cacheData.sprite.getLocalBounds(null)
}, et.prototype._destroyCachedDisplayObject = function () {
    this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, X.removeFromCache(this._cacheData.textureCacheId), B.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
}, et.prototype._cacheAsBitmapDestroy = function (t) {
    this.cacheAsBitmap = !1, this.destroy(t)
}, et.prototype.name = null, bt.prototype.getChildByName = function (t, s) {
    for (let i = 0, r = this.children.length; i < r; i++) if (this.children[i].name === t) return this.children[i];
    if (s) for (let i = 0, r = this.children.length; i < r; i++) {
        const n = this.children[i];
        if (!n.getChildByName) continue;
        const o = n.getChildByName(t, !0);
        if (o) return o
    }
    return null
}, et.prototype.getGlobalPosition = function (t = new j, s = !1) {
    return this.parent ? this.parent.toGlobal(this.position, t, s) : (t.x = this.position.x, t.y = this.position.y), t
};
var rf = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;

class ra extends mt {
    constructor(t = 1) {
        super(Jo, rf, {uAlpha: 1}), this.alpha = t
    }

    get alpha() {
        return this.uniforms.uAlpha
    }

    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}

const nf = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    },
    of = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

function af(e) {
    const t = nf[e], s = t.length;
    let i = of, r = "";
    const n = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < e; a++) {
        let h = n.replace("%index%", a.toString());
        o = a, a >= s && (o = e - a - 1), h = h.replace("%value%", t[o].toString()), r += h, r += `
`
    }
    return i = i.replace("%blur%", r), i = i.replace("%size%", e.toString()), i
}

const hf = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

function lf(e, t) {
    const s = Math.ceil(e / 2);
    let i = hf, r = "", n;
    t ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < e; o++) {
        let a = n.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o - (s - 1)}.0`), r += a, r += `
`
    }
    return i = i.replace("%blur%", r), i = i.replace("%size%", e.toString()), i
}

class ci extends mt {
    constructor(t, s = 8, i = 4, r = mt.defaultResolution, n = 5) {
        const o = lf(n, t), a = af(n);
        super(o, a), this.horizontal = t, this.resolution = r, this._quality = 0, this.quality = i, this.blur = s
    }

    apply(t, s, i, r) {
        if (i ? this.horizontal ? this.uniforms.strength = 1 / i.width * (i.width / s.width) : this.uniforms.strength = 1 / i.height * (i.height / s.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / s.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / s.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1) t.applyFilter(this, s, i, r); else {
            const n = t.getFilterTexture(), o = t.renderer;
            let a = s, h = n;
            this.state.blend = !1, t.applyFilter(this, a, h, Ot.CLEAR);
            for (let l = 1; l < this.passes - 1; l++) {
                t.bindAndClear(a, Ot.BLIT), this.uniforms.uSampler = h;
                const c = h;
                h = a, a = c, o.shader.bind(this), o.geometry.draw(5)
            }
            this.state.blend = !0, t.applyFilter(this, h, i, r), t.returnFilterTexture(n)
        }
    }

    get blur() {
        return this.strength
    }

    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2, this.strength = t
    }

    get quality() {
        return this._quality
    }

    set quality(t) {
        this._quality = t, this.passes = t
    }
}

class na extends mt {
    constructor(t = 8, s = 4, i = mt.defaultResolution, r = 5) {
        super(), this.blurXFilter = new ci(!0, t, s, i, r), this.blurYFilter = new ci(!1, t, s, i, r), this.resolution = i, this.quality = s, this.blur = t, this.repeatEdgePixels = !1
    }

    apply(t, s, i, r) {
        const n = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);
        if (n && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, s, a, Ot.CLEAR), this.blurYFilter.apply(t, a, i, r), t.returnFilterTexture(a)
        } else o ? this.blurYFilter.apply(t, s, i, r) : this.blurXFilter.apply(t, s, i, r)
    }

    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }

    get blur() {
        return this.blurXFilter.blur
    }

    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
    }

    get quality() {
        return this.blurXFilter.quality
    }

    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }

    get blurX() {
        return this.blurXFilter.blur
    }

    set blurX(t) {
        this.blurXFilter.blur = t, this.updatePadding()
    }

    get blurY() {
        return this.blurYFilter.blur
    }

    set blurY(t) {
        this.blurYFilter.blur = t, this.updatePadding()
    }

    get blendMode() {
        return this.blurYFilter.blendMode
    }

    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }

    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }

    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t, this.updatePadding()
    }
}

var cf = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;

class ui extends mt {
    constructor() {
        const t = {m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1};
        super(Vr, cf, t), this.alpha = 1
    }

    _loadMatrix(t, s = !1) {
        let i = t;
        s && (this._multiply(i, this.uniforms.m, t), i = this._colorMatrix(i)), this.uniforms.m = i
    }

    _multiply(t, s, i) {
        return t[0] = s[0] * i[0] + s[1] * i[5] + s[2] * i[10] + s[3] * i[15], t[1] = s[0] * i[1] + s[1] * i[6] + s[2] * i[11] + s[3] * i[16], t[2] = s[0] * i[2] + s[1] * i[7] + s[2] * i[12] + s[3] * i[17], t[3] = s[0] * i[3] + s[1] * i[8] + s[2] * i[13] + s[3] * i[18], t[4] = s[0] * i[4] + s[1] * i[9] + s[2] * i[14] + s[3] * i[19] + s[4], t[5] = s[5] * i[0] + s[6] * i[5] + s[7] * i[10] + s[8] * i[15], t[6] = s[5] * i[1] + s[6] * i[6] + s[7] * i[11] + s[8] * i[16], t[7] = s[5] * i[2] + s[6] * i[7] + s[7] * i[12] + s[8] * i[17], t[8] = s[5] * i[3] + s[6] * i[8] + s[7] * i[13] + s[8] * i[18], t[9] = s[5] * i[4] + s[6] * i[9] + s[7] * i[14] + s[8] * i[19] + s[9], t[10] = s[10] * i[0] + s[11] * i[5] + s[12] * i[10] + s[13] * i[15], t[11] = s[10] * i[1] + s[11] * i[6] + s[12] * i[11] + s[13] * i[16], t[12] = s[10] * i[2] + s[11] * i[7] + s[12] * i[12] + s[13] * i[17], t[13] = s[10] * i[3] + s[11] * i[8] + s[12] * i[13] + s[13] * i[18], t[14] = s[10] * i[4] + s[11] * i[9] + s[12] * i[14] + s[13] * i[19] + s[14], t[15] = s[15] * i[0] + s[16] * i[5] + s[17] * i[10] + s[18] * i[15], t[16] = s[15] * i[1] + s[16] * i[6] + s[17] * i[11] + s[18] * i[16], t[17] = s[15] * i[2] + s[16] * i[7] + s[17] * i[12] + s[18] * i[17], t[18] = s[15] * i[3] + s[16] * i[8] + s[17] * i[13] + s[18] * i[18], t[19] = s[15] * i[4] + s[16] * i[9] + s[17] * i[14] + s[18] * i[19] + s[19], t
    }

    _colorMatrix(t) {
        const s = new Float32Array(t);
        return s[4] /= 255, s[9] /= 255, s[14] /= 255, s[19] /= 255, s
    }

    brightness(t, s) {
        const i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, s)
    }

    tint(t, s) {
        const i = t >> 16 & 255, r = t >> 8 & 255, n = t & 255,
            o = [i / 255, 0, 0, 0, 0, 0, r / 255, 0, 0, 0, 0, 0, n / 255, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, s)
    }

    greyscale(t, s) {
        const i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, s)
    }

    blackAndWhite(t) {
        const s = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    hue(t, s) {
        t = (t || 0) / 180 * Math.PI;
        const i = Math.cos(t), r = Math.sin(t), n = Math.sqrt, o = 1 / 3, a = n(o), h = i + (1 - i) * o,
            l = o * (1 - i) - a * r, c = o * (1 - i) + a * r, u = o * (1 - i) + a * r, d = i + o * (1 - i),
            f = o * (1 - i) - a * r, p = o * (1 - i) - a * r, _ = o * (1 - i) + a * r, m = i + o * (1 - i),
            x = [h, l, c, 0, 0, u, d, f, 0, 0, p, _, m, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(x, s)
    }

    contrast(t, s) {
        const i = (t || 0) + 1, r = -.5 * (i - 1), n = [i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0];
        this._loadMatrix(n, s)
    }

    saturate(t = 0, s) {
        const i = t * 2 / 3 + 1, r = (i - 1) * -.5, n = [i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(n, s)
    }

    desaturate() {
        this.saturate(-1)
    }

    negative(t) {
        const s = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    sepia(t) {
        const s = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    technicolor(t) {
        const s = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    polaroid(t) {
        const s = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    toBGR(t) {
        const s = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    kodachrome(t) {
        const s = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    browni(t) {
        const s = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    vintage(t) {
        const s = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    colorTone(t, s, i, r, n) {
        t = t || .2, s = s || .15, i = i || 16770432, r = r || 3375104;
        const o = (i >> 16 & 255) / 255, a = (i >> 8 & 255) / 255, h = (i & 255) / 255, l = (r >> 16 & 255) / 255,
            c = (r >> 8 & 255) / 255, u = (r & 255) / 255,
            d = [.3, .59, .11, 0, 0, o, a, h, t, 0, l, c, u, s, 0, o - l, a - c, h - u, 0, 0];
        this._loadMatrix(d, n)
    }

    night(t, s) {
        t = t || .1;
        const i = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, s)
    }

    predator(t, s) {
        const i = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(i, s)
    }

    lsd(t) {
        const s = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, t)
    }

    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }

    get matrix() {
        return this.uniforms.m
    }

    set matrix(t) {
        this.uniforms.m = t
    }

    get alpha() {
        return this.uniforms.uAlpha
    }

    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}

ui.prototype.grayscale = ui.prototype.greyscale;
var uf = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, df = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;

class oa extends mt {
    constructor(t, s) {
        const i = new Q;
        t.renderable = !1, super(df, uf, {
            mapSampler: t._texture,
            filterMatrix: i,
            scale: {x: 1, y: 1},
            rotation: new Float32Array([1, 0, 0, 1])
        }), this.maskSprite = t, this.maskMatrix = i, s == null && (s = 20), this.scale = new j(s, s)
    }

    apply(t, s, i, r) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
        const n = this.maskSprite.worldTransform, o = Math.sqrt(n.a * n.a + n.b * n.b),
            a = Math.sqrt(n.c * n.c + n.d * n.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = n.a / o, this.uniforms.rotation[1] = n.b / o, this.uniforms.rotation[2] = n.c / a, this.uniforms.rotation[3] = n.d / a), t.applyFilter(this, s, i, r)
    }

    get map() {
        return this.uniforms.mapSampler
    }

    set map(t) {
        this.uniforms.mapSampler = t
    }
}

var ff = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`, pf = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;

class aa extends mt {
    constructor() {
        super(pf, ff)
    }
}

var mf = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;

class ha extends mt {
    constructor(t = .5, s = Math.random()) {
        super(Vr, mf, {uNoise: 0, uSeed: 0}), this.noise = t, this.seed = s
    }

    get noise() {
        return this.uniforms.uNoise
    }

    set noise(t) {
        this.uniforms.uNoise = t
    }

    get seed() {
        return this.uniforms.uSeed
    }

    set seed(t) {
        this.uniforms.uSeed = t
    }
}

const Qr = {
    AlphaFilter: ra,
    BlurFilter: na,
    BlurFilterPass: ci,
    ColorMatrixFilter: ui,
    DisplacementFilter: oa,
    FXAAFilter: aa,
    NoiseFilter: ha
};
Object.entries(Qr).forEach(([e, t]) => {
    Object.defineProperty(Qr, e, {
        get() {
            return t
        }
    })
});

class $e {
    constructor(t) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = $e.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new j, this.page = new j, this.AT_TARGET = 1, this.BUBBLING_PHASE = 2, this.CAPTURING_PHASE = 3, this.NONE = 0, this.manager = t
    }

    get layerX() {
        return this.layer.x
    }

    get layerY() {
        return this.layer.y
    }

    get pageX() {
        return this.page.x
    }

    get pageY() {
        return this.page.y
    }

    get data() {
        return this
    }

    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
    }

    initEvent(t, s, i) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }

    initUIEvent(t, s, i, r, n) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }

    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
    }

    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }

    stopPropagation() {
        this.propagationStopped = !0
    }
}

class us extends $e {
    constructor() {
        super(...arguments), this.client = new j, this.movement = new j, this.offset = new j, this.global = new j, this.screen = new j
    }

    get clientX() {
        return this.client.x
    }

    get clientY() {
        return this.client.y
    }

    get x() {
        return this.clientX
    }

    get y() {
        return this.clientY
    }

    get movementX() {
        return this.movement.x
    }

    get movementY() {
        return this.movement.y
    }

    get offsetX() {
        return this.offset.x
    }

    get offsetY() {
        return this.offset.y
    }

    get globalX() {
        return this.global.x
    }

    get globalY() {
        return this.global.y
    }

    get screenX() {
        return this.screen.x
    }

    get screenY() {
        return this.screen.y
    }

    getModifierState(t) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }

    initMouseEvent(t, s, i, r, n, o, a, h, l, c, u, d, f, p, _) {
        throw new Error("Method not implemented.")
    }
}

class Dt extends us {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
    }

    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }

    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}

class di extends us {
    constructor() {
        super(...arguments), this.DOM_DELTA_LINE = 0, this.DOM_DELTA_PAGE = 1, this.DOM_DELTA_PIXEL = 2
    }
}

const _f = 2048, gf = new j, Jr = new j;

class la {
    constructor(t) {
        this.dispatch = new De, this.moveOnAll = !1, this.mappingState = {trackingData: {}}, this.eventPool = new Map, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
    }

    addEventMapping(t, s) {
        this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
            fn: s,
            priority: 0
        }), this.mappingTable[t].sort((i, r) => i.priority - r.priority)
    }

    dispatchEvent(t, s) {
        t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, s), this.dispatch.emit(s || t.type, t)
    }

    mapEvent(t) {
        if (!this.rootTarget) return;
        const s = this.mappingTable[t.type];
        if (s) for (let i = 0, r = s.length; i < r; i++) s[i].fn(t); else console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }

    hitTest(t, s) {
        const i = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, gf.set(t, s), this.hitTestFn, this.hitPruneFn);
        return i && i[0]
    }

    propagate(t, s) {
        if (!t.target) return;
        const i = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let r = 0, n = i.length - 1; r < n; r++) if (t.currentTarget = i[r], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return;
        if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, s), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let r = i.length - 2; r >= 0; r--) if (t.currentTarget = i[r], this.notifyTarget(t, s), t.propagationStopped || t.propagationImmediatelyStopped) return
        }
    }

    all(t, s, i = this.rootTarget) {
        t.eventPhase = t.BUBBLING_PHASE;
        const r = i.children;
        if (r) for (let n = 0; n < r.length; n++) this.all(t, s, r[n]);
        t.currentTarget = i, this.notifyTarget(t, s)
    }

    propagationPath(t) {
        const s = [t];
        for (let i = 0; i < _f && t !== this.rootTarget; i++) {
            if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
            s.push(t.parent), t = t.parent
        }
        return s.reverse(), s
    }

    hitTestRecursive(t, s, i, r, n) {
        if (!t || !t.visible || n(t, i)) return null;
        if (t.interactiveChildren && t.children) {
            const o = t.children;
            for (let a = o.length - 1; a >= 0; a--) {
                const h = o[a], l = this.hitTestRecursive(h, s || h.interactive, i, r, n);
                if (l) {
                    if (l.length > 0 && !l[l.length - 1].parent) continue;
                    return (l.length > 0 || t.interactive) && l.push(t), l
                }
            }
        }
        return s && r(t, i) ? t.interactive ? [t] : [] : null
    }

    hitPruneFn(t, s) {
        var i;
        if (t.hitArea && (t.worldTransform.applyInverse(s, Jr), !t.hitArea.contains(Jr.x, Jr.y))) return !0;
        if (t._mask) {
            const r = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (r && !((i = r.containsPoint) != null && i.call(r, s))) return !0
        }
        return !1
    }

    hitTestFn(t, s) {
        return t.hitArea ? !0 : t.containsPoint ? t.containsPoint(s) : !1
    }

    notifyTarget(t, s) {
        var n, o;
        s = s != null ? s : t.type;
        const i = `on${s}`;
        (o = (n = t.currentTarget)[i]) == null || o.call(n, t);
        const r = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${s}capture` : s;
        this.notifyListeners(t, r), t.eventPhase === t.AT_TARGET && this.notifyListeners(t, s)
    }

    mapPointerDown(t) {
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = this.createPointerEvent(t);
        if (this.dispatchEvent(s, "pointerdown"), s.pointerType === "touch") this.dispatchEvent(s, "touchstart"); else if (s.pointerType === "mouse" || s.pointerType === "pen") {
            const r = s.button === 2;
            this.dispatchEvent(s, r ? "rightdown" : "mousedown")
        }
        const i = this.trackingData(t.pointerId);
        i.pressTargetsByButton[t.button] = s.composedPath(), this.freeEvent(s)
    }

    mapPointerMove(t) {
        var a, h;
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = this.createPointerEvent(t), i = s.pointerType === "mouse" || s.pointerType === "pen",
            r = this.trackingData(t.pointerId), n = this.findMountedTarget(r.overTargets);
        if (((a = r.overTargets) == null ? void 0 : a.length) > 0 && n !== s.target) {
            const l = t.type === "mousemove" ? "mouseout" : "pointerout", c = this.createPointerEvent(t, l, n);
            if (this.dispatchEvent(c, "pointerout"), i && this.dispatchEvent(c, "mouseout"), !s.composedPath().includes(n)) {
                const u = this.createPointerEvent(t, "pointerleave", n);
                for (u.eventPhase = u.AT_TARGET; u.target && !s.composedPath().includes(u.target);) u.currentTarget = u.target, this.notifyTarget(u), i && this.notifyTarget(u, "mouseleave"), u.target = u.target.parent;
                this.freeEvent(u)
            }
            this.freeEvent(c)
        }
        if (n !== s.target) {
            const l = t.type === "mousemove" ? "mouseover" : "pointerover", c = this.clonePointerEvent(s, l);
            this.dispatchEvent(c, "pointerover"), i && this.dispatchEvent(c, "mouseover");
            let u = n == null ? void 0 : n.parent;
            for (; u && u !== this.rootTarget.parent && u !== s.target;) u = u.parent;
            if (!u || u === this.rootTarget.parent) {
                const f = this.clonePointerEvent(s, "pointerenter");
                for (f.eventPhase = f.AT_TARGET; f.target && f.target !== n && f.target !== this.rootTarget.parent;) f.currentTarget = f.target, this.notifyTarget(f), i && this.notifyTarget(f, "mouseenter"), f.target = f.target.parent;
                this.freeEvent(f)
            }
            this.freeEvent(c)
        }
        const o = this.moveOnAll ? "all" : "dispatchEvent";
        this[o](s, "pointermove"), this.all(s, "globalpointermove"), s.pointerType === "touch" && (this[o](s, "touchmove"), this.all(s, "globaltouchmove")), i && (this[o](s, "mousemove"), this.all(s, "globalmousemove"), this.cursor = (h = s.target) == null ? void 0 : h.cursor), r.overTargets = s.composedPath(), this.freeEvent(s)
    }

    mapPointerOver(t) {
        var o;
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = this.trackingData(t.pointerId), i = this.createPointerEvent(t),
            r = i.pointerType === "mouse" || i.pointerType === "pen";
        this.dispatchEvent(i, "pointerover"), r && this.dispatchEvent(i, "mouseover"), i.pointerType === "mouse" && (this.cursor = (o = i.target) == null ? void 0 : o.cursor);
        const n = this.clonePointerEvent(i, "pointerenter");
        for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;) n.currentTarget = n.target, this.notifyTarget(n), r && this.notifyTarget(n, "mouseenter"), n.target = n.target.parent;
        s.overTargets = i.composedPath(), this.freeEvent(i), this.freeEvent(n)
    }

    mapPointerOut(t) {
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = this.trackingData(t.pointerId);
        if (s.overTargets) {
            const i = t.pointerType === "mouse" || t.pointerType === "pen", r = this.findMountedTarget(s.overTargets),
                n = this.createPointerEvent(t, "pointerout", r);
            this.dispatchEvent(n), i && this.dispatchEvent(n, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", r);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;) o.currentTarget = o.target, this.notifyTarget(o), i && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
            s.overTargets = null, this.freeEvent(n), this.freeEvent(o)
        }
        this.cursor = null
    }

    mapPointerUp(t) {
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = performance.now(), i = this.createPointerEvent(t);
        if (this.dispatchEvent(i, "pointerup"), i.pointerType === "touch") this.dispatchEvent(i, "touchend"); else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const a = i.button === 2;
            this.dispatchEvent(i, a ? "rightup" : "mouseup")
        }
        const r = this.trackingData(t.pointerId), n = this.findMountedTarget(r.pressTargetsByButton[t.button]);
        let o = n;
        if (n && !i.composedPath().includes(n)) {
            let a = n;
            for (; a && !i.composedPath().includes(a);) {
                if (i.currentTarget = a, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch") this.notifyTarget(i, "touchendoutside"); else if (i.pointerType === "mouse" || i.pointerType === "pen") {
                    const h = i.button === 2;
                    this.notifyTarget(i, h ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete r.pressTargetsByButton[t.button], o = a
        }
        if (o) {
            const a = this.clonePointerEvent(i, "click");
            a.target = o, a.path = null, r.clicksByButton[t.button] || (r.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: s
            });
            const h = r.clicksByButton[t.button];
            h.target === a.target && s - h.timeStamp < 200 ? ++h.clickCount : h.clickCount = 1, h.target = a.target, h.timeStamp = s, a.detail = h.clickCount, a.pointerType === "mouse" ? this.dispatchEvent(a, "click") : a.pointerType === "touch" && this.dispatchEvent(a, "tap"), this.dispatchEvent(a, "pointertap"), this.freeEvent(a)
        }
        this.freeEvent(i)
    }

    mapPointerUpOutside(t) {
        if (!(t instanceof Dt)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const s = this.trackingData(t.pointerId), i = this.findMountedTarget(s.pressTargetsByButton[t.button]),
            r = this.createPointerEvent(t);
        if (i) {
            let n = i;
            for (; n;) r.currentTarget = n, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch" ? this.notifyTarget(r, "touchendoutside") : (r.pointerType === "mouse" || r.pointerType === "pen") && this.notifyTarget(r, r.button === 2 ? "rightupoutside" : "mouseupoutside"), n = n.parent;
            delete s.pressTargetsByButton[t.button]
        }
        this.freeEvent(r)
    }

    mapWheel(t) {
        if (!(t instanceof di)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const s = this.createWheelEvent(t);
        this.dispatchEvent(s), this.freeEvent(s)
    }

    findMountedTarget(t) {
        if (!t) return null;
        let s = t[0];
        for (let i = 1; i < t.length && t[i].parent === s; i++) s = t[i];
        return s
    }

    createPointerEvent(t, s, i) {
        const r = this.allocateEvent(Dt);
        return this.copyPointerData(t, r), this.copyMouseData(t, r), this.copyData(t, r), r.nativeEvent = t.nativeEvent, r.originalEvent = t, r.target = i != null ? i : this.hitTest(r.global.x, r.global.y), typeof s == "string" && (r.type = s), r
    }

    createWheelEvent(t) {
        const s = this.allocateEvent(di);
        return this.copyWheelData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.nativeEvent = t.nativeEvent, s.originalEvent = t, s.target = this.hitTest(s.global.x, s.global.y), s
    }

    clonePointerEvent(t, s) {
        const i = this.allocateEvent(Dt);
        return i.nativeEvent = t.nativeEvent, i.originalEvent = t.originalEvent, this.copyPointerData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.target = t.target, i.path = t.composedPath().slice(), i.type = s != null ? s : i.type, i
    }

    copyWheelData(t, s) {
        s.deltaMode = t.deltaMode, s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ
    }

    copyPointerData(t, s) {
        t instanceof Dt && s instanceof Dt && (s.pointerId = t.pointerId, s.width = t.width, s.height = t.height, s.isPrimary = t.isPrimary, s.pointerType = t.pointerType, s.pressure = t.pressure, s.tangentialPressure = t.tangentialPressure, s.tiltX = t.tiltX, s.tiltY = t.tiltY, s.twist = t.twist)
    }

    copyMouseData(t, s) {
        t instanceof us && s instanceof us && (s.altKey = t.altKey, s.button = t.button, s.buttons = t.buttons, s.client.copyFrom(t.client), s.ctrlKey = t.ctrlKey, s.metaKey = t.metaKey, s.movement.copyFrom(t.movement), s.screen.copyFrom(t.screen), s.global.copyFrom(t.global))
    }

    copyData(t, s) {
        s.isTrusted = t.isTrusted, s.srcElement = t.srcElement, s.timeStamp = performance.now(), s.type = t.type, s.detail = t.detail, s.view = t.view, s.which = t.which, s.layer.copyFrom(t.layer), s.page.copyFrom(t.page)
    }

    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[t]
    }

    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const s = this.eventPool.get(t).pop() || new t(this);
        return s.eventPhase = s.NONE, s.currentTarget = null, s.path = null, s.target = null, s
    }

    freeEvent(t) {
        if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const s = t.constructor;
        this.eventPool.has(s) || this.eventPool.set(s, []), this.eventPool.get(s).push(t)
    }

    notifyListeners(t, s) {
        const i = t.currentTarget._events[s];
        if (!!i) if ("fn" in i) i.fn.call(i.context, t); else for (let r = 0, n = i.length; r < n && !t.propagationImmediatelyStopped; r++) i[r].fn.call(i[r].context, t)
    }
}

const xf = 1, vf = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
};

class tn {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new la(null), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new Dt(null), this.rootWheelEvent = new di(null), this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        }, this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
    }

    init() {
        const {view: t, resolution: s} = this.renderer;
        this.setTargetElement(t), this.resolution = s
    }

    resolutionChange(t) {
        this.resolution = t
    }

    destroy() {
        this.setTargetElement(null), this.renderer = null
    }

    setCursor(t) {
        t = t || "default";
        let s = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (s = !1), this.currentCursor === t) return;
        this.currentCursor = t;
        const i = this.cursorStyles[t];
        if (i) switch (typeof i) {
            case"string":
                s && (this.domElement.style.cursor = i);
                break;
            case"function":
                i(t);
                break;
            case"object":
                s && Object.assign(this.domElement.style, i);
                break
        } else s && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }

    onPointerDown(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const s = this.normalizeToPointerData(t);
        this.autoPreventDefault && s[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
        for (let i = 0, r = s.length; i < r; i++) {
            const n = s[i], o = this.bootstrapEvent(this.rootPointerEvent, n);
            this.rootBoundary.mapEvent(o)
        }
        this.setCursor(this.rootBoundary.cursor)
    }

    onPointerMove(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const s = this.normalizeToPointerData(t);
        for (let i = 0, r = s.length; i < r; i++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, s[i]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }

    onPointerUp(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        let s = t.target;
        t.composedPath && t.composedPath().length > 0 && (s = t.composedPath()[0]);
        const i = s !== this.domElement ? "outside" : "", r = this.normalizeToPointerData(t);
        for (let n = 0, o = r.length; n < o; n++) {
            const a = this.bootstrapEvent(this.rootPointerEvent, r[n]);
            a.type += i, this.rootBoundary.mapEvent(a)
        }
        this.setCursor(this.rootBoundary.cursor)
    }

    onPointerOverOut(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const s = this.normalizeToPointerData(t);
        for (let i = 0, r = s.length; i < r; i++) {
            const n = this.bootstrapEvent(this.rootPointerEvent, s[i]);
            this.rootBoundary.mapEvent(n)
        }
        this.setCursor(this.rootBoundary.cursor)
    }

    onWheel(t) {
        const s = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(s)
    }

    setTargetElement(t) {
        this.removeEvents(), this.domElement = t, this.addEvents()
    }

    addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)), this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }), this.eventsAdded = !0
    }

    removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1
    }

    mapPositionToPoint(t, s, i) {
        let r;
        this.domElement.parentElement ? r = this.domElement.getBoundingClientRect() : r = {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const n = 1 / this.resolution;
        t.x = (s - r.left) * (this.domElement.width / r.width) * n, t.y = (i - r.top) * (this.domElement.height / r.height) * n
    }

    normalizeToPointerData(t) {
        const s = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent) for (let i = 0, r = t.changedTouches.length; i < r; i++) {
            const n = t.changedTouches[i];
            typeof n.button == "undefined" && (n.button = 0), typeof n.buttons == "undefined" && (n.buttons = 1), typeof n.isPrimary == "undefined" && (n.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof n.width == "undefined" && (n.width = n.radiusX || 1), typeof n.height == "undefined" && (n.height = n.radiusY || 1), typeof n.tiltX == "undefined" && (n.tiltX = 0), typeof n.tiltY == "undefined" && (n.tiltY = 0), typeof n.pointerType == "undefined" && (n.pointerType = "touch"), typeof n.pointerId == "undefined" && (n.pointerId = n.identifier || 0), typeof n.pressure == "undefined" && (n.pressure = n.force || .5), typeof n.twist == "undefined" && (n.twist = 0), typeof n.tangentialPressure == "undefined" && (n.tangentialPressure = 0), typeof n.layerX == "undefined" && (n.layerX = n.offsetX = n.clientX), typeof n.layerY == "undefined" && (n.layerY = n.offsetY = n.clientY), n.isNormalized = !0, n.type = t.type, s.push(n)
        } else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
            const i = t;
            typeof i.isPrimary == "undefined" && (i.isPrimary = !0), typeof i.width == "undefined" && (i.width = 1), typeof i.height == "undefined" && (i.height = 1), typeof i.tiltX == "undefined" && (i.tiltX = 0), typeof i.tiltY == "undefined" && (i.tiltY = 0), typeof i.pointerType == "undefined" && (i.pointerType = "mouse"), typeof i.pointerId == "undefined" && (i.pointerId = xf), typeof i.pressure == "undefined" && (i.pressure = .5), typeof i.twist == "undefined" && (i.twist = 0), typeof i.tangentialPressure == "undefined" && (i.tangentialPressure = 0), i.isNormalized = !0, s.push(i)
        } else s.push(t);
        return s
    }

    normalizeWheelEvent(t) {
        const s = this.rootWheelEvent;
        return this.transferMouseData(s, t), s.deltaX = t.deltaX, s.deltaY = t.deltaY, s.deltaZ = t.deltaZ, s.deltaMode = t.deltaMode, this.mapPositionToPoint(s.screen, t.clientX, t.clientY), s.global.copyFrom(s.screen), s.offset.copyFrom(s.screen), s.nativeEvent = t, s.type = t.type, s
    }

    bootstrapEvent(t, s) {
        return t.originalEvent = null, t.nativeEvent = s, t.pointerId = s.pointerId, t.width = s.width, t.height = s.height, t.isPrimary = s.isPrimary, t.pointerType = s.pointerType, t.pressure = s.pressure, t.tangentialPressure = s.tangentialPressure, t.tiltX = s.tiltX, t.tiltY = s.tiltY, t.twist = s.twist, this.transferMouseData(t, s), this.mapPositionToPoint(t.screen, s.clientX, s.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = s.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = vf[t.type] || t.type), t
    }

    transferMouseData(t, s) {
        t.isTrusted = s.isTrusted, t.srcElement = s.srcElement, t.timeStamp = performance.now(), t.type = s.type, t.altKey = s.altKey, t.button = s.button, t.buttons = s.buttons, t.client.x = s.clientX, t.client.y = s.clientY, t.ctrlKey = s.ctrlKey, t.metaKey = s.metaKey, t.movement.x = s.movementX, t.movement.y = s.movementY, t.page.x = s.pageX, t.page.y = s.pageY, t.relatedTarget = null, t.shiftKey = s.shiftKey
    }
}

tn.extension = {name: "events", type: [I.RendererSystem, I.CanvasRendererSystem]}, O.add(tn);
const ca = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    interactive: !1,
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(e, t, s) {
        const i = typeof s == "boolean" && s || typeof s == "object" && s.capture,
            r = typeof t == "function" ? void 0 : t;
        e = i ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.on(e, t, r)
    },
    removeEventListener(e, t, s) {
        const i = typeof s == "boolean" && s || typeof s == "object" && s.capture,
            r = typeof t == "function" ? void 0 : t;
        e = i ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.off(e, t, r)
    },
    dispatchEvent(e) {
        if (!(e instanceof $e)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented
    }
};
et.mixin(ca);
const ua = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
et.mixin(ua);
const yf = 9, fi = 100, Tf = 0, bf = 0, da = 2, fa = 1, Ef = -1e3, wf = -1e3, Af = 2;

class en {
    constructor(t) {
        this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (kt.tablet || kt.phone) && this.createTouchHook();
        const s = document.createElement("div");
        s.style.width = `${fi}px`, s.style.height = `${fi}px`, s.style.position = "absolute", s.style.top = `${Tf}px`, s.style.left = `${bf}px`, s.style.zIndex = da.toString(), this.div = s, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }

    get isActive() {
        return this._isActive
    }

    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }

    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${fa}px`, t.style.height = `${fa}px`, t.style.position = "absolute", t.style.top = `${Ef}px`, t.style.left = `${wf}px`, t.style.zIndex = Af.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
            this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook()
        }), document.body.appendChild(t), this._hookDiv = t
    }

    destroyTouchHook() {
        !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null)
    }

    activate() {
        var t;
        this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (t = this.renderer.view.parentNode) == null || t.appendChild(this.div))
    }

    deactivate() {
        var t;
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (t = this.div.parentNode) == null || t.removeChild(this.div))
    }

    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren) return;
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        const s = t.children;
        if (s) for (let i = 0; i < s.length; i++) this.updateAccessibleObjects(s[i])
    }

    update() {
        const t = performance.now();
        if (kt.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency, !this.renderer.renderingToScreen)) return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {x: s, y: i, width: r, height: n} = this.renderer.view.getBoundingClientRect(), {
            width: o,
            height: a,
            resolution: h
        } = this.renderer, l = r / o * h, c = n / a * h;
        let u = this.div;
        u.style.left = `${s}px`, u.style.top = `${i}px`, u.style.width = `${o}px`, u.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId) f._accessibleActive = !1, ve(this.children, d, 1), this.div.removeChild(f._accessibleDiv), this.pool.push(f._accessibleDiv), f._accessibleDiv = null, d--; else {
                u = f._accessibleDiv;
                let p = f.hitArea;
                const _ = f.worldTransform;
                f.hitArea ? (u.style.left = `${(_.tx + p.x * _.a) * l}px`, u.style.top = `${(_.ty + p.y * _.d) * c}px`, u.style.width = `${p.width * _.a * l}px`, u.style.height = `${p.height * _.d * c}px`) : (p = f.getBounds(), this.capHitArea(p), u.style.left = `${p.x * l}px`, u.style.top = `${p.y * c}px`, u.style.width = `${p.width * l}px`, u.style.height = `${p.height * c}px`, u.title !== f.accessibleTitle && f.accessibleTitle !== null && (u.title = f.accessibleTitle), u.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && u.setAttribute("aria-label", f.accessibleHint)), (f.accessibleTitle !== u.title || f.tabIndex !== u.tabIndex) && (u.title = f.accessibleTitle, u.tabIndex = f.tabIndex, this.debug && this.updateDebugHTML(u))
            }
        }
        this.renderId++
    }

    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }

    capHitArea(t) {
        t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
        const {width: s, height: i} = this.renderer;
        t.x + t.width > s && (t.width = s - t.x), t.y + t.height > i && (t.height = i - t.y)
    }

    addChild(t) {
        let s = this.pool.pop();
        s || (s = document.createElement("button"), s.style.width = `${fi}px`, s.style.height = `${fi}px`, s.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", s.style.position = "absolute", s.style.zIndex = da.toString(), s.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? s.setAttribute("aria-live", "off") : s.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? s.setAttribute("aria-relevant", "additions") : s.setAttribute("aria-relevant", "text"), s.addEventListener("click", this._onClick.bind(this)), s.addEventListener("focus", this._onFocus.bind(this)), s.addEventListener("focusout", this._onFocusOut.bind(this))), s.style.pointerEvents = t.accessiblePointerEvents, s.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? s.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (s.title = `displayObject ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && s.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(s), t._accessibleActive = !0, t._accessibleDiv = s, s.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
    }

    _dispatchEvent(t, s) {
        const {displayObject: i} = t.target, r = this.renderer.events.rootBoundary,
            n = Object.assign(new $e(r), {target: i});
        r.rootTarget = this.renderer.lastObjectRendered, s.forEach(o => r.dispatchEvent(n, o))
    }

    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }

    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"])
    }

    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"])
    }

    _onKeyDown(t) {
        t.keyCode === yf && this.activate()
    }

    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }

    destroy() {
        this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
    }
}

en.extension = {name: "accessibility", type: [I.RendererPlugin, I.CanvasRendererPlugin]}, O.add(en);
const sn = class {
    constructor(e) {
        this.stage = new bt, e = Object.assign({forceCanvas: !1}, e), this.renderer = Qo(e), sn._plugins.forEach(t => {
            t.init.call(this, e)
        })
    }

    render() {
        this.renderer.render(this.stage)
    }

    get view() {
        return this.renderer.view
    }

    get screen() {
        return this.renderer.screen
    }

    destroy(e, t) {
        const s = sn._plugins.slice(0);
        s.reverse(), s.forEach(i => {
            i.destroy.call(this)
        }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null
    }
};
let rn = sn;
rn._plugins = [], O.handleByList(I.Application, rn._plugins);

class nn {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(s) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = s, s && (globalThis.addEventListener("resize", this.queueResize), this.resize())
            }, get() {
                return this._resizeTo
            }
        }), this.queueResize = () => {
            !this._resizeTo || (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
        }, this.cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
        }, this.resize = () => {
            if (!this._resizeTo) return;
            this.cancelResize();
            let s, i;
            if (this._resizeTo === globalThis.window) s = globalThis.innerWidth, i = globalThis.innerHeight; else {
                const {clientWidth: r, clientHeight: n} = this._resizeTo;
                s = r, i = n
            }
            this.renderer.resize(s, i), this.render()
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
    }

    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
    }
}

nn.extension = I.Application, O.add(nn);
const pa = {loader: I.LoadParser, resolver: I.ResolveParser, cache: I.CacheParser, detection: I.DetectionParser};
O.handle(I.Asset, e => {
    const t = e.ref;
    Object.entries(pa).filter(([s]) => !!t[s]).forEach(([s, i]) => {
        var r;
        return O.add(Object.assign(t[s], {extension: (r = t[s].extension) != null ? r : i}))
    })
}, e => {
    const t = e.ref;
    Object.keys(pa).filter(s => !!t[s]).forEach(s => O.remove(t[s]))
});

class Sf {
    constructor(t, s = !1) {
        this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = s
    }

    add(t) {
        t.forEach(s => {
            this._assetList.push(s)
        }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
    }

    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = [], s = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i = 0; i < s; i++) t.push(this._assetList.pop());
            await this._loader.load(t), this._isLoading = !1, this._next()
        }
    }

    get active() {
        return this._isActive
    }

    set active(t) {
        this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next())
    }
}

function on(e, t) {
    if (Array.isArray(t)) {
        for (const s of t) if (e.startsWith(`data:${s}`)) return !0;
        return !1
    }
    return e.startsWith(`data:${t}`)
}

function ds(e, t) {
    const s = e.split("?")[0], i = ft.extname(s).toLowerCase();
    return Array.isArray(t) ? t.includes(i) : i === t
}

const Qt = (e, t) => (Array.isArray(e) || (e = [e]), t ? e.map(s => typeof s == "string" ? t(s) : s) : e),
    pi = (e, t) => {
        const s = t.split("?")[1];
        return s && (e += `?${s}`), e
    };

function ma(e, t, s, i, r) {
    const n = t[s];
    for (let o = 0; o < n.length; o++) {
        const a = n[o];
        s < t.length - 1 ? ma(e.replace(i[s], a), t, s + 1, i, r) : r.push(e.replace(i[s], a))
    }
}

function _a(e) {
    const t = /\{(.*?)\}/g, s = e.match(t), i = [];
    if (s) {
        const r = [];
        s.forEach(n => {
            const o = n.substring(1, n.length - 1).split(",");
            r.push(o)
        }), ma(e, r, 0, s, i)
    } else i.push(e);
    return i
}

const fs = e => !Array.isArray(e);

class Rf {
    constructor() {
        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
    }

    reset() {
        this._cacheMap.clear(), this._cache.clear()
    }

    has(t) {
        return this._cache.has(t)
    }

    get(t) {
        const s = this._cache.get(t);
        return s || console.warn(`[Assets] Asset id ${t} was not found in the Cache`), s
    }

    set(t, s) {
        const i = Qt(t);
        let r;
        for (let a = 0; a < this.parsers.length; a++) {
            const h = this.parsers[a];
            if (h.test(s)) {
                r = h.getCacheableAssets(i, s);
                break
            }
        }
        r || (r = {}, i.forEach(a => {
            r[a] = s
        }));
        const n = Object.keys(r), o = {cacheKeys: n, keys: i};
        if (i.forEach(a => {
            this._cacheMap.set(a, o)
        }), n.forEach(a => {
            this._cache.has(a) && this._cache.get(a) !== s && console.warn("[Cache] already has key:", a), this._cache.set(a, r[a])
        }), s instanceof B) {
            const a = s;
            i.forEach(h => {
                a.baseTexture !== B.EMPTY.baseTexture && X.addToCache(a.baseTexture, h), B.addToCache(a, h)
            })
        }
    }

    remove(t) {
        if (this._cacheMap.get(t), !this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const s = this._cacheMap.get(t);
        s.cacheKeys.forEach(r => {
            this._cache.delete(r)
        }), s.keys.forEach(r => {
            this._cacheMap.delete(r)
        })
    }

    get parsers() {
        return this._parsers
    }
}

const Xe = new Rf;

class Cf {
    constructor() {
        this._parsers = [], this.promiseCache = {}
    }

    reset() {
        this.promiseCache = {}
    }

    _getLoadPromiseAndParser(t, s) {
        const i = {promise: null, parser: null};
        return i.promise = (async () => {
            var n, o;
            let r = null;
            for (let a = 0; a < this.parsers.length; a++) {
                const h = this.parsers[a];
                if (h.load && ((n = h.test) == null ? void 0 : n.call(h, t, s, this))) {
                    r = await h.load(t, s, this), i.parser = h;
                    break
                }
            }
            if (!i.parser) return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`), null;
            for (let a = 0; a < this.parsers.length; a++) {
                const h = this.parsers[a];
                h.parse && h.parse && await ((o = h.testParse) == null ? void 0 : o.call(h, r, s, this)) && (r = await h.parse(r, s, this) || r, i.parser = h)
            }
            return r
        })(), i
    }

    async load(t, s) {
        let i = 0;
        const r = {}, n = fs(t), o = Qt(t, l => ({src: l})), a = o.length, h = o.map(async l => {
            const c = ft.toAbsolute(l.src);
            if (!r[l.src]) try {
                this.promiseCache[c] || (this.promiseCache[c] = this._getLoadPromiseAndParser(c, l)), r[l.src] = await this.promiseCache[c].promise, s && s(++i / a)
            } catch (u) {
                throw delete this.promiseCache[c], delete r[l.src], new Error(`[Loader.load] Failed to load ${c}.
${u}`)
            }
        });
        return await Promise.all(h), n ? r[o[0].src] : r
    }

    async unload(t) {
        const i = Qt(t, r => ({src: r})).map(async r => {
            var a, h;
            const n = ft.toAbsolute(r.src), o = this.promiseCache[n];
            if (o) {
                const l = await o.promise;
                (h = (a = o.parser) == null ? void 0 : a.unload) == null || h.call(a, l, r, this), delete this.promiseCache[n]
            }
        });
        await Promise.all(i)
    }

    get parsers() {
        return this._parsers
    }
}

var Xt = (e => (e[e.Low = 0] = "Low", e[e.Normal = 1] = "Normal", e[e.High = 2] = "High", e))(Xt || {});
const ga = {
    extension: {type: I.LoadParser, priority: Xt.Low}, test(e) {
        return ft.extname(e).toLowerCase() === ".json"
    }, async load(e) {
        return await (await M.ADAPTER.fetch(e)).json()
    }
};
O.add(ga);
const xa = {
    extension: {type: I.LoadParser, priority: Xt.Low}, test(e) {
        return ft.extname(e).toLowerCase() === ".txt"
    }, async load(e) {
        return await (await M.ADAPTER.fetch(e)).text()
    }
};
O.add(xa);
const If = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
    Pf = [".ttf", ".otf", ".woff", ".woff2"], Mf = ["font/ttf", "font/otf", "font/woff", "font/woff2"];

function va(e) {
    const t = ft.extname(e);
    return ft.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(n => n.charAt(0).toUpperCase() + n.slice(1)).join(" ")
}

const ya = {
    extension: {type: I.LoadParser, priority: Xt.Low}, test(e) {
        return on(e, Mf) || ds(e, Pf)
    }, async load(e, t) {
        var i, r, n, o, a, h;
        const s = M.ADAPTER.getFontFaceSet();
        if (s) {
            const l = [], c = (r = (i = t.data) == null ? void 0 : i.family) != null ? r : va(e),
                u = (a = (o = (n = t.data) == null ? void 0 : n.weights) == null ? void 0 : o.filter(f => If.includes(f))) != null ? a : ["normal"],
                d = (h = t.data) != null ? h : {};
            for (let f = 0; f < u.length; f++) {
                const p = u[f], _ = new FontFace(c, `url(${encodeURI(e)})`, Ni(Yt({}, d), {weight: p}));
                await _.load(), s.add(_), l.push(_)
            }
            return l.length === 1 ? l[0] : l
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
    }, unload(e) {
        (Array.isArray(e) ? e : [e]).forEach(t => M.ADAPTER.getFontFaceSet().delete(t))
    }
};
O.add(ya);
let Ta = 0, an;
const Bf = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",
    Df = {
        id: "checkImageBitmap", code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${Bf}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    }, Ff = {
        id: "loadImageBitmap", code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
let hn;

class Nf {
    constructor() {
        this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {}
    }

    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t => {
            const s = URL.createObjectURL(new Blob([Df.code], {type: "application/javascript"})), i = new Worker(s);
            i.addEventListener("message", r => {
                i.terminate(), URL.revokeObjectURL(s), t(r.data)
            })
        }), this._isImageBitmapSupported)
    }

    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }

    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }

    getWorker() {
        an === void 0 && (an = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < an && (hn || (hn = URL.createObjectURL(new Blob([Ff.code], {type: "application/javascript"}))), this._createdWorkers++, t = new Worker(hn), t.addEventListener("message", s => {
            this.complete(s.data), this.returnWorker(s.target), this.next()
        })), t
    }

    returnWorker(t) {
        this.workerPool.push(t)
    }

    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data), this.resolveHash[t.uuid] = null
    }

    async _run(t, s) {
        await this._initWorkers();
        const i = new Promise((r, n) => {
            this.queue.push({id: t, arguments: s, resolve: r, reject: n})
        });
        return this.next(), i
    }

    next() {
        if (!this.queue.length) return;
        const t = this.getWorker();
        if (!t) return;
        const s = this.queue.pop(), i = s.id;
        this.resolveHash[Ta] = {resolve: s.resolve, reject: s.reject}, t.postMessage({
            data: s.arguments,
            uuid: Ta++,
            id: i
        })
    }
}

const ba = new Nf;

function ps(e, t, s) {
    const i = new B(e);
    return i.baseTexture.on("dispose", () => {
        delete t.promiseCache[s]
    }), i
}

const Lf = [".jpeg", ".jpg", ".png", ".webp", ".avif"], Of = ["image/jpeg", "image/png", "image/webp", "image/avif"];

async function Ea(e) {
    const t = await M.ADAPTER.fetch(e);
    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
    const s = await t.blob();
    return await createImageBitmap(s)
}

const Ve = {
    extension: {type: I.LoadParser, priority: Xt.High}, config: {preferWorkers: !0}, test(e) {
        return on(e, Of) || ds(e, Lf)
    }, async load(e, t, s) {
        let i = null;
        globalThis.createImageBitmap ? this.config.preferWorkers && await ba.isImageBitmapSupported() ? i = await ba.loadImageBitmap(e) : i = await Ea(e) : i = await new Promise(n => {
            i = new Image, i.crossOrigin = "anonymous", i.src = e, i.complete ? n(i) : i.onload = () => {
                n(i)
            }
        });
        const r = new X(i, Yt({resolution: ee(e)}, t.data));
        return r.resource.src = e, ps(r, s, e)
    }, unload(e) {
        e.destroy(!0)
    }
};
O.add(Ve);
const wa = {
    extension: {type: I.LoadParser, priority: Xt.High}, test(e) {
        return ft.extname(e).toLowerCase() === ".svg"
    }, async testParse(e) {
        return He.test(e)
    }, async parse(e, t, s) {
        var o, a, h;
        const i = new He(e, (o = t == null ? void 0 : t.data) == null ? void 0 : o.resourceOptions),
            r = new X(i, Yt({resolution: ee(e)}, t == null ? void 0 : t.data));
        r.resource.src = e;
        const n = ps(r, s, e);
        return (h = (a = t == null ? void 0 : t.data) == null ? void 0 : a.resourceOptions) != null && h.autoLoad || await i.load(), n
    }, async load(e, t) {
        return (await M.ADAPTER.fetch(e)).text()
    }, unload: Ve.unload
};
O.add(wa);

class Uf {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t, s) => `${t}${this._bundleIdConnector}${s}`,
            extractAssetIdFromBundle: (t, s) => s.replace(`${t}${this._bundleIdConnector}`, "")
        }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
    }

    setBundleIdentifier(t) {
        var s, i, r;
        if (this._bundleIdConnector = (s = t.connector) != null ? s : this._bundleIdConnector, this._createBundleAssetId = (i = t.createBundleAssetId) != null ? i : this._createBundleAssetId, this._extractAssetIdFromBundle = (r = t.extractAssetIdFromBundle) != null ? r : this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }

    prefer(...t) {
        t.forEach(s => {
            this._preferredOrder.push(s), s.priority || (s.priority = Object.keys(s.params))
        }), this._resolverHash = {}
    }

    set basePath(t) {
        this._basePath = t
    }

    get basePath() {
        return this._basePath
    }

    set rootPath(t) {
        this._rootPath = t
    }

    get rootPath() {
        return this._rootPath
    }

    get parsers() {
        return this._parsers
    }

    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
    }

    setDefaultSearchParams(t) {
        if (typeof t == "string") this._defaultSearchParams = t; else {
            const s = t;
            this._defaultSearchParams = Object.keys(s).map(i => `${encodeURIComponent(i)}=${encodeURIComponent(s[i])}`).join("&")
        }
    }

    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach(s => {
            this.addBundle(s.name, s.assets)
        })
    }

    addBundle(t, s) {
        const i = [];
        Array.isArray(s) ? s.forEach(r => {
            if (typeof r.name == "string") {
                const n = this._createBundleAssetId(t, r.name);
                i.push(n), this.add([r.name, n], r.srcs, r.data)
            } else {
                const n = r.name.map(o => this._createBundleAssetId(t, o));
                n.forEach(o => {
                    i.push(o)
                }), this.add([...r.name, ...n], r.srcs)
            }
        }) : Object.keys(s).forEach(r => {
            i.push(this._createBundleAssetId(t, r)), this.add([r, this._createBundleAssetId(t, r)], s[r])
        }), this._bundles[t] = i
    }

    add(t, s, i) {
        const r = Qt(t);
        r.forEach(o => {
            this.hasKey(o) && console.warn(`[Resolver] already has key: ${o} overwriting`)
        }), Array.isArray(s) || (typeof s == "string" ? s = _a(s) : s = [s]);
        const n = s.map(o => {
            var h;
            let a = o;
            if (typeof o == "string") {
                let l = !1;
                for (let c = 0; c < this._parsers.length; c++) {
                    const u = this._parsers[c];
                    if (u.test(o)) {
                        a = u.parse(o), l = !0;
                        break
                    }
                }
                l || (a = {src: o})
            }
            return a.format || (a.format = a.src.split(".").pop()), a.alias || (a.alias = r), (this._basePath || this._rootPath) && (a.src = ft.toAbsolute(a.src, this._basePath, this._rootPath)), a.src = this._appendDefaultSearchParams(a.src), a.data = (h = a.data) != null ? h : i, a
        });
        r.forEach(o => {
            this._assetMap[o] = n
        })
    }

    resolveBundle(t) {
        const s = fs(t);
        t = Qt(t);
        const i = {};
        return t.forEach(r => {
            const n = this._bundles[r];
            if (n) {
                const o = this.resolve(n), a = {};
                for (const h in o) {
                    const l = o[h];
                    a[this._extractAssetIdFromBundle(r, h)] = l
                }
                i[r] = a
            }
        }), s ? i[t[0]] : i
    }

    resolveUrl(t) {
        const s = this.resolve(t);
        if (typeof t != "string") {
            const i = {};
            for (const r in s) i[r] = s[r].src;
            return i
        }
        return s.src
    }

    resolve(t) {
        const s = fs(t);
        t = Qt(t);
        const i = {};
        return t.forEach(r => {
            var n;
            if (!this._resolverHash[r]) if (this._assetMap[r]) {
                let o = this._assetMap[r];
                const a = this._getPreferredOrder(o), h = o[0];
                a == null || a.priority.forEach(l => {
                    a.params[l].forEach(c => {
                        const u = o.filter(d => d[l] ? d[l] === c : !1);
                        u.length && (o = u)
                    })
                }), this._resolverHash[r] = (n = o[0]) != null ? n : h
            } else {
                let o = r;
                (this._basePath || this._rootPath) && (o = ft.toAbsolute(o, this._basePath, this._rootPath)), o = this._appendDefaultSearchParams(o), this._resolverHash[r] = {src: o}
            }
            i[r] = this._resolverHash[r]
        }), s ? i[t[0]] : i
    }

    hasKey(t) {
        return !!this._assetMap[t]
    }

    hasBundle(t) {
        return !!this._bundles[t]
    }

    _getPreferredOrder(t) {
        for (let s = 0; s < t.length; s++) {
            const i = t[0], r = this._preferredOrder.find(n => n.params.format.includes(i.format));
            if (r) return r
        }
        return this._preferredOrder[0]
    }

    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams) return t;
        const s = /\?/.test(t) ? "&" : "?";
        return `${t}${s}${this._defaultSearchParams}`
    }
}

class Aa {
    constructor() {
        this._detections = [], this._initialized = !1, this.resolver = new Uf, this.loader = new Cf, this.cache = Xe, this._backgroundLoader = new Sf(this.loader), this._backgroundLoader.active = !0, this.reset()
    }

    async init(t = {}) {
        var n, o, a, h;
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return
        }
        if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
            let l = t.manifest;
            typeof l == "string" && (l = await this.load(l)), this.resolver.addManifest(l)
        }
        const s = (o = (n = t.texturePreference) == null ? void 0 : n.resolution) != null ? o : 1,
            i = typeof s == "number" ? [s] : s;
        let r = [];
        if ((a = t.texturePreference) != null && a.format) {
            const l = (h = t.texturePreference) == null ? void 0 : h.format;
            r = typeof l == "string" ? [l] : l;
            for (const c of this._detections) await c.test() || (r = await c.remove(r))
        } else for (const l of this._detections) await l.test() && (r = await l.add(r));
        this.resolver.prefer({params: {format: r, resolution: i}})
    }

    add(t, s, i) {
        this.resolver.add(t, s, i)
    }

    async load(t, s) {
        this._initialized || await this.init();
        const i = fs(t),
            r = Qt(t).map(a => typeof a != "string" ? (this.resolver.add(a.src, a), a.src) : (this.resolver.hasKey(a) || this.resolver.add(a, a), a)),
            n = this.resolver.resolve(r), o = await this._mapLoadToResolve(n, s);
        return i ? o[r[0]] : o
    }

    addBundle(t, s) {
        this.resolver.addBundle(t, s)
    }

    async loadBundle(t, s) {
        this._initialized || await this.init();
        let i = !1;
        typeof t == "string" && (i = !0, t = [t]);
        const r = this.resolver.resolveBundle(t), n = {}, o = Object.keys(r);
        let a = 0, h = 0;
        const l = () => {
            s == null || s(++a / h)
        }, c = o.map(u => {
            const d = r[u];
            return h += Object.keys(d).length, this._mapLoadToResolve(d, l).then(f => {
                n[u] = f
            })
        });
        return await Promise.all(c), i ? n[t[0]] : n
    }

    async backgroundLoad(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const s = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(s))
    }

    async backgroundLoadBundle(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const s = this.resolver.resolveBundle(t);
        Object.values(s).forEach(i => {
            this._backgroundLoader.add(Object.values(i))
        })
    }

    reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
    }

    get(t) {
        if (typeof t == "string") return Xe.get(t);
        const s = {};
        for (let i = 0; i < t.length; i++) s[i] = Xe.get(t[i]);
        return s
    }

    async _mapLoadToResolve(t, s) {
        const i = Object.values(t), r = Object.keys(t);
        this._backgroundLoader.active = !1;
        const n = await this.loader.load(i, s);
        this._backgroundLoader.active = !0;
        const o = {};
        return i.forEach((a, h) => {
            const l = n[a.src], c = [a.src];
            a.alias && c.push(...a.alias), o[r[h]] = l, Xe.set(c, l)
        }), o
    }

    async unload(t) {
        this._initialized || await this.init();
        const s = Qt(t).map(r => typeof r != "string" ? r.src : r), i = this.resolver.resolve(s);
        await this._unloadFromResolved(i)
    }

    async unloadBundle(t) {
        this._initialized || await this.init(), t = Qt(t);
        const s = this.resolver.resolveBundle(t), i = Object.keys(s).map(r => this._unloadFromResolved(s[r]));
        await Promise.all(i)
    }

    async _unloadFromResolved(t) {
        const s = Object.values(t);
        s.forEach(i => {
            Xe.remove(i.src)
        }), await this.loader.unload(s)
    }

    get detections() {
        return this._detections
    }

    get preferWorkers() {
        return Ve.config.preferWorkers
    }

    set preferWorkers(t) {
        Ve.config.preferWorkers = t
    }
}

const ms = new Aa;
O.handleByList(I.LoadParser, ms.loader.parsers).handleByList(I.ResolveParser, ms.resolver.parsers).handleByList(I.CacheParser, ms.cache.parsers).handleByList(I.DetectionParser, ms.detections);
const Sa = {
    extension: I.CacheParser,
    test: e => Array.isArray(e) && e.every(t => t instanceof B),
    getCacheableAssets: (e, t) => {
        const s = {};
        return e.forEach(i => {
            t.forEach((r, n) => {
                s[i + (n === 0 ? "" : n + 1)] = r
            })
        }), s
    }
};
O.add(Sa);
const Ra = {
    extension: {type: I.DetectionParser, priority: 1}, test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",
            t = await M.ADAPTER.fetch(e).then(s => s.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    }, add: async e => [...e, "avif"], remove: async e => e.filter(t => t !== "avif")
};
O.add(Ra);
const Ca = {
    extension: {type: I.DetectionParser, priority: 0}, test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",
            t = await M.ADAPTER.fetch(e).then(s => s.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    }, add: async e => [...e, "webp"], remove: async e => e.filter(t => t !== "webp")
};
O.add(Ca);
const Ia = ["png", "jpg", "jpeg"], Pa = {
    extension: {type: I.DetectionParser, priority: -1},
    test: () => Promise.resolve(!0),
    add: async e => [...e, ...Ia],
    remove: async e => e.filter(t => !Ia.includes(t))
};
O.add(Pa);
const Ma = {
    extension: I.ResolveParser, test: Ve.test, parse: e => {
        var t, s;
        return {
            resolution: parseFloat((s = (t = M.RETINA_PREFIX.exec(e)) == null ? void 0 : t[1]) != null ? s : "1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
O.add(Ma);
var Et = (e => (e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e))(Et || {});
const _s = {
    [33776]: .5,
    [33777]: .5,
    [33778]: 1,
    [33779]: 1,
    [35916]: .5,
    [35917]: .5,
    [35918]: 1,
    [35919]: 1,
    [37488]: .5,
    [37489]: .5,
    [37490]: 1,
    [37491]: 1,
    [37492]: .5,
    [37496]: 1,
    [37493]: .5,
    [37497]: 1,
    [37494]: .5,
    [37495]: .5,
    [35840]: .5,
    [35842]: .5,
    [35841]: .25,
    [35843]: .25,
    [36196]: .5,
    [35986]: .5,
    [35986]: 1,
    [34798]: 1,
    [37808]: 1
};
let ie, ze;

function Ba() {
    ze = {
        s3tc: ie.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: ie.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: ie.getExtension("WEBGL_compressed_texture_etc"),
        etc1: ie.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: ie.getExtension("WEBGL_compressed_texture_pvrtc") || ie.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: ie.getExtension("WEBGL_compressed_texture_atc"),
        astc: ie.getExtension("WEBGL_compressed_texture_astc")
    }
}

const Da = {
    extension: {type: I.DetectionParser, priority: 2}, test: async () => {
        const t = M.ADAPTER.createCanvas().getContext("webgl");
        return t ? (ie = t, !0) : (console.warn("WebGL not available for compressed textures."), !1)
    }, add: async e => {
        ze || Ba();
        const t = [];
        for (const s in ze) !ze[s] || t.push(s);
        return [...t, ...e]
    }, remove: async e => (ze || Ba(), e.filter(t => !(t in ze)))
};
O.add(Da);

class Fa extends Oe {
    constructor(t, s = {width: 1, height: 1, autoLoad: !0}) {
        let i, r;
        typeof t == "string" ? (i = t, r = new Uint8Array) : (i = null, r = t), super(r, s), this.origin = i, this.buffer = r ? new Ws(r) : null, this.origin && s.autoLoad !== !1 && this.load(), r != null && r.length && (this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData))
    }

    onBlobLoaded(t) {
    }

    async load() {
        const i = await (await (await fetch(this.origin)).blob()).arrayBuffer();
        return this.data = new Uint32Array(i), this.buffer = new Ws(i), this.loaded = !0, this.onBlobLoaded(i), this.update(), this
    }
}

class me extends Fa {
    constructor(t, s) {
        super(t, s), this.format = s.format, this.levels = s.levels || 1, this._width = s.width, this._height = s.height, this._extension = me._formatToExtension(this.format), (s.levelBuffers || this.buffer) && (this._levelBuffers = s.levelBuffers || me._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }

    upload(t, s, i) {
        const r = t.gl;
        if (!t.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers) return !1;
        for (let o = 0, a = this.levels; o < a; o++) {
            const {levelID: h, levelWidth: l, levelHeight: c, levelBuffer: u} = this._levelBuffers[o];
            r.compressedTexImage2D(r.TEXTURE_2D, h, this.format, l, c, 0, u)
        }
        return !0
    }

    onBlobLoaded() {
        this._levelBuffers = me._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }

    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779) return "s3tc";
        if (t >= 37488 && t <= 37497) return "etc";
        if (t >= 35840 && t <= 35843) return "pvrtc";
        if (t >= 36196) return "etc1";
        if (t >= 35986 && t <= 34798) return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }

    static _createLevelBuffers(t, s, i, r, n, o, a) {
        const h = new Array(i);
        let l = t.byteOffset, c = o, u = a, d = c + r - 1 & ~(r - 1), f = u + n - 1 & ~(n - 1), p = d * f * _s[s];
        for (let _ = 0; _ < i; _++) h[_] = {
            levelID: _,
            levelWidth: i > 1 ? c : d,
            levelHeight: i > 1 ? u : f,
            levelBuffer: new Uint8Array(t.buffer, l, p)
        }, l += p, c = c >> 1 || 1, u = u >> 1 || 1, d = c + r - 1 & ~(r - 1), f = u + n - 1 & ~(n - 1), p = d * f * _s[s];
        return h
    }
}

const ln = 4, mi = 124, kf = 32, Na = 20, Gf = 542327876,
    _i = {SIZE: 1, FLAGS: 2, HEIGHT: 3, WIDTH: 4, MIPMAP_COUNT: 7, PIXEL_FORMAT: 19},
    Hf = {SIZE: 0, FLAGS: 1, FOURCC: 2, RGB_BITCOUNT: 3, R_BIT_MASK: 4, G_BIT_MASK: 5, B_BIT_MASK: 6, A_BIT_MASK: 7},
    gi = {DXGI_FORMAT: 0, RESOURCE_DIMENSION: 1, MISC_FLAG: 2, ARRAY_SIZE: 3, MISC_FLAGS2: 4};
var Xf = (e => (e[e.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", e[e.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", e[e.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", e[e.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", e[e.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", e[e.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", e[e.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", e[e.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", e[e.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", e[e.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", e[e.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", e[e.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", e[e.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", e[e.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", e[e.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", e[e.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", e[e.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", e[e.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", e[e.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", e[e.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", e[e.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", e[e.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", e[e.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", e[e.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", e[e.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", e[e.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", e[e.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", e[e.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", e[e.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", e[e.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", e[e.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", e[e.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", e[e.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", e[e.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", e[e.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", e[e.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", e[e.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", e[e.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", e[e.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", e[e.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", e[e.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", e[e.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", e[e.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", e[e.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", e[e.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", e[e.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", e[e.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", e[e.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", e[e.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", e[e.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", e[e.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", e[e.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", e[e.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", e[e.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", e[e.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", e[e.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", e[e.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", e[e.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", e[e.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", e[e.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", e[e.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", e[e.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", e[e.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", e[e.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", e[e.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", e[e.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", e[e.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", e[e.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", e[e.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", e[e.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", e[e.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", e[e.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", e[e.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", e[e.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", e[e.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", e[e.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", e[e.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", e[e.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", e[e.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", e[e.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", e[e.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", e[e.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", e[e.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", e[e.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", e[e.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", e[e.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", e[e.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", e[e.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", e[e.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", e[e.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", e[e.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", e[e.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", e[e.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", e[e.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", e[e.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", e[e.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", e[e.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", e[e.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", e[e.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", e[e.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", e[e.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV",e[e.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410",e[e.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416",e[e.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12",e[e.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010",e[e.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016",e[e.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE",e[e.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2",e[e.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210",e[e.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216",e[e.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11",e[e.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44",e[e.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44",e[e.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8",e[e.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8",e[e.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM",e[e.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208",e[e.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208",e[e.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408",e[e.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE",e[e.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE",e[e.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT",e))(Xf || {}),
    Vf = (e => (e[e.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", e[e.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", e[e.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D", e))(Vf || {});
const zf = 1, Wf = 2, jf = 4, $f = 64, Yf = 512, qf = 131072, Kf = 827611204, Zf = 861165636, Qf = 894720068,
    Jf = 808540228, tp = 4, ep = {
        [Kf]: Et.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [Zf]: Et.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [Qf]: Et.COMPRESSED_RGBA_S3TC_DXT5_EXT
    }, sp = {
        [70]: Et.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [71]: Et.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [73]: Et.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [74]: Et.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [76]: Et.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [77]: Et.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [72]: Et.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        [75]: Et.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        [78]: Et.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    };

function La(e) {
    const t = new Uint32Array(e);
    if (t[0] !== Gf) throw new Error("Invalid DDS file magic word");
    const i = new Uint32Array(e, 0, mi / Uint32Array.BYTES_PER_ELEMENT), r = i[_i.HEIGHT], n = i[_i.WIDTH],
        o = i[_i.MIPMAP_COUNT],
        a = new Uint32Array(e, _i.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, kf / Uint32Array.BYTES_PER_ELEMENT),
        h = a[zf];
    if (h & jf) {
        const l = a[Hf.FOURCC];
        if (l !== Jf) {
            const g = ep[l], v = ln + mi, A = new Uint8Array(e, v);
            return [new me(A, {format: g, width: n, height: r, levels: o})]
        }
        const c = ln + mi, u = new Uint32Array(t.buffer, c, Na / Uint32Array.BYTES_PER_ELEMENT), d = u[gi.DXGI_FORMAT],
            f = u[gi.RESOURCE_DIMENSION], p = u[gi.MISC_FLAG], _ = u[gi.ARRAY_SIZE], m = sp[d];
        if (m === void 0) throw new Error(`DDSParser cannot parse texture data with DXGI format ${d}`);
        if (p === tp) throw new Error("DDSParser does not support cubemap textures");
        if (f === 6) throw new Error("DDSParser does not supported 3D texture data");
        const x = new Array, y = ln + mi + Na;
        if (_ === 1) x.push(new Uint8Array(e, y)); else {
            const g = _s[m];
            let v = 0, A = n, P = r;
            for (let b = 0; b < o; b++) {
                const L = Math.max(1, A + 3 & -4), G = Math.max(1, P + 3 & -4);
                v += L * G * g, A = A >>> 1, P = P >>> 1
            }
            let S = y;
            for (let b = 0; b < _; b++) x.push(new Uint8Array(e, S, v)), S += v
        }
        return x.map(g => new me(g, {format: m, width: n, height: r, levels: o}))
    }
    throw h & $f ? new Error("DDSParser does not support uncompressed texture data.") : h & Yf ? new Error("DDSParser does not supported YUV uncompressed texture data.") : h & qf ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : h & Wf ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}

const Oa = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], ip = 67305985, Vt = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    }, cn = 64, un = {
        [U.UNSIGNED_BYTE]: 1,
        [U.UNSIGNED_SHORT]: 2,
        [U.INT]: 4,
        [U.UNSIGNED_INT]: 4,
        [U.FLOAT]: 4,
        [U.HALF_FLOAT]: 8
    }, Ua = {[R.RGBA]: 4, [R.RGB]: 3, [R.RG]: 2, [R.RED]: 1, [R.LUMINANCE]: 1, [R.LUMINANCE_ALPHA]: 2, [R.ALPHA]: 1},
    ka = {[U.UNSIGNED_SHORT_4_4_4_4]: 2, [U.UNSIGNED_SHORT_5_5_5_1]: 2, [U.UNSIGNED_SHORT_5_6_5]: 2};

function Ga(e, t, s = !1) {
    const i = new DataView(t);
    if (!rp(e, i)) return null;
    const r = i.getUint32(Vt.ENDIANNESS, !0) === ip, n = i.getUint32(Vt.GL_TYPE, r), o = i.getUint32(Vt.GL_FORMAT, r),
        a = i.getUint32(Vt.GL_INTERNAL_FORMAT, r), h = i.getUint32(Vt.PIXEL_WIDTH, r),
        l = i.getUint32(Vt.PIXEL_HEIGHT, r) || 1, c = i.getUint32(Vt.PIXEL_DEPTH, r) || 1,
        u = i.getUint32(Vt.NUMBER_OF_ARRAY_ELEMENTS, r) || 1, d = i.getUint32(Vt.NUMBER_OF_FACES, r),
        f = i.getUint32(Vt.NUMBER_OF_MIPMAP_LEVELS, r), p = i.getUint32(Vt.BYTES_OF_KEY_VALUE_DATA, r);
    if (l === 0 || c !== 1) throw new Error("Only 2D textures are supported");
    if (d !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (u !== 1) throw new Error("WebGL does not support array textures");
    const _ = 4, m = 4, x = h + 3 & -4, y = l + 3 & -4, g = new Array(u);
    let v = h * l;
    n === 0 && (v = x * y);
    let A;
    if (n !== 0 ? un[n] ? A = un[n] * Ua[o] : A = ka[n] : A = _s[a], A === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const P = s ? op(i, p, r) : null;
    let b = v * A, L = h, G = l, C = x, F = y, E = cn + p;
    for (let T = 0; T < f; T++) {
        const V = i.getUint32(E, r);
        let W = E + 4;
        for (let D = 0; D < u; D++) {
            let q = g[D];
            q || (q = g[D] = new Array(f)), q[T] = {
                levelID: T,
                levelWidth: f > 1 || n !== 0 ? L : C,
                levelHeight: f > 1 || n !== 0 ? G : F,
                levelBuffer: new Uint8Array(t, W, b)
            }, W += b
        }
        E += V + 4, E = E % 4 !== 0 ? E + 4 - E % 4 : E, L = L >> 1 || 1, G = G >> 1 || 1, C = L + _ - 1 & ~(_ - 1), F = G + m - 1 & ~(m - 1), b = C * F * A
    }
    return n !== 0 ? {
        uncompressed: g.map(T => {
            let V = T[0].levelBuffer, W = !1;
            return n === U.FLOAT ? V = new Float32Array(T[0].levelBuffer.buffer, T[0].levelBuffer.byteOffset, T[0].levelBuffer.byteLength / 4) : n === U.UNSIGNED_INT ? (W = !0, V = new Uint32Array(T[0].levelBuffer.buffer, T[0].levelBuffer.byteOffset, T[0].levelBuffer.byteLength / 4)) : n === U.INT && (W = !0, V = new Int32Array(T[0].levelBuffer.buffer, T[0].levelBuffer.byteOffset, T[0].levelBuffer.byteLength / 4)), {
                resource: new Oe(V, {
                    width: T[0].levelWidth,
                    height: T[0].levelHeight
                }), type: n, format: W ? np(o) : o
            }
        }), kvData: P
    } : {compressed: g.map(T => new me(null, {format: a, width: h, height: l, levels: f, levelBuffers: T})), kvData: P}
}

function rp(e, t) {
    for (let s = 0; s < Oa.length; s++) if (t.getUint8(s) !== Oa[s]) return console.error(`${e} is not a valid *.ktx file!`), !1;
    return !0
}

function np(e) {
    switch (e) {
        case R.RGBA:
            return R.RGBA_INTEGER;
        case R.RGB:
            return R.RGB_INTEGER;
        case R.RG:
            return R.RG_INTEGER;
        case R.RED:
            return R.RED_INTEGER;
        default:
            return e
    }
}

function op(e, t, s) {
    const i = new Map;
    let r = 0;
    for (; r < t;) {
        const n = e.getUint32(cn + r, s), o = cn + r + 4, a = 3 - (n + 3) % 4;
        if (n === 0 || n > t - r) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let h = 0;
        for (; h < n && e.getUint8(o + h) !== 0; h++) ;
        if (h === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const l = new TextDecoder().decode(new Uint8Array(e.buffer, o, h)),
            c = new DataView(e.buffer, o + h + 1, n - h - 1);
        i.set(l, c), r += 4 + n + a
    }
    return i
}

const Ha = {
    extension: {type: I.LoadParser, priority: Xt.High}, test(e) {
        return ds(e, ".dds")
    }, async load(e, t, s) {
        const r = await (await M.ADAPTER.fetch(e)).arrayBuffer(), o = La(r).map(a => {
            const h = new X(a, Yt({mipmap: Lt.OFF, alphaMode: Ct.NO_PREMULTIPLIED_ALPHA, resolution: ee(e)}, t.data));
            return ps(h, s, e)
        });
        return o.length === 1 ? o[0] : o
    }, unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
O.add(Ha);
const Xa = {
    extension: {type: I.LoadParser, priority: Xt.High}, test(e) {
        return ds(e, ".ktx")
    }, async load(e, t, s) {
        const r = await (await M.ADAPTER.fetch(e)).arrayBuffer(), {
                compressed: n,
                uncompressed: o,
                kvData: a
            } = Ga(e, r), h = n != null ? n : o,
            l = Yt({mipmap: Lt.OFF, alphaMode: Ct.NO_PREMULTIPLIED_ALPHA, resolution: ee(e)}, t.data), c = h.map(u => {
                h === o && Object.assign(l, {type: u.type, format: u.format});
                const d = new X(u, l);
                return d.ktxKeyValueData = a, ps(d, s, e)
            });
        return c.length === 1 ? c[0] : c
    }, unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
O.add(Xa);
const Va = {
    extension: I.ResolveParser, test: e => {
        const s = e.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(s)
    }, parse: e => {
        var i, r, n, o;
        if (e.split("?")[0].split(".").pop() === "ktx") {
            const a = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (a.some(h => e.endsWith(h))) return {
                resolution: parseFloat((r = (i = M.RETINA_PREFIX.exec(e)) == null ? void 0 : i[1]) != null ? r : "1"),
                format: a.find(h => e.endsWith(h)),
                src: e
            }
        }
        return {
            resolution: parseFloat((o = (n = M.RETINA_PREFIX.exec(e)) == null ? void 0 : n[1]) != null ? o : "1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
O.add(Va);
const ap = new z, hp = 4, dn = class {
    constructor(e) {
        this.renderer = e
    }

    async image(e, t, s) {
        const i = new Image;
        return i.src = await this.base64(e, t, s), i
    }

    async base64(e, t, s) {
        const i = this.canvas(e);
        if (i.toDataURL !== void 0) return i.toDataURL(t, s);
        if (i.convertToBlob !== void 0) {
            const r = await i.convertToBlob({type: t, quality: s});
            return await new Promise(n => {
                const o = new FileReader;
                o.onload = () => n(o.result), o.readAsDataURL(r)
            })
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
    }

    canvas(e, t) {
        const {pixels: s, width: i, height: r, flipY: n} = this._rawPixels(e, t);
        let o = new sr(i, r, 1);
        const a = o.context.getImageData(0, 0, i, r);
        if (dn.arrayPostDivide(s, a.data), o.context.putImageData(a, 0, 0), n) {
            const h = new sr(o.width, o.height, 1);
            h.context.scale(1, -1), h.context.drawImage(o.canvas, 0, -r), o.destroy(), o = h
        }
        return o.canvas
    }

    pixels(e, t) {
        const {pixels: s} = this._rawPixels(e, t);
        return dn.arrayPostDivide(s, s), s
    }

    _rawPixels(e, t) {
        const s = this.renderer;
        let i, r = !1, n, o = !1;
        if (e) if (e instanceof oe) n = e; else {
            const u = s.context.webGLVersion >= 2 ? s.multisample : st.NONE;
            if (n = this.renderer.generateTexture(e, {multisample: u}), u !== st.NONE) {
                const d = oe.create({width: n.width, height: n.height});
                s.framebuffer.bind(n.framebuffer), s.framebuffer.blit(d.framebuffer), s.framebuffer.bind(null), n.destroy(!0), n = d
            }
            o = !0
        }
        n ? (i = n.baseTexture.resolution, t = t != null ? t : n.frame, r = !1, s.renderTexture.bind(n)) : (i = s.resolution, t || (t = ap, t.width = s.width, t.height = s.height), r = !0, s.renderTexture.bind(null));
        const a = Math.round(t.width * i), h = Math.round(t.height * i), l = new Uint8Array(hp * a * h), c = s.gl;
        return c.readPixels(Math.round(t.x * i), Math.round(t.y * i), a, h, c.RGBA, c.UNSIGNED_BYTE, l), o && n.destroy(!0), {
            pixels: l,
            width: a,
            height: h,
            flipY: r
        }
    }

    destroy() {
        this.renderer = null
    }

    static arrayPostDivide(e, t) {
        for (let s = 0; s < e.length; s += 4) {
            const i = t[s + 3] = e[s + 3];
            i !== 0 ? (t[s] = Math.round(Math.min(e[s] * 255 / i, 255)), t[s + 1] = Math.round(Math.min(e[s + 1] * 255 / i, 255)), t[s + 2] = Math.round(Math.min(e[s + 2] * 255 / i, 255))) : (t[s] = e[s], t[s + 1] = e[s + 1], t[s + 2] = e[s + 2])
        }
    }
};
let fn = dn;
fn.extension = {name: "extract", type: I.RendererSystem}, O.add(fn);
const gs = {
    build(e) {
        const t = e.points;
        let s, i, r, n, o, a;
        if (e.type === pt.CIRC) {
            const p = e.shape;
            s = p.x, i = p.y, o = a = p.radius, r = n = 0
        } else if (e.type === pt.ELIP) {
            const p = e.shape;
            s = p.x, i = p.y, o = p.width, a = p.height, r = n = 0
        } else {
            const p = e.shape, _ = p.width / 2, m = p.height / 2;
            s = p.x + _, i = p.y + m, o = a = Math.max(0, Math.min(p.radius, Math.min(_, m))), r = _ - o, n = m - a
        }
        if (!(o >= 0 && a >= 0 && r >= 0 && n >= 0)) {
            t.length = 0;
            return
        }
        const h = Math.ceil(2.3 * Math.sqrt(o + a)), l = h * 8 + (r ? 4 : 0) + (n ? 4 : 0);
        if (t.length = l, l === 0) return;
        if (h === 0) {
            t.length = 8, t[0] = t[6] = s + r, t[1] = t[3] = i + n, t[2] = t[4] = s - r, t[5] = t[7] = i - n;
            return
        }
        let c = 0, u = h * 4 + (r ? 2 : 0) + 2, d = u, f = l;
        {
            const p = r + o, _ = n, m = s + p, x = s - p, y = i + _;
            if (t[c++] = m, t[c++] = y, t[--u] = y, t[--u] = x, n) {
                const g = i - _;
                t[d++] = x, t[d++] = g, t[--f] = g, t[--f] = m
            }
        }
        for (let p = 1; p < h; p++) {
            const _ = Math.PI / 2 * (p / h), m = r + Math.cos(_) * o, x = n + Math.sin(_) * a, y = s + m, g = s - m,
                v = i + x, A = i - x;
            t[c++] = y, t[c++] = v, t[--u] = v, t[--u] = g, t[d++] = g, t[d++] = A, t[--f] = A, t[--f] = y
        }
        {
            const p = r, _ = n + a, m = s + p, x = s - p, y = i + _, g = i - _;
            t[c++] = m, t[c++] = y, t[--f] = g, t[--f] = m, r && (t[c++] = x, t[c++] = y, t[--f] = g, t[--f] = x)
        }
    }, triangulate(e, t) {
        const s = e.points, i = t.points, r = t.indices;
        if (s.length === 0) return;
        let n = i.length / 2;
        const o = n;
        let a, h;
        if (e.type !== pt.RREC) {
            const c = e.shape;
            a = c.x, h = c.y
        } else {
            const c = e.shape;
            a = c.x + c.width / 2, h = c.y + c.height / 2
        }
        const l = e.matrix;
        i.push(e.matrix ? l.a * a + l.c * h + l.tx : a, e.matrix ? l.b * a + l.d * h + l.ty : h), n++, i.push(s[0], s[1]);
        for (let c = 2; c < s.length; c += 2) i.push(s[c], s[c + 1]), r.push(n++, o, n);
        r.push(o + 1, o, n)
    }
};

function za(e, t = !1) {
    const s = e.length;
    if (s < 6) return;
    let i = 0;
    for (let r = 0, n = e[s - 2], o = e[s - 1]; r < s; r += 2) {
        const a = e[r], h = e[r + 1];
        i += (a - n) * (h + o), n = a, o = h
    }
    if (!t && i > 0 || t && i <= 0) {
        const r = s / 2;
        for (let n = r + r % 2; n < s; n += 2) {
            const o = s - n - 2, a = s - n - 1, h = n, l = n + 1;
            [e[o], e[h]] = [e[h], e[o]], [e[a], e[l]] = [e[l], e[a]]
        }
    }
}

const pn = {
    build(e) {
        e.points = e.shape.points.slice()
    }, triangulate(e, t) {
        let s = e.points;
        const i = e.holes, r = t.points, n = t.indices;
        if (s.length >= 6) {
            za(s, !1);
            const o = [];
            for (let l = 0; l < i.length; l++) {
                const c = i[l];
                za(c.points, !0), o.push(s.length / 2), s = s.concat(c.points)
            }
            const a = Hi(s, o, 2);
            if (!a) return;
            const h = r.length / 2;
            for (let l = 0; l < a.length; l += 3) n.push(a[l] + h), n.push(a[l + 1] + h), n.push(a[l + 2] + h);
            for (let l = 0; l < s.length; l++) r.push(s[l])
        }
    }
}, Wa = {
    build(e) {
        const t = e.shape, s = t.x, i = t.y, r = t.width, n = t.height, o = e.points;
        o.length = 0, r >= 0 && n >= 0 && o.push(s, i, s + r, i, s + r, i + n, s, i + n)
    }, triangulate(e, t) {
        const s = e.points, i = t.points;
        if (s.length === 0) return;
        const r = i.length / 2;
        i.push(s[0], s[1], s[2], s[3], s[6], s[7], s[4], s[5]), t.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3)
    }
}, ja = {
    build(e) {
        gs.build(e)
    }, triangulate(e, t) {
        gs.triangulate(e, t)
    }
};
var re = (e => (e.MITER = "miter", e.BEVEL = "bevel", e.ROUND = "round", e))(re || {}),
    ue = (e => (e.BUTT = "butt", e.ROUND = "round", e.SQUARE = "square", e))(ue || {});
const de = {
    adaptive: !0, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount(e, t = 20) {
        if (!this.adaptive || !e || isNaN(e)) return t;
        let s = Math.ceil(e / this.maxLength);
        return s < this.minSegments ? s = this.minSegments : s > this.maxSegments && (s = this.maxSegments), s
    }
}, lp = de;

class mn {
    static curveTo(t, s, i, r, n, o) {
        const a = o[o.length - 2], l = o[o.length - 1] - s, c = a - t, u = r - s, d = i - t,
            f = Math.abs(l * d - c * u);
        if (f < 1e-8 || n === 0) return (o[o.length - 2] !== t || o[o.length - 1] !== s) && o.push(t, s), null;
        const p = l * l + c * c, _ = u * u + d * d, m = l * u + c * d, x = n * Math.sqrt(p) / f,
            y = n * Math.sqrt(_) / f, g = x * m / p, v = y * m / _, A = x * d + y * c, P = x * u + y * l,
            S = c * (y + g), b = l * (y + g), L = d * (x + v), G = u * (x + v), C = Math.atan2(b - P, S - A),
            F = Math.atan2(G - P, L - A);
        return {cx: A + t, cy: P + s, radius: n, startAngle: C, endAngle: F, anticlockwise: c * u > d * l}
    }

    static arc(t, s, i, r, n, o, a, h, l) {
        const c = a - o, u = de._segmentsCount(Math.abs(c) * n, Math.ceil(Math.abs(c) / ss) * 40), d = c / (u * 2),
            f = d * 2, p = Math.cos(d), _ = Math.sin(d), m = u - 1, x = m % 1 / m;
        for (let y = 0; y <= m; ++y) {
            const g = y + x * y, v = d + o + f * g, A = Math.cos(v), P = -Math.sin(v);
            l.push((p * A + _ * P) * n + i, (p * -P + _ * A) * n + r)
        }
    }
}

class $a {
    constructor() {
        this.reset()
    }

    begin(t, s, i) {
        this.reset(), this.style = t, this.start = s, this.attribStart = i
    }

    end(t, s) {
        this.attribSize = s - this.attribStart, this.size = t - this.start
    }

    reset() {
        this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
    }
}

class Mi {
    static curveLength(t, s, i, r, n, o, a, h) {
        let c = 0, u = 0, d = 0, f = 0, p = 0, _ = 0, m = 0, x = 0, y = 0, g = 0, v = 0, A = t, P = s;
        for (let S = 1; S <= 10; ++S) u = S / 10, d = u * u, f = d * u, p = 1 - u, _ = p * p, m = _ * p, x = m * t + 3 * _ * u * i + 3 * p * d * n + f * a, y = m * s + 3 * _ * u * r + 3 * p * d * o + f * h, g = A - x, v = P - y, A = x, P = y, c += Math.sqrt(g * g + v * v);
        return c
    }

    static curveTo(t, s, i, r, n, o, a) {
        const h = a[a.length - 2], l = a[a.length - 1];
        a.length -= 2;
        const c = de._segmentsCount(Mi.curveLength(h, l, t, s, i, r, n, o));
        let u = 0, d = 0, f = 0, p = 0, _ = 0;
        a.push(h, l);
        for (let m = 1, x = 0; m <= c; ++m) x = m / c, u = 1 - x, d = u * u, f = d * u, p = x * x, _ = p * x, a.push(f * h + 3 * d * x * t + 3 * u * p * i + _ * n, f * l + 3 * d * x * s + 3 * u * p * r + _ * o)
    }
}

function Ya(e, t, s, i, r, n, o, a) {
    const h = e - s * r, l = t - i * r, c = e + s * n, u = t + i * n;
    let d, f;
    o ? (d = i, f = -s) : (d = -i, f = s);
    const p = h + d, _ = l + f, m = c + d, x = u + f;
    return a.push(p, _), a.push(m, x), 2
}

function Ce(e, t, s, i, r, n, o, a) {
    const h = s - e, l = i - t;
    let c = Math.atan2(h, l), u = Math.atan2(r - e, n - t);
    a && c < u ? c += Math.PI * 2 : !a && c > u && (u += Math.PI * 2);
    let d = c;
    const f = u - c, p = Math.abs(f), _ = Math.sqrt(h * h + l * l), m = (15 * p * Math.sqrt(_) / Math.PI >> 0) + 1,
        x = f / m;
    if (d += x, a) {
        o.push(e, t), o.push(s, i);
        for (let y = 1, g = d; y < m; y++, g += x) o.push(e, t), o.push(e + Math.sin(g) * _, t + Math.cos(g) * _);
        o.push(e, t), o.push(r, n)
    } else {
        o.push(s, i), o.push(e, t);
        for (let y = 1, g = d; y < m; y++, g += x) o.push(e + Math.sin(g) * _, t + Math.cos(g) * _), o.push(e, t);
        o.push(r, n), o.push(e, t)
    }
    return m * 2
}

function cp(e, t) {
    const s = e.shape;
    let i = e.points || s.points.slice();
    const r = t.closePointEps;
    if (i.length === 0) return;
    const n = e.lineStyle, o = new j(i[0], i[1]), a = new j(i[i.length - 2], i[i.length - 1]),
        h = s.type !== pt.POLY || s.closeStroke, l = Math.abs(o.x - a.x) < r && Math.abs(o.y - a.y) < r;
    if (h) {
        i = i.slice(), l && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1]));
        const D = (o.x + a.x) * .5, q = (a.y + o.y) * .5;
        i.unshift(D, q), i.push(D, q)
    }
    const c = t.points, u = i.length / 2;
    let d = i.length;
    const f = c.length / 2, p = n.width / 2, _ = p * p, m = n.miterLimit * n.miterLimit;
    let x = i[0], y = i[1], g = i[2], v = i[3], A = 0, P = 0, S = -(y - v), b = x - g, L = 0, G = 0,
        C = Math.sqrt(S * S + b * b);
    S /= C, b /= C, S *= p, b *= p;
    const F = n.alignment, E = (1 - F) * 2, T = F * 2;
    h || (n.cap === ue.ROUND ? d += Ce(x - S * (E - T) * .5, y - b * (E - T) * .5, x - S * E, y - b * E, x + S * T, y + b * T, c, !0) + 2 : n.cap === ue.SQUARE && (d += Ya(x, y, S, b, E, T, !0, c))), c.push(x - S * E, y - b * E), c.push(x + S * T, y + b * T);
    for (let D = 1; D < u - 1; ++D) {
        x = i[(D - 1) * 2], y = i[(D - 1) * 2 + 1], g = i[D * 2], v = i[D * 2 + 1], A = i[(D + 1) * 2], P = i[(D + 1) * 2 + 1], S = -(y - v), b = x - g, C = Math.sqrt(S * S + b * b), S /= C, b /= C, S *= p, b *= p, L = -(v - P), G = g - A, C = Math.sqrt(L * L + G * G), L /= C, G /= C, L *= p, G *= p;
        const q = g - x, rt = y - v, w = g - A, H = P - v, $ = q * w + rt * H, K = rt * w - H * q, Z = K < 0;
        if (Math.abs(K) < .001 * Math.abs($)) {
            c.push(g - S * E, v - b * E), c.push(g + S * T, v + b * T), $ >= 0 && (n.join === re.ROUND ? d += Ce(g, v, g - S * E, v - b * E, g - L * E, v - G * E, c, !1) + 4 : d += 2, c.push(g - L * T, v - G * T), c.push(g + L * E, v + G * E));
            continue
        }
        const ut = (-S + x) * (-b + v) - (-S + g) * (-b + y), ot = (-L + A) * (-G + v) - (-L + g) * (-G + P),
            dt = (q * ot - w * ut) / K, xt = (H * ut - rt * ot) / K, Tt = (dt - g) * (dt - g) + (xt - v) * (xt - v),
            gt = g + (dt - g) * E, J = v + (xt - v) * E, at = g - (dt - g) * T, lt = v - (xt - v) * T,
            jt = Math.min(q * q + rt * rt, w * w + H * H), $t = Z ? E : T, Ye = jt + $t * $t * _;
        Tt <= Ye ? n.join === re.BEVEL || Tt / _ > m ? (Z ? (c.push(gt, J), c.push(g + S * T, v + b * T), c.push(gt, J), c.push(g + L * T, v + G * T)) : (c.push(g - S * E, v - b * E), c.push(at, lt), c.push(g - L * E, v - G * E), c.push(at, lt)), d += 2) : n.join === re.ROUND ? Z ? (c.push(gt, J), c.push(g + S * T, v + b * T), d += Ce(g, v, g + S * T, v + b * T, g + L * T, v + G * T, c, !0) + 4, c.push(gt, J), c.push(g + L * T, v + G * T)) : (c.push(g - S * E, v - b * E), c.push(at, lt), d += Ce(g, v, g - S * E, v - b * E, g - L * E, v - G * E, c, !1) + 4, c.push(g - L * E, v - G * E), c.push(at, lt)) : (c.push(gt, J), c.push(at, lt)) : (c.push(g - S * E, v - b * E), c.push(g + S * T, v + b * T), n.join === re.ROUND ? Z ? d += Ce(g, v, g + S * T, v + b * T, g + L * T, v + G * T, c, !0) + 2 : d += Ce(g, v, g - S * E, v - b * E, g - L * E, v - G * E, c, !1) + 2 : n.join === re.MITER && Tt / _ <= m && (Z ? (c.push(at, lt), c.push(at, lt)) : (c.push(gt, J), c.push(gt, J)), d += 2), c.push(g - L * E, v - G * E), c.push(g + L * T, v + G * T), d += 2)
    }
    x = i[(u - 2) * 2], y = i[(u - 2) * 2 + 1], g = i[(u - 1) * 2], v = i[(u - 1) * 2 + 1], S = -(y - v), b = x - g, C = Math.sqrt(S * S + b * b), S /= C, b /= C, S *= p, b *= p, c.push(g - S * E, v - b * E), c.push(g + S * T, v + b * T), h || (n.cap === ue.ROUND ? d += Ce(g - S * (E - T) * .5, v - b * (E - T) * .5, g - S * E, v - b * E, g + S * T, v + b * T, c, !1) + 2 : n.cap === ue.SQUARE && (d += Ya(g, v, S, b, E, T, !1, c)));
    const V = t.indices, W = de.epsilon * de.epsilon;
    for (let D = f; D < d + f - 2; ++D) x = c[D * 2], y = c[D * 2 + 1], g = c[(D + 1) * 2], v = c[(D + 1) * 2 + 1], A = c[(D + 2) * 2], P = c[(D + 2) * 2 + 1], !(Math.abs(x * (v - P) + g * (P - y) + A * (y - v)) < W) && V.push(D, D + 1, D + 2)
}

function up(e, t) {
    let s = 0;
    const i = e.shape, r = e.points || i.points, n = i.type !== pt.POLY || i.closeStroke;
    if (r.length === 0) return;
    const o = t.points, a = t.indices, h = r.length / 2, l = o.length / 2;
    let c = l;
    for (o.push(r[0], r[1]), s = 1; s < h; s++) o.push(r[s * 2], r[s * 2 + 1]), a.push(c, c + 1), c++;
    n && a.push(c, l)
}

function _n(e, t) {
    e.lineStyle.native ? up(e, t) : cp(e, t)
}

class Bi {
    static curveLength(t, s, i, r, n, o) {
        const a = t - 2 * i + n, h = s - 2 * r + o, l = 2 * i - 2 * t, c = 2 * r - 2 * s, u = 4 * (a * a + h * h),
            d = 4 * (a * l + h * c), f = l * l + c * c, p = 2 * Math.sqrt(u + d + f), _ = Math.sqrt(u), m = 2 * u * _,
            x = 2 * Math.sqrt(f), y = d / _;
        return (m * p + _ * d * (p - x) + (4 * f * u - d * d) * Math.log((2 * _ + y + p) / (y + x))) / (4 * m)
    }

    static curveTo(t, s, i, r, n) {
        const o = n[n.length - 2], a = n[n.length - 1], h = de._segmentsCount(Bi.curveLength(o, a, t, s, i, r));
        let l = 0, c = 0;
        for (let u = 1; u <= h; ++u) {
            const d = u / h;
            l = o + (t - o) * d, c = a + (s - a) * d, n.push(l + (t + (i - t) * d - l) * d, c + (s + (r - s) * d - c) * d)
        }
    }
}

const xi = {[pt.POLY]: pn, [pt.CIRC]: gs, [pt.ELIP]: gs, [pt.RECT]: Wa, [pt.RREC]: ja}, gn = [], xs = [];

class Is {
    constructor(t, s = null, i = null, r = null) {
        this.points = [], this.holes = [], this.shape = t, this.lineStyle = i, this.fillStyle = s, this.matrix = r, this.type = t.type
    }

    clone() {
        return new Is(this.shape, this.fillStyle, this.lineStyle, this.matrix)
    }

    destroy() {
        this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
    }
}

const We = new j, qa = class extends ur {
    constructor() {
        super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new ls, this.boundsDirty = -1
    }

    get bounds() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
    }

    invalidate() {
        this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
        for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), xs.push(this.drawCalls[e]);
        this.drawCalls.length = 0;
        for (let e = 0; e < this.batches.length; e++) {
            const t = this.batches[e];
            t.reset(), gn.push(t)
        }
        this.batches.length = 0
    }

    clear() {
        return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
    }

    drawShape(e, t = null, s = null, i = null) {
        const r = new Is(e, t, s, i);
        return this.graphicsData.push(r), this.dirty++, this
    }

    drawHole(e, t = null) {
        if (!this.graphicsData.length) return null;
        const s = new Is(e, null, null, t), i = this.graphicsData[this.graphicsData.length - 1];
        return s.lineStyle = i.lineStyle, i.holes.push(s), this.dirty++, this
    }

    destroy() {
        super.destroy();
        for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
        this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
    }

    containsPoint(e) {
        const t = this.graphicsData;
        for (let s = 0; s < t.length; ++s) {
            const i = t[s];
            if (!!i.fillStyle.visible && i.shape && (i.matrix ? i.matrix.applyInverse(e, We) : We.copyFrom(e), i.shape.contains(We.x, We.y))) {
                let r = !1;
                if (i.holes) {
                    for (let n = 0; n < i.holes.length; n++) if (i.holes[n].shape.contains(We.x, We.y)) {
                        r = !0;
                        break
                    }
                }
                if (!r) return !0
            }
        }
        return !1
    }

    updateBatches() {
        if (!this.graphicsData.length) {
            this.batchable = !0;
            return
        }
        if (!this.validateBatching()) return;
        this.cacheDirty = this.dirty;
        const e = this.uvs, t = this.graphicsData;
        let s = null, i = null;
        this.batches.length > 0 && (s = this.batches[this.batches.length - 1], i = s.style);
        for (let a = this.shapeIndex; a < t.length; a++) {
            this.shapeIndex++;
            const h = t[a], l = h.fillStyle, c = h.lineStyle;
            xi[h.type].build(h), h.matrix && this.transformPoints(h.points, h.matrix), (l.visible || c.visible) && this.processHoles(h.holes);
            for (let d = 0; d < 2; d++) {
                const f = d === 0 ? l : c;
                if (!f.visible) continue;
                const p = f.texture.baseTexture, _ = this.indices.length, m = this.points.length / 2;
                p.wrapMode = Kt.REPEAT, d === 0 ? this.processFill(h) : this.processLine(h);
                const x = this.points.length / 2 - m;
                x !== 0 && (s && !this._compareStyles(i, f) && (s.end(_, m), s = null), s || (s = gn.pop() || new $a, s.begin(f, _, m), this.batches.push(s), i = f), this.addUvs(this.points, e, f.texture, m, x, f.matrix))
            }
        }
        const r = this.indices.length, n = this.points.length / 2;
        if (s && s.end(r, n), this.batches.length === 0) {
            this.batchable = !0;
            return
        }
        const o = n > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
    }

    _compareStyles(e, t) {
        return !(!e || !t || e.texture.baseTexture !== t.texture.baseTexture || e.color + e.alpha !== t.color + t.alpha || !!e.native != !!t.native)
    }

    validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
        for (let e = 0, t = this.graphicsData.length; e < t; e++) {
            const s = this.graphicsData[e], i = s.fillStyle, r = s.lineStyle;
            if (i && !i.texture.baseTexture.valid || r && !r.texture.baseTexture.valid) return !1
        }
        return !0
    }

    packBatches() {
        this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
        const e = this.batches;
        for (let t = 0, s = e.length; t < s; t++) {
            const i = e[t];
            for (let r = 0; r < i.size; r++) {
                const n = i.start + r;
                this.indicesUint16[n] = this.indicesUint16[n] - i.attribStart
            }
        }
    }

    isBatchable() {
        if (this.points.length > 65535 * 2) return !1;
        const e = this.batches;
        for (let t = 0; t < e.length; t++) if (e[t].style.native) return !1;
        return this.points.length < qa.BATCHABLE_SIZE * 2
    }

    buildDrawCalls() {
        let e = ++X._globalBatch;
        for (let c = 0; c < this.drawCalls.length; c++) this.drawCalls[c].texArray.clear(), xs.push(this.drawCalls[c]);
        this.drawCalls.length = 0;
        const t = this.colors, s = this.textureIds;
        let i = xs.pop();
        i || (i = new $s, i.texArray = new Js), i.texArray.count = 0, i.start = 0, i.size = 0, i.type = Nt.TRIANGLES;
        let r = 0, n = null, o = 0, a = !1, h = Nt.TRIANGLES, l = 0;
        this.drawCalls.push(i);
        for (let c = 0; c < this.batches.length; c++) {
            const u = this.batches[c], d = 8, f = u.style, p = f.texture.baseTexture;
            a !== !!f.native && (a = !!f.native, h = a ? Nt.LINES : Nt.TRIANGLES, n = null, r = d, e++), n !== p && (n = p, p._batchEnabled !== e && (r === d && (e++, r = 0, i.size > 0 && (i = xs.pop(), i || (i = new $s, i.texArray = new Js), this.drawCalls.push(i)), i.start = l, i.size = 0, i.texArray.count = 0, i.type = h), p.touched = 1, p._batchEnabled = e, p._batchLocation = r, p.wrapMode = Kt.REPEAT, i.texArray.elements[i.texArray.count++] = p, r++)), i.size += u.size, l += u.size, o = p._batchLocation, this.addColors(t, f.color, f.alpha, u.attribSize, u.attribStart), this.addTextureIds(s, o, u.attribSize, u.attribStart)
        }
        X._globalBatch = e, this.packAttributes()
    }

    packAttributes() {
        const e = this.points, t = this.uvs, s = this.colors, i = this.textureIds,
            r = new ArrayBuffer(e.length * 3 * 4), n = new Float32Array(r), o = new Uint32Array(r);
        let a = 0;
        for (let h = 0; h < e.length / 2; h++) n[a++] = e[h * 2], n[a++] = e[h * 2 + 1], n[a++] = t[h * 2], n[a++] = t[h * 2 + 1], o[a++] = s[h], n[a++] = i[h];
        this._buffer.update(r), this._indexBuffer.update(this.indicesUint16)
    }

    processFill(e) {
        e.holes.length ? pn.triangulate(e, this) : xi[e.type].triangulate(e, this)
    }

    processLine(e) {
        _n(e, this);
        for (let t = 0; t < e.holes.length; t++) _n(e.holes[t], this)
    }

    processHoles(e) {
        for (let t = 0; t < e.length; t++) {
            const s = e[t];
            xi[s.type].build(s), s.matrix && this.transformPoints(s.points, s.matrix)
        }
    }

    calculateBounds() {
        const e = this._bounds;
        e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding)
    }

    transformPoints(e, t) {
        for (let s = 0; s < e.length / 2; s++) {
            const i = e[s * 2], r = e[s * 2 + 1];
            e[s * 2] = t.a * i + t.c * r + t.tx, e[s * 2 + 1] = t.b * i + t.d * r + t.ty
        }
    }

    addColors(e, t, s, i, r = 0) {
        const n = (t >> 16) + (t & 65280) + ((t & 255) << 16), o = Hs(n, s);
        e.length = Math.max(e.length, r + i);
        for (let a = 0; a < i; a++) e[r + a] = o
    }

    addTextureIds(e, t, s, i = 0) {
        e.length = Math.max(e.length, i + s);
        for (let r = 0; r < s; r++) e[i + r] = t
    }

    addUvs(e, t, s, i, r, n = null) {
        let o = 0;
        const a = t.length, h = s.frame;
        for (; o < r;) {
            let c = e[(i + o) * 2], u = e[(i + o) * 2 + 1];
            if (n) {
                const d = n.a * c + n.c * u + n.tx;
                u = n.b * c + n.d * u + n.ty, c = d
            }
            o++, t.push(c / h.width, u / h.height)
        }
        const l = s.baseTexture;
        (h.width < l.width || h.height < l.height) && this.adjustUvs(t, s, a, r)
    }

    adjustUvs(e, t, s, i) {
        const r = t.baseTexture, n = 1e-6, o = s + i * 2, a = t.frame, h = a.width / r.width, l = a.height / r.height;
        let c = a.x / a.width, u = a.y / a.height, d = Math.floor(e[s] + n), f = Math.floor(e[s + 1] + n);
        for (let p = s + 2; p < o; p += 2) d = Math.min(d, Math.floor(e[p] + n)), f = Math.min(f, Math.floor(e[p + 1] + n));
        c -= d, u -= f;
        for (let p = s; p < o; p += 2) e[p] = (e[p] + c) * h, e[p + 1] = (e[p + 1] + u) * l
    }
};
let xn = qa;
xn.BATCHABLE_SIZE = 100;

class Ps {
    constructor() {
        this.color = 16777215, this.alpha = 1, this.texture = B.WHITE, this.matrix = null, this.visible = !1, this.reset()
    }

    clone() {
        const t = new Ps;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t
    }

    reset() {
        this.color = 16777215, this.alpha = 1, this.texture = B.WHITE, this.matrix = null, this.visible = !1
    }

    destroy() {
        this.texture = null, this.matrix = null
    }
}

class Di extends Ps {
    constructor() {
        super(...arguments), this.width = 0, this.alignment = .5, this.native = !1, this.cap = ue.BUTT, this.join = re.MITER, this.miterLimit = 10
    }

    clone() {
        const t = new Di;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
    }

    reset() {
        super.reset(), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
    }
}

const dp = new Float32Array(3), vn = {}, vi = class extends bt {
    constructor(e = null) {
        super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new Ps, this._lineStyle = new Di, this._matrix = null, this._holeMode = !1, this.state = Jt.for2d(), this._geometry = e || new xn, this._geometry.refCount++, this._transformID = -1, this.tint = 16777215, this.blendMode = k.NORMAL
    }

    get geometry() {
        return this._geometry
    }

    clone() {
        return this.finishPoly(), new vi(this._geometry)
    }

    set blendMode(e) {
        this.state.blendMode = e
    }

    get blendMode() {
        return this.state.blendMode
    }

    get tint() {
        return this._tint
    }

    set tint(e) {
        this._tint = e
    }

    get fill() {
        return this._fillStyle
    }

    get line() {
        return this._lineStyle
    }

    lineStyle(e = null, t = 0, s = 1, i = .5, r = !1) {
        return typeof e == "number" && (e = {
            width: e,
            color: t,
            alpha: s,
            alignment: i,
            native: r
        }), this.lineTextureStyle(e)
    }

    lineTextureStyle(e) {
        e = Object.assign({
            width: 0,
            texture: B.WHITE,
            color: e != null && e.texture ? 16777215 : 0,
            alpha: 1,
            matrix: null,
            alignment: .5,
            native: !1,
            cap: ue.BUTT,
            join: re.MITER,
            miterLimit: 10
        }, e), this.currentPath && this.startPoly();
        const t = e.width > 0 && e.alpha > 0;
        return t ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, {visible: t}, e)) : this._lineStyle.reset(), this
    }

    startPoly() {
        if (this.currentPath) {
            const e = this.currentPath.points, t = this.currentPath.points.length;
            t > 2 && (this.drawShape(this.currentPath), this.currentPath = new Pe, this.currentPath.closeStroke = !1, this.currentPath.points.push(e[t - 2], e[t - 1]))
        } else this.currentPath = new Pe, this.currentPath.closeStroke = !1
    }

    finishPoly() {
        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
    }

    moveTo(e, t) {
        return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = t, this
    }

    lineTo(e, t) {
        this.currentPath || this.moveTo(0, 0);
        const s = this.currentPath.points, i = s[s.length - 2], r = s[s.length - 1];
        return (i !== e || r !== t) && s.push(e, t), this
    }

    _initCurve(e = 0, t = 0) {
        this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, t]) : this.moveTo(e, t)
    }

    quadraticCurveTo(e, t, s, i) {
        this._initCurve();
        const r = this.currentPath.points;
        return r.length === 0 && this.moveTo(0, 0), Bi.curveTo(e, t, s, i, r), this
    }

    bezierCurveTo(e, t, s, i, r, n) {
        return this._initCurve(), Mi.curveTo(e, t, s, i, r, n, this.currentPath.points), this
    }

    arcTo(e, t, s, i, r) {
        this._initCurve(e, t);
        const n = this.currentPath.points, o = mn.curveTo(e, t, s, i, r, n);
        if (o) {
            const {cx: a, cy: h, radius: l, startAngle: c, endAngle: u, anticlockwise: d} = o;
            this.arc(a, h, l, c, u, d)
        }
        return this
    }

    arc(e, t, s, i, r, n = !1) {
        if (i === r) return this;
        if (!n && r <= i ? r += ss : n && i <= r && (i += ss), r - i === 0) return this;
        const a = e + Math.cos(i) * s, h = t + Math.sin(i) * s, l = this._geometry.closePointEps;
        let c = this.currentPath ? this.currentPath.points : null;
        if (c) {
            const u = Math.abs(c[c.length - 2] - a), d = Math.abs(c[c.length - 1] - h);
            u < l && d < l || c.push(a, h)
        } else this.moveTo(a, h), c = this.currentPath.points;
        return mn.arc(a, h, e, t, s, i, r, n, c), this
    }

    beginFill(e = 0, t = 1) {
        return this.beginTextureFill({texture: B.WHITE, color: e, alpha: t})
    }

    beginTextureFill(e) {
        e = Object.assign({
            texture: B.WHITE,
            color: 16777215,
            alpha: 1,
            matrix: null
        }, e), this.currentPath && this.startPoly();
        const t = e.alpha > 0;
        return t ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, {visible: t}, e)) : this._fillStyle.reset(), this
    }

    endFill() {
        return this.finishPoly(), this._fillStyle.reset(), this
    }

    drawRect(e, t, s, i) {
        return this.drawShape(new z(e, t, s, i))
    }

    drawRoundedRect(e, t, s, i, r) {
        return this.drawShape(new Pi(e, t, s, i, r))
    }

    drawCircle(e, t, s) {
        return this.drawShape(new Ci(e, t, s))
    }

    drawEllipse(e, t, s, i) {
        return this.drawShape(new Ii(e, t, s, i))
    }

    drawPolygon(...e) {
        let t, s = !0;
        const i = e[0];
        i.points ? (s = i.closeStroke, t = i.points) : Array.isArray(e[0]) ? t = e[0] : t = e;
        const r = new Pe(t);
        return r.closeStroke = s, this.drawShape(r), this
    }

    drawShape(e) {
        return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
    }

    clear() {
        return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
    }

    isFastRect() {
        const e = this._geometry.graphicsData;
        return e.length === 1 && e[0].shape.type === pt.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width)
    }

    _render(e) {
        this.finishPoly();
        const t = this._geometry;
        t.updateBatches(), t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e))
    }

    _populateBatches() {
        const e = this._geometry, t = this.blendMode, s = e.batches.length;
        this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = s, this.vertexData = new Float32Array(e.points);
        for (let i = 0; i < s; i++) {
            const r = e.batches[i], n = r.style.color,
                o = new Float32Array(this.vertexData.buffer, r.attribStart * 4 * 2, r.attribSize * 2),
                a = new Float32Array(e.uvsFloat32.buffer, r.attribStart * 4 * 2, r.attribSize * 2),
                h = new Uint16Array(e.indicesUint16.buffer, r.start * 2, r.size), l = {
                    vertexData: o,
                    blendMode: t,
                    indices: h,
                    uvs: a,
                    _batchRGB: xe(n),
                    _tintRGB: n,
                    _texture: r.style.texture,
                    alpha: r.style.alpha,
                    worldAlpha: 1
                };
            this.batches[i] = l
        }
    }

    _renderBatched(e) {
        if (!!this.batches.length) {
            e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
            for (let t = 0, s = this.batches.length; t < s; t++) {
                const i = this.batches[t];
                i.worldAlpha = this.worldAlpha * i.alpha, e.plugins[this.pluginName].render(i)
            }
        }
    }

    _renderDirect(e) {
        const t = this._resolveDirectShader(e), s = this._geometry, i = this.tint, r = this.worldAlpha, n = t.uniforms,
            o = s.drawCalls;
        n.translationMatrix = this.transform.worldTransform, n.tint[0] = (i >> 16 & 255) / 255 * r, n.tint[1] = (i >> 8 & 255) / 255 * r, n.tint[2] = (i & 255) / 255 * r, n.tint[3] = r, e.shader.bind(t), e.geometry.bind(s, t), e.state.set(this.state);
        for (let a = 0, h = o.length; a < h; a++) this._renderDrawCallDirect(e, s.drawCalls[a])
    }

    _renderDrawCallDirect(e, t) {
        const {texArray: s, type: i, size: r, start: n} = t, o = s.count;
        for (let a = 0; a < o; a++) e.texture.bind(s.elements[a], a);
        e.geometry.draw(i, r, n)
    }

    _resolveDirectShader(e) {
        let t = this.shader;
        const s = this.pluginName;
        if (!t) {
            if (!vn[s]) {
                const {maxTextures: i} = e.plugins[s], r = new Int32Array(i);
                for (let a = 0; a < i; a++) r[a] = a;
                const n = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new Q,
                    default: Ft.from({uSamplers: r}, !0)
                }, o = e.plugins[s]._shader.program;
                vn[s] = new Wt(o, n)
            }
            t = vn[s]
        }
        return t
    }

    _calculateBounds() {
        this.finishPoly();
        const e = this._geometry;
        if (!e.graphicsData.length) return;
        const {minX: t, minY: s, maxX: i, maxY: r} = e.bounds;
        this._bounds.addFrame(this.transform, t, s, i, r)
    }

    containsPoint(e) {
        return this.worldTransform.applyInverse(e, vi._TEMP_POINT), this._geometry.containsPoint(vi._TEMP_POINT)
    }

    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            const e = xe(this.tint, dp);
            for (let t = 0; t < this.batches.length; t++) {
                const s = this.batches[t], i = s._batchRGB, r = e[0] * i[0] * 255, n = e[1] * i[1] * 255,
                    o = e[2] * i[2] * 255, a = (r << 16) + (n << 8) + (o | 0);
                s._tintRGB = (a >> 16) + (a & 65280) + ((a & 255) << 16)
            }
        }
    }

    calculateVertices() {
        const e = this.transform._worldID;
        if (this._transformID === e) return;
        this._transformID = e;
        const t = this.transform.worldTransform, s = t.a, i = t.b, r = t.c, n = t.d, o = t.tx, a = t.ty,
            h = this._geometry.points, l = this.vertexData;
        let c = 0;
        for (let u = 0; u < h.length; u += 2) {
            const d = h[u], f = h[u + 1];
            l[c++] = s * d + r * f + o, l[c++] = n * f + i * d + a
        }
    }

    closePath() {
        const e = this.currentPath;
        return e && (e.closeStroke = !0, this.finishPoly()), this
    }

    setMatrix(e) {
        return this._matrix = e, this
    }

    beginHole() {
        return this.finishPoly(), this._holeMode = !0, this
    }

    endHole() {
        return this.finishPoly(), this._holeMode = !1, this
    }

    destroy(e) {
        this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(e)
    }
};
let vs = vi;
vs.curves = de, vs._TEMP_POINT = new j;
const fp = {
    buildPoly: pn,
    buildCircle: gs,
    buildRectangle: Wa,
    buildRoundedRectangle: ja,
    buildLine: _n,
    ArcUtils: mn,
    BezierUtils: Mi,
    QuadraticUtils: Bi,
    BatchPart: $a,
    FILL_COMMANDS: xi,
    BATCH_POOL: gn,
    DRAW_CALL_POOL: xs
};

class Ka {
    constructor(t, s) {
        this.uvBuffer = t, this.uvMatrix = s, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
    }

    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        const s = this.uvBuffer.data;
        (!this.data || this.data.length !== s.length) && (this.data = new Float32Array(s.length)), this.uvMatrix.multiplyUvs(s, this.data), this._updateID++
    }
}

const yn = new j, Za = new Pe, Qa = class extends bt {
    constructor(e, t, s, i = Nt.TRIANGLES) {
        super(), this.geometry = e, this.shader = t, this.state = s || Jt.for2d(), this.drawMode = i, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = M.ROUND_PIXELS, this.batchUvs = null
    }

    get geometry() {
        return this._geometry
    }

    set geometry(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
    }

    get uvBuffer() {
        return this.geometry.buffers[1]
    }

    get verticesBuffer() {
        return this.geometry.buffers[0]
    }

    set material(e) {
        this.shader = e
    }

    get material() {
        return this.shader
    }

    set blendMode(e) {
        this.state.blendMode = e
    }

    get blendMode() {
        return this.state.blendMode
    }

    set roundPixels(e) {
        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e
    }

    get roundPixels() {
        return this._roundPixels
    }

    get tint() {
        return "tint" in this.shader ? this.shader.tint : null
    }

    set tint(e) {
        this.shader.tint = e
    }

    get texture() {
        return "texture" in this.shader ? this.shader.texture : null
    }

    set texture(e) {
        this.shader.texture = e
    }

    _render(e) {
        const t = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === Nt.TRIANGLES && t.length < Qa.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e)
    }

    _renderDefault(e) {
        const t = this.shader;
        t.alpha = this.worldAlpha, t.update && t.update(), e.batch.flush(), t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(t), e.state.set(this.state), e.geometry.bind(this.geometry, t), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
    }

    _renderToBatch(e) {
        const t = this.geometry, s = this.shader;
        s.uvMatrix && (s.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = t.indexBuffer.data, this._tintRGB = s._tintRGB, this._texture = s.texture;
        const i = this.material.pluginName;
        e.batch.setObjectRenderer(e.plugins[i]), e.plugins[i].render(this)
    }

    calculateVertices() {
        const t = this.geometry.buffers[0], s = t.data, i = t._updateID;
        if (i === this.vertexDirty && this._transformID === this.transform._worldID) return;
        this._transformID = this.transform._worldID, this.vertexData.length !== s.length && (this.vertexData = new Float32Array(s.length));
        const r = this.transform.worldTransform, n = r.a, o = r.b, a = r.c, h = r.d, l = r.tx, c = r.ty,
            u = this.vertexData;
        for (let d = 0; d < u.length / 2; d++) {
            const f = s[d * 2], p = s[d * 2 + 1];
            u[d * 2] = n * f + a * p + l, u[d * 2 + 1] = o * f + h * p + c
        }
        if (this._roundPixels) {
            const d = M.RESOLUTION;
            for (let f = 0; f < u.length; ++f) u[f] = Math.round(u[f] * d) / d
        }
        this.vertexDirty = i
    }

    calculateUvs() {
        const e = this.geometry.buffers[1], t = this.shader;
        t.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new Ka(e, t.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
    }

    _calculateBounds() {
        this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
    }

    containsPoint(e) {
        if (!this.getBounds().contains(e.x, e.y)) return !1;
        this.worldTransform.applyInverse(e, yn);
        const t = this.geometry.getBuffer("aVertexPosition").data, s = Za.points, i = this.geometry.getIndex().data,
            r = i.length, n = this.drawMode === 4 ? 3 : 1;
        for (let o = 0; o + 2 < r; o += n) {
            const a = i[o] * 2, h = i[o + 1] * 2, l = i[o + 2] * 2;
            if (s[0] = t[a], s[1] = t[a + 1], s[2] = t[h], s[3] = t[h + 1], s[4] = t[l], s[5] = t[l + 1], Za.contains(yn.x, yn.y)) return !0
        }
        return !1
    }

    destroy(e) {
        super.destroy(e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
    }
};
let Ie = Qa;
Ie.BATCHABLE_SIZE = 100;

class ys extends ae {
    constructor(t, s, i) {
        super();
        const r = new nt(t), n = new nt(s, !0), o = new nt(i, !0, !0);
        this.addAttribute("aVertexPosition", r, 2, !1, U.FLOAT).addAttribute("aTextureCoord", n, 2, !1, U.FLOAT).addIndex(o), this._updateId = -1
    }

    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}

var pp = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, mp = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;

class je extends Wt {
    constructor(t, s) {
        const i = {uSampler: t, alpha: 1, uTextureMatrix: Q.IDENTITY, uColor: new Float32Array([1, 1, 1, 1])};
        s = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, s), s.uniforms && Object.assign(i, s.uniforms), super(s.program || Pt.from(mp, pp), i), this._colorDirty = !1, this.uvMatrix = new ii(t), this.batchable = s.program === void 0, this.pluginName = s.pluginName, this.tint = s.tint, this.alpha = s.alpha
    }

    get texture() {
        return this.uniforms.uSampler
    }

    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t)
    }

    set alpha(t) {
        t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
    }

    get alpha() {
        return this._alpha
    }

    set tint(t) {
        t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16), this._colorDirty = !0)
    }

    get tint() {
        return this._tint
    }

    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture;
            Qi(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}

class Ja extends ys {
    constructor(t = 100, s = 100, i = 10, r = 10) {
        super(), this.segWidth = i, this.segHeight = r, this.width = t, this.height = s, this.build()
    }

    build() {
        const t = this.segWidth * this.segHeight, s = [], i = [], r = [], n = this.segWidth - 1, o = this.segHeight - 1,
            a = this.width / n, h = this.height / o;
        for (let c = 0; c < t; c++) {
            const u = c % this.segWidth, d = c / this.segWidth | 0;
            s.push(u * a, d * h), i.push(u / n, d / o)
        }
        const l = n * o;
        for (let c = 0; c < l; c++) {
            const u = c % n, d = c / n | 0, f = d * this.segWidth + u, p = d * this.segWidth + u + 1,
                _ = (d + 1) * this.segWidth + u, m = (d + 1) * this.segWidth + u + 1;
            r.push(f, p, _, p, m, _)
        }
        this.buffers[0].data = new Float32Array(s), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint16Array(r), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
    }
}

class th extends ys {
    constructor(t = 200, s, i = 0) {
        super(new Float32Array(s.length * 4), new Float32Array(s.length * 4), new Uint16Array((s.length - 1) * 6)), this.points = s, this._width = t, this.textureScale = i, this.build()
    }

    get width() {
        return this._width
    }

    build() {
        const t = this.points;
        if (!t) return;
        const s = this.getBuffer("aVertexPosition"), i = this.getBuffer("aTextureCoord"), r = this.getIndex();
        if (t.length < 1) return;
        s.data.length / 4 !== t.length && (s.data = new Float32Array(t.length * 4), i.data = new Float32Array(t.length * 4), r.data = new Uint16Array((t.length - 1) * 6));
        const n = i.data, o = r.data;
        n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1;
        let a = 0, h = t[0];
        const l = this._width * this.textureScale, c = t.length;
        for (let d = 0; d < c; d++) {
            const f = d * 4;
            if (this.textureScale > 0) {
                const p = h.x - t[d].x, _ = h.y - t[d].y, m = Math.sqrt(p * p + _ * _);
                h = t[d], a += m / l
            } else a = d / (c - 1);
            n[f] = a, n[f + 1] = 0, n[f + 2] = a, n[f + 3] = 1
        }
        let u = 0;
        for (let d = 0; d < c - 1; d++) {
            const f = d * 2;
            o[u++] = f, o[u++] = f + 1, o[u++] = f + 2, o[u++] = f + 2, o[u++] = f + 1, o[u++] = f + 3
        }
        i.update(), r.update(), this.updateVertices()
    }

    updateVertices() {
        const t = this.points;
        if (t.length < 1) return;
        let s = t[0], i, r = 0, n = 0;
        const o = this.buffers[0].data, a = t.length;
        for (let h = 0; h < a; h++) {
            const l = t[h], c = h * 4;
            h < t.length - 1 ? i = t[h + 1] : i = l, n = -(i.x - s.x), r = i.y - s.y;
            let u = (1 - h / (a - 1)) * 10;
            u > 1 && (u = 1);
            const d = Math.sqrt(r * r + n * n),
                f = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            r /= d, n /= d, r *= f, n *= f, o[c] = l.x + r, o[c + 1] = l.y + n, o[c + 2] = l.x - r, o[c + 3] = l.y - n, s = l
        }
        this.buffers[0].update()
    }

    update() {
        this.textureScale > 0 ? this.build() : this.updateVertices()
    }
}

class eh extends Ie {
    constructor(t, s, i) {
        const r = new Ja(t.width, t.height, s, i), n = new je(B.WHITE);
        super(r, n), this.texture = t, this.autoResize = !0
    }

    textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const t = this.geometry, {width: s, height: i} = this.shader.texture;
        this.autoResize && (t.width !== s || t.height !== i) && (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build())
    }

    set texture(t) {
        this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
    }

    get texture() {
        return this.shader.texture
    }

    _render(t) {
        this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(t)
    }

    destroy(t) {
        this.shader.texture.off("update", this.textureUpdated, this), super.destroy(t)
    }
}

const yi = 10;

class _p extends eh {
    constructor(t, s = yi, i = yi, r = yi, n = yi) {
        super(B.WHITE, 4, 4), this._origWidth = t.orig.width, this._origHeight = t.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = s, this._rightWidth = r, this._topHeight = i, this._bottomHeight = n, this.texture = t
    }

    textureUpdated() {
        this._textureID = this.shader.texture._updateID, this._refresh()
    }

    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }

    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }

    updateHorizontalVertices() {
        const t = this.vertices, s = this._getMinScale();
        t[9] = t[11] = t[13] = t[15] = this._topHeight * s, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * s, t[25] = t[27] = t[29] = t[31] = this._height
    }

    updateVerticalVertices() {
        const t = this.vertices, s = this._getMinScale();
        t[2] = t[10] = t[18] = t[26] = this._leftWidth * s, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * s, t[6] = t[14] = t[22] = t[30] = this._width
    }

    _getMinScale() {
        const t = this._leftWidth + this._rightWidth, s = this._width > t ? 1 : this._width / t,
            i = this._topHeight + this._bottomHeight, r = this._height > i ? 1 : this._height / i;
        return Math.min(s, r)
    }

    get width() {
        return this._width
    }

    set width(t) {
        this._width = t, this._refresh()
    }

    get height() {
        return this._height
    }

    set height(t) {
        this._height = t, this._refresh()
    }

    get leftWidth() {
        return this._leftWidth
    }

    set leftWidth(t) {
        this._leftWidth = t, this._refresh()
    }

    get rightWidth() {
        return this._rightWidth
    }

    set rightWidth(t) {
        this._rightWidth = t, this._refresh()
    }

    get topHeight() {
        return this._topHeight
    }

    set topHeight(t) {
        this._topHeight = t, this._refresh()
    }

    get bottomHeight() {
        return this._bottomHeight
    }

    set bottomHeight(t) {
        this._bottomHeight = t, this._refresh()
    }

    _refresh() {
        const t = this.texture, s = this.geometry.buffers[1].data;
        this._origWidth = t.orig.width, this._origHeight = t.orig.height;
        const i = 1 / this._origWidth, r = 1 / this._origHeight;
        s[0] = s[8] = s[16] = s[24] = 0, s[1] = s[3] = s[5] = s[7] = 0, s[6] = s[14] = s[22] = s[30] = 1, s[25] = s[27] = s[29] = s[31] = 1, s[2] = s[10] = s[18] = s[26] = i * this._leftWidth, s[4] = s[12] = s[20] = s[28] = 1 - i * this._rightWidth, s[9] = s[11] = s[13] = s[15] = r * this._topHeight, s[17] = s[19] = s[21] = s[23] = 1 - r * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
    }
}

class gp extends Ie {
    constructor(t = B.EMPTY, s, i, r, n) {
        const o = new ys(s, i, r);
        o.getBuffer("aVertexPosition").static = !1;
        const a = new je(t);
        super(o, a, null, n), this.autoUpdate = !0
    }

    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }

    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }

    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(t)
    }
}

class xp extends Ie {
    constructor(t, s, i = 0) {
        const r = new th(t.height, s, i), n = new je(t);
        i > 0 && (t.baseTexture.wrapMode = Kt.REPEAT), super(r, n), this.autoUpdate = !0
    }

    _render(t) {
        const s = this.geometry;
        (this.autoUpdate || s._width !== this.shader.texture.height) && (s._width = this.shader.texture.height, s.update()), super._render(t)
    }
}

class vp extends bt {
    constructor(t = 1500, s, i = 16384, r = !1) {
        super();
        const n = 16384;
        i > n && (i = n), this._properties = [!1, !0, !1, !1, !1], this._maxSize = t, this._batchSize = i, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = k.NORMAL, this.autoResize = r, this.roundPixels = !0, this.baseTexture = null, this.setProperties(s), this._tint = 0, this.tintRgb = new Float32Array(4), this.tint = 16777215
    }

    setProperties(t) {
        t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
    }

    updateTransform() {
        this.displayObjectUpdateTransform()
    }

    get tint() {
        return this._tint
    }

    set tint(t) {
        this._tint = t, xe(t, this.tintRgb)
    }

    render(t) {
        !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
    }

    onChildrenChange(t) {
        const s = Math.floor(t / this._batchSize);
        for (; this._bufferUpdateIDs.length < s;) this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[s] = ++this._updateID
    }

    dispose() {
        if (this._buffers) {
            for (let t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
            this._buffers = null
        }
    }

    destroy(t) {
        super.destroy(t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
    }
}

class sh {
    constructor(t, s, i) {
        this.geometry = new ae, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
        for (let r = 0; r < t.length; ++r) {
            let n = t[r];
            n = {
                attributeName: n.attributeName,
                size: n.size,
                uploadFunction: n.uploadFunction,
                type: n.type || U.FLOAT,
                offset: n.offset
            }, s[r] ? this.dynamicProperties.push(n) : this.staticProperties.push(n)
        }
        this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
    }

    initBuffers() {
        const t = this.geometry;
        let s = 0;
        this.indexBuffer = new nt(ao(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = s, s += a.size, this.dynamicStride += a.size
        }
        const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(i), this.dynamicDataUint32 = new Uint32Array(i), this.dynamicBuffer = new nt(this.dynamicData, !1, !1);
        let r = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = r, r += a.size, this.staticStride += a.size
        }
        const n = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(n), this.staticDataUint32 = new Uint32Array(n), this.staticBuffer = new nt(this.staticData, !0, !1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === U.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === U.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }

    uploadDynamic(t, s, i) {
        for (let r = 0; r < this.dynamicProperties.length; r++) {
            const n = this.dynamicProperties[r];
            n.uploadFunction(t, s, i, n.type === U.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, n.offset)
        }
        this.dynamicBuffer._updateID++
    }

    uploadStatic(t, s, i) {
        for (let r = 0; r < this.staticProperties.length; r++) {
            const n = this.staticProperties[r];
            n.uploadFunction(t, s, i, n.type === U.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, n.offset)
        }
        this.staticBuffer._updateID++
    }

    destroy() {
        this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
    }
}

var yp = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, Tp = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;

class Tn extends ns {
    constructor(t) {
        super(t), this.shader = null, this.properties = null, this.tempMatrix = new Q, this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: U.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }], this.shader = Wt.from(Tp, yp, {}), this.state = Jt.for2d()
    }

    render(t) {
        const s = t.children, i = t._maxSize, r = t._batchSize, n = this.renderer;
        let o = s.length;
        if (o === 0) return;
        o > i && !t.autoResize && (o = i);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const h = s[0]._texture.baseTexture, l = h.alphaMode > 0;
        this.state.blendMode = Zi(t.blendMode, l), n.state.set(this.state);
        const c = n.gl, u = t.worldTransform.copyTo(this.tempMatrix);
        u.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = u.toArray(!0), this.shader.uniforms.uColor = no(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, l), this.shader.uniforms.uSampler = h, this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += r, p += 1) {
            let _ = o - f;
            _ > r && (_ = r), p >= a.length && a.push(this._generateOneMoreBuffer(t));
            const m = a[p];
            m.uploadDynamic(s, f, _);
            const x = t._bufferUpdateIDs[p] || 0;
            d = d || m._updateID < x, d && (m._updateID = t._updateID, m.uploadStatic(s, f, _)), n.geometry.bind(m.geometry), c.drawElements(c.TRIANGLES, _ * 6, c.UNSIGNED_SHORT, 0)
        }
    }

    generateBuffers(t) {
        const s = [], i = t._maxSize, r = t._batchSize, n = t._properties;
        for (let o = 0; o < i; o += r) s.push(new sh(this.properties, n, r));
        return s
    }

    _generateOneMoreBuffer(t) {
        const s = t._batchSize, i = t._properties;
        return new sh(this.properties, i, s)
    }

    uploadVertices(t, s, i, r, n, o) {
        let a = 0, h = 0, l = 0, c = 0;
        for (let u = 0; u < i; ++u) {
            const d = t[s + u], f = d._texture, p = d.scale.x, _ = d.scale.y, m = f.trim, x = f.orig;
            m ? (h = m.x - d.anchor.x * x.width, a = h + m.width, c = m.y - d.anchor.y * x.height, l = c + m.height) : (a = x.width * (1 - d.anchor.x), h = x.width * -d.anchor.x, l = x.height * (1 - d.anchor.y), c = x.height * -d.anchor.y), r[o] = h * p, r[o + 1] = c * _, r[o + n] = a * p, r[o + n + 1] = c * _, r[o + n * 2] = a * p, r[o + n * 2 + 1] = l * _, r[o + n * 3] = h * p, r[o + n * 3 + 1] = l * _, o += n * 4
        }
    }

    uploadPosition(t, s, i, r, n, o) {
        for (let a = 0; a < i; a++) {
            const h = t[s + a].position;
            r[o] = h.x, r[o + 1] = h.y, r[o + n] = h.x, r[o + n + 1] = h.y, r[o + n * 2] = h.x, r[o + n * 2 + 1] = h.y, r[o + n * 3] = h.x, r[o + n * 3 + 1] = h.y, o += n * 4
        }
    }

    uploadRotation(t, s, i, r, n, o) {
        for (let a = 0; a < i; a++) {
            const h = t[s + a].rotation;
            r[o] = h, r[o + n] = h, r[o + n * 2] = h, r[o + n * 3] = h, o += n * 4
        }
    }

    uploadUvs(t, s, i, r, n, o) {
        for (let a = 0; a < i; ++a) {
            const h = t[s + a]._texture._uvs;
            h ? (r[o] = h.x0, r[o + 1] = h.y0, r[o + n] = h.x1, r[o + n + 1] = h.y1, r[o + n * 2] = h.x2, r[o + n * 2 + 1] = h.y2, r[o + n * 3] = h.x3, r[o + n * 3 + 1] = h.y3, o += n * 4) : (r[o] = 0, r[o + 1] = 0, r[o + n] = 0, r[o + n + 1] = 0, r[o + n * 2] = 0, r[o + n * 2 + 1] = 0, r[o + n * 3] = 0, r[o + n * 3 + 1] = 0, o += n * 4)
        }
    }

    uploadTint(t, s, i, r, n, o) {
        for (let a = 0; a < i; ++a) {
            const h = t[s + a], l = h._texture.baseTexture.alphaMode > 0, c = h.alpha,
                u = c < 1 && l ? Hs(h._tintRGB, c) : h._tintRGB + (c * 255 << 24);
            r[o] = u, r[o + n] = u, r[o + n * 2] = u, r[o + n * 3] = u, o += n * 4
        }
    }

    destroy() {
        super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
    }
}

Tn.extension = {name: "particle", type: I.RendererPlugin}, O.add(Tn);
var Ts = (e => (e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", e))(Ts || {});
const Ti = {willReadFrequently: !0}, N = class {
    static get experimentalLetterSpacingSupported() {
        let e = N._experimentalLetterSpacingSupported;
        if (e !== void 0) {
            const t = M.ADAPTER.getCanvasRenderingContext2D().prototype;
            e = N._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t
        }
        return e
    }

    constructor(e, t, s, i, r, n, o, a, h) {
        this.text = e, this.style = t, this.width = s, this.height = i, this.lines = r, this.lineWidths = n, this.lineHeight = o, this.maxLineWidth = a, this.fontProperties = h
    }

    static measureText(e, t, s, i = N._canvas) {
        s = s == null ? t.wordWrap : s;
        const r = t.toFontString(), n = N.measureFont(r);
        n.fontSize === 0 && (n.fontSize = t.fontSize, n.ascent = t.fontSize);
        const o = i.getContext("2d", Ti);
        o.font = r;
        const h = (s ? N.wordWrap(e, t, i) : e).split(/(?:\r\n|\r|\n)/), l = new Array(h.length);
        let c = 0;
        for (let p = 0; p < h.length; p++) {
            const _ = N._measureText(h[p], t.letterSpacing, o);
            l[p] = _, c = Math.max(c, _)
        }
        let u = c + t.strokeThickness;
        t.dropShadow && (u += t.dropShadowDistance);
        const d = t.lineHeight || n.fontSize + t.strokeThickness;
        let f = Math.max(d, n.fontSize + t.strokeThickness * 2) + (h.length - 1) * (d + t.leading);
        return t.dropShadow && (f += t.dropShadowDistance), new N(e, t, u, f, h, l, d + t.leading, c, n)
    }

    static _measureText(e, t, s) {
        let i = !1;
        N.experimentalLetterSpacingSupported && (N.experimentalLetterSpacing ? (s.letterSpacing = `${t}px`, s.textLetterSpacing = `${t}px`, i = !0) : (s.letterSpacing = "0px", s.textLetterSpacing = "0px"));
        let r = s.measureText(e).width;
        return r > 0 && (i ? r -= t : r += (N.graphemeSegmenter(e).length - 1) * t), r
    }

    static wordWrap(e, t, s = N._canvas) {
        const i = s.getContext("2d", Ti);
        let r = 0, n = "", o = "";
        const a = Object.create(null), {letterSpacing: h, whiteSpace: l} = t, c = N.collapseSpaces(l),
            u = N.collapseNewlines(l);
        let d = !c;
        const f = t.wordWrapWidth + h, p = N.tokenize(e);
        for (let _ = 0; _ < p.length; _++) {
            let m = p[_];
            if (N.isNewline(m)) {
                if (!u) {
                    o += N.addLine(n), d = !c, n = "", r = 0;
                    continue
                }
                m = " "
            }
            if (c) {
                const y = N.isBreakingSpace(m), g = N.isBreakingSpace(n[n.length - 1]);
                if (y && g) continue
            }
            const x = N.getFromCache(m, h, a, i);
            if (x > f) if (n !== "" && (o += N.addLine(n), n = "", r = 0), N.canBreakWords(m, t.breakWords)) {
                const y = N.wordWrapSplit(m);
                for (let g = 0; g < y.length; g++) {
                    let v = y[g], A = v, P = 1;
                    for (; y[g + P];) {
                        const b = y[g + P];
                        if (!N.canBreakChars(A, b, m, g, t.breakWords)) v += b; else break;
                        A = b, P++
                    }
                    g += P - 1;
                    const S = N.getFromCache(v, h, a, i);
                    S + r > f && (o += N.addLine(n), d = !1, n = "", r = 0), n += v, r += S
                }
            } else {
                n.length > 0 && (o += N.addLine(n), n = "", r = 0);
                const y = _ === p.length - 1;
                o += N.addLine(m, !y), d = !1, n = "", r = 0
            } else x + r > f && (d = !1, o += N.addLine(n), n = "", r = 0), (n.length > 0 || !N.isBreakingSpace(m) || d) && (n += m, r += x)
        }
        return o += N.addLine(n, !1), o
    }

    static addLine(e, t = !0) {
        return e = N.trimRight(e), e = t ? `${e}
` : e, e
    }

    static getFromCache(e, t, s, i) {
        let r = s[e];
        return typeof r != "number" && (r = N._measureText(e, t, i) + t, s[e] = r), r
    }

    static collapseSpaces(e) {
        return e === "normal" || e === "pre-line"
    }

    static collapseNewlines(e) {
        return e === "normal"
    }

    static trimRight(e) {
        if (typeof e != "string") return "";
        for (let t = e.length - 1; t >= 0; t--) {
            const s = e[t];
            if (!N.isBreakingSpace(s)) break;
            e = e.slice(0, -1)
        }
        return e
    }

    static isNewline(e) {
        return typeof e != "string" ? !1 : N._newlines.includes(e.charCodeAt(0))
    }

    static isBreakingSpace(e, t) {
        return typeof e != "string" ? !1 : N._breakingSpaces.includes(e.charCodeAt(0))
    }

    static tokenize(e) {
        const t = [];
        let s = "";
        if (typeof e != "string") return t;
        for (let i = 0; i < e.length; i++) {
            const r = e[i], n = e[i + 1];
            if (N.isBreakingSpace(r, n) || N.isNewline(r)) {
                s !== "" && (t.push(s), s = ""), t.push(r);
                continue
            }
            s += r
        }
        return s !== "" && t.push(s), t
    }

    static canBreakWords(e, t) {
        return t
    }

    static canBreakChars(e, t, s, i, r) {
        return !0
    }

    static wordWrapSplit(e) {
        return N.graphemeSegmenter(e)
    }

    static measureFont(e) {
        if (N._fonts[e]) return N._fonts[e];
        const t = {ascent: 0, descent: 0, fontSize: 0}, s = N._canvas, i = N._context;
        i.font = e;
        const r = N.METRICS_STRING + N.BASELINE_SYMBOL, n = Math.ceil(i.measureText(r).width);
        let o = Math.ceil(i.measureText(N.BASELINE_SYMBOL).width);
        const a = Math.ceil(N.HEIGHT_MULTIPLIER * o);
        if (o = o * N.BASELINE_MULTIPLIER | 0, n === 0 || a === 0) return N._fonts[e] = t, t;
        s.width = n, s.height = a, i.fillStyle = "#f00", i.fillRect(0, 0, n, a), i.font = e, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(r, 0, o);
        const h = i.getImageData(0, 0, n, a).data, l = h.length, c = n * 4;
        let u = 0, d = 0, f = !1;
        for (u = 0; u < o; ++u) {
            for (let p = 0; p < c; p += 4) if (h[d + p] !== 255) {
                f = !0;
                break
            }
            if (!f) d += c; else break
        }
        for (t.ascent = o - u, d = l - c, f = !1, u = a; u > o; --u) {
            for (let p = 0; p < c; p += 4) if (h[d + p] !== 255) {
                f = !0;
                break
            }
            if (!f) d -= c; else break
        }
        return t.descent = u - o, t.fontSize = t.ascent + t.descent, N._fonts[e] = t, t
    }

    static clearMetrics(e = "") {
        e ? delete N._fonts[e] : N._fonts = {}
    }

    static get _canvas() {
        if (!N.__canvas) {
            let e;
            try {
                const t = new OffscreenCanvas(0, 0), s = t.getContext("2d", Ti);
                if (s != null && s.measureText) return N.__canvas = t, t;
                e = M.ADAPTER.createCanvas()
            } catch (t) {
                e = M.ADAPTER.createCanvas()
            }
            e.width = e.height = 10, N.__canvas = e
        }
        return N.__canvas
    }

    static get _context() {
        return N.__context || (N.__context = N._canvas.getContext("2d", Ti)), N.__context
    }
};
let _t = N;
_t.METRICS_STRING = "|\xC9q\xC5", _t.BASELINE_SYMBOL = "M", _t.BASELINE_MULTIPLIER = 1.4, _t.HEIGHT_MULTIPLIER = 2, _t.graphemeSegmenter = (() => {
    if (typeof (Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const e = new Intl.Segmenter;
        return t => [...e.segment(t)].map(s => s.segment)
    }
    return e => [...e]
})(), _t.experimentalLetterSpacing = !1, _t._fonts = {}, _t._newlines = [10, 13], _t._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
const bp = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], bs = class {
    constructor(e) {
        this.styleID = 0, this.reset(), En(this, e, e)
    }

    clone() {
        const e = {};
        return En(e, this, bs.defaultStyle), new bs(e)
    }

    reset() {
        En(this, bs.defaultStyle, bs.defaultStyle)
    }

    get align() {
        return this._align
    }

    set align(e) {
        this._align !== e && (this._align = e, this.styleID++)
    }

    get breakWords() {
        return this._breakWords
    }

    set breakWords(e) {
        this._breakWords !== e && (this._breakWords = e, this.styleID++)
    }

    get dropShadow() {
        return this._dropShadow
    }

    set dropShadow(e) {
        this._dropShadow !== e && (this._dropShadow = e, this.styleID++)
    }

    get dropShadowAlpha() {
        return this._dropShadowAlpha
    }

    set dropShadowAlpha(e) {
        this._dropShadowAlpha !== e && (this._dropShadowAlpha = e, this.styleID++)
    }

    get dropShadowAngle() {
        return this._dropShadowAngle
    }

    set dropShadowAngle(e) {
        this._dropShadowAngle !== e && (this._dropShadowAngle = e, this.styleID++)
    }

    get dropShadowBlur() {
        return this._dropShadowBlur
    }

    set dropShadowBlur(e) {
        this._dropShadowBlur !== e && (this._dropShadowBlur = e, this.styleID++)
    }

    get dropShadowColor() {
        return this._dropShadowColor
    }

    set dropShadowColor(e) {
        const t = bn(e);
        this._dropShadowColor !== t && (this._dropShadowColor = t, this.styleID++)
    }

    get dropShadowDistance() {
        return this._dropShadowDistance
    }

    set dropShadowDistance(e) {
        this._dropShadowDistance !== e && (this._dropShadowDistance = e, this.styleID++)
    }

    get fill() {
        return this._fill
    }

    set fill(e) {
        const t = bn(e);
        this._fill !== t && (this._fill = t, this.styleID++)
    }

    get fillGradientType() {
        return this._fillGradientType
    }

    set fillGradientType(e) {
        this._fillGradientType !== e && (this._fillGradientType = e, this.styleID++)
    }

    get fillGradientStops() {
        return this._fillGradientStops
    }

    set fillGradientStops(e) {
        Ep(this._fillGradientStops, e) || (this._fillGradientStops = e, this.styleID++)
    }

    get fontFamily() {
        return this._fontFamily
    }

    set fontFamily(e) {
        this.fontFamily !== e && (this._fontFamily = e, this.styleID++)
    }

    get fontSize() {
        return this._fontSize
    }

    set fontSize(e) {
        this._fontSize !== e && (this._fontSize = e, this.styleID++)
    }

    get fontStyle() {
        return this._fontStyle
    }

    set fontStyle(e) {
        this._fontStyle !== e && (this._fontStyle = e, this.styleID++)
    }

    get fontVariant() {
        return this._fontVariant
    }

    set fontVariant(e) {
        this._fontVariant !== e && (this._fontVariant = e, this.styleID++)
    }

    get fontWeight() {
        return this._fontWeight
    }

    set fontWeight(e) {
        this._fontWeight !== e && (this._fontWeight = e, this.styleID++)
    }

    get letterSpacing() {
        return this._letterSpacing
    }

    set letterSpacing(e) {
        this._letterSpacing !== e && (this._letterSpacing = e, this.styleID++)
    }

    get lineHeight() {
        return this._lineHeight
    }

    set lineHeight(e) {
        this._lineHeight !== e && (this._lineHeight = e, this.styleID++)
    }

    get leading() {
        return this._leading
    }

    set leading(e) {
        this._leading !== e && (this._leading = e, this.styleID++)
    }

    get lineJoin() {
        return this._lineJoin
    }

    set lineJoin(e) {
        this._lineJoin !== e && (this._lineJoin = e, this.styleID++)
    }

    get miterLimit() {
        return this._miterLimit
    }

    set miterLimit(e) {
        this._miterLimit !== e && (this._miterLimit = e, this.styleID++)
    }

    get padding() {
        return this._padding
    }

    set padding(e) {
        this._padding !== e && (this._padding = e, this.styleID++)
    }

    get stroke() {
        return this._stroke
    }

    set stroke(e) {
        const t = bn(e);
        this._stroke !== t && (this._stroke = t, this.styleID++)
    }

    get strokeThickness() {
        return this._strokeThickness
    }

    set strokeThickness(e) {
        this._strokeThickness !== e && (this._strokeThickness = e, this.styleID++)
    }

    get textBaseline() {
        return this._textBaseline
    }

    set textBaseline(e) {
        this._textBaseline !== e && (this._textBaseline = e, this.styleID++)
    }

    get trim() {
        return this._trim
    }

    set trim(e) {
        this._trim !== e && (this._trim = e, this.styleID++)
    }

    get whiteSpace() {
        return this._whiteSpace
    }

    set whiteSpace(e) {
        this._whiteSpace !== e && (this._whiteSpace = e, this.styleID++)
    }

    get wordWrap() {
        return this._wordWrap
    }

    set wordWrap(e) {
        this._wordWrap !== e && (this._wordWrap = e, this.styleID++)
    }

    get wordWrapWidth() {
        return this._wordWrapWidth
    }

    set wordWrapWidth(e) {
        this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.styleID++)
    }

    toFontString() {
        const e = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
        let t = this.fontFamily;
        Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
        for (let s = t.length - 1; s >= 0; s--) {
            let i = t[s].trim();
            !/([\"\'])[^\'\"]+\1/.test(i) && !bp.includes(i) && (i = `"${i}"`), t[s] = i
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`
    }
};
let fe = bs;
fe.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: Ts.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};

function ih(e) {
    return typeof e == "number" ? qi(e) : (typeof e == "string" && e.startsWith("0x") && (e = e.replace("0x", "#")), e)
}

function bn(e) {
    if (Array.isArray(e)) {
        for (let t = 0; t < e.length; ++t) e[t] = ih(e[t]);
        return e
    } else return ih(e)
}

function Ep(e, t) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length) return !1;
    for (let s = 0; s < e.length; ++s) if (e[s] !== t[s]) return !1;
    return !0
}

function En(e, t, s) {
    for (const i in s) Array.isArray(t[i]) ? e[i] = t[i].slice() : e[i] = t[i]
}

const wp = {texture: !0, children: !1, baseTexture: !0}, wn = class extends pe {
    constructor(e, t, s) {
        var n;
        let i = !1;
        s || (s = M.ADAPTER.createCanvas(), i = !0), s.width = 3, s.height = 3;
        const r = B.from(s);
        r.orig = new z, r.trim = new z, super(r), this._ownCanvas = i, this.canvas = s, this.context = s.getContext("2d", {willReadFrequently: !0}), this._resolution = (n = wn.defaultResolution) != null ? n : M.RESOLUTION, this._autoResolution = wn.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = e, this.style = t, this.localStyleID = -1
    }

    static get experimentalLetterSpacing() {
        return _t.experimentalLetterSpacing
    }

    static set experimentalLetterSpacing(e) {
        Y("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), _t.experimentalLetterSpacing = e
    }

    updateText(e) {
        const t = this._style;
        if (this.localStyleID !== t.styleID && (this.dirty = !0, this.localStyleID = t.styleID), !this.dirty && e) return;
        this._font = this._style.toFontString();
        const s = this.context, i = _t.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
            r = i.width, n = i.height, o = i.lines, a = i.lineHeight, h = i.lineWidths, l = i.maxLineWidth,
            c = i.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, r) + t.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, n) + t.padding * 2) * this._resolution), s.scale(this._resolution, this._resolution), s.clearRect(0, 0, this.canvas.width, this.canvas.height), s.font = this._font, s.lineWidth = t.strokeThickness, s.textBaseline = t.textBaseline, s.lineJoin = t.lineJoin, s.miterLimit = t.miterLimit;
        let u, d;
        const f = t.dropShadow ? 2 : 1;
        for (let p = 0; p < f; ++p) {
            const _ = t.dropShadow && p === 0, m = _ ? Math.ceil(Math.max(1, n) + t.padding * 2) : 0,
                x = m * this._resolution;
            if (_) {
                s.fillStyle = "black", s.strokeStyle = "black";
                const g = t.dropShadowColor, v = xe(typeof g == "number" ? g : Gs(g)),
                    A = t.dropShadowBlur * this._resolution, P = t.dropShadowDistance * this._resolution;
                s.shadowColor = `rgba(${v[0] * 255},${v[1] * 255},${v[2] * 255},${t.dropShadowAlpha})`, s.shadowBlur = A, s.shadowOffsetX = Math.cos(t.dropShadowAngle) * P, s.shadowOffsetY = Math.sin(t.dropShadowAngle) * P + x
            } else s.fillStyle = this._generateFillStyle(t, o, i), s.strokeStyle = t.stroke, s.shadowColor = "black", s.shadowBlur = 0, s.shadowOffsetX = 0, s.shadowOffsetY = 0;
            let y = (a - c.fontSize) / 2;
            a - c.fontSize < 0 && (y = 0);
            for (let g = 0; g < o.length; g++) u = t.strokeThickness / 2, d = t.strokeThickness / 2 + g * a + c.ascent + y, t.align === "right" ? u += l - h[g] : t.align === "center" && (u += (l - h[g]) / 2), t.stroke && t.strokeThickness && this.drawLetterSpacing(o[g], u + t.padding, d + t.padding - m, !0), t.fill && this.drawLetterSpacing(o[g], u + t.padding, d + t.padding - m)
        }
        this.updateTexture()
    }

    drawLetterSpacing(e, t, s, i = !1) {
        const n = this._style.letterSpacing;
        let o = !1;
        if (_t.experimentalLetterSpacingSupported && (_t.experimentalLetterSpacing ? (this.context.letterSpacing = `${n}px`, this.context.textLetterSpacing = `${n}px`, o = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), n === 0 || o) {
            i ? this.context.strokeText(e, t, s) : this.context.fillText(e, t, s);
            return
        }
        let a = t;
        const h = _t.graphemeSegmenter(e);
        let l = this.context.measureText(e).width, c = 0;
        for (let u = 0; u < h.length; ++u) {
            const d = h[u];
            i ? this.context.strokeText(d, a, s) : this.context.fillText(d, a, s);
            let f = "";
            for (let p = u + 1; p < h.length; ++p) f += h[p];
            c = this.context.measureText(f).width, a += l - c + n, l = c
        }
    }

    updateTexture() {
        const e = this.canvas;
        if (this._style.trim) {
            const n = fo(e);
            n.data && (e.width = n.width, e.height = n.height, this.context.putImageData(n.data, 0, 0))
        }
        const t = this._texture, s = this._style, i = s.trim ? 0 : s.padding, r = t.baseTexture;
        t.trim.width = t._frame.width = e.width / this._resolution, t.trim.height = t._frame.height = e.height / this._resolution, t.trim.x = -i, t.trim.y = -i, t.orig.width = t._frame.width - i * 2, t.orig.height = t._frame.height - i * 2, this._onTextureUpdate(), r.setRealSize(e.width, e.height, this._resolution), t.updateUvs(), this.dirty = !1
    }

    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._render(e)
    }

    updateTransform() {
        this.updateText(!0), super.updateTransform()
    }

    getBounds(e, t) {
        return this.updateText(!0), this._textureID === -1 && (e = !1), super.getBounds(e, t)
    }

    getLocalBounds(e) {
        return this.updateText(!0), super.getLocalBounds.call(this, e)
    }

    _calculateBounds() {
        this.calculateVertices(), this._bounds.addQuad(this.vertexData)
    }

    _generateFillStyle(e, t, s) {
        const i = e.fill;
        if (Array.isArray(i)) {
            if (i.length === 1) return i[0]
        } else return i;
        let r;
        const n = e.dropShadow ? e.dropShadowDistance : 0, o = e.padding || 0,
            a = this.canvas.width / this._resolution - n - o * 2, h = this.canvas.height / this._resolution - n - o * 2,
            l = i.slice(), c = e.fillGradientStops.slice();
        if (!c.length) {
            const u = l.length + 1;
            for (let d = 1; d < u; ++d) c.push(d / u)
        }
        if (l.unshift(i[0]), c.unshift(0), l.push(i[i.length - 1]), c.push(1), e.fillGradientType === Ts.LINEAR_VERTICAL) {
            r = this.context.createLinearGradient(a / 2, o, a / 2, h + o);
            const u = s.fontProperties.fontSize + e.strokeThickness;
            for (let d = 0; d < t.length; d++) {
                const f = s.lineHeight * (d - 1) + u, p = s.lineHeight * d;
                let _ = p;
                d > 0 && f > p && (_ = (p + f) / 2);
                const m = p + u, x = s.lineHeight * (d + 1);
                let y = m;
                d + 1 < t.length && x < m && (y = (m + x) / 2);
                const g = (y - _) / h;
                for (let v = 0; v < l.length; v++) {
                    let A = 0;
                    typeof c[v] == "number" ? A = c[v] : A = v / l.length;
                    let P = Math.min(1, Math.max(0, _ / h + A * g));
                    P = Number(P.toFixed(5)), r.addColorStop(P, l[v])
                }
            }
        } else {
            r = this.context.createLinearGradient(o, h / 2, a + o, h / 2);
            const u = l.length + 1;
            let d = 1;
            for (let f = 0; f < l.length; f++) {
                let p;
                typeof c[f] == "number" ? p = c[f] : p = d / u, r.addColorStop(p, l[f]), d++
            }
        }
        return r
    }

    destroy(e) {
        typeof e == "boolean" && (e = {children: e}), e = Object.assign({}, wp, e), super.destroy(e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
    }

    get width() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
    }

    set width(e) {
        this.updateText(!0);
        const t = ye(this.scale.x) || 1;
        this.scale.x = t * e / this._texture.orig.width, this._width = e
    }

    get height() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
    }

    set height(e) {
        this.updateText(!0);
        const t = ye(this.scale.y) || 1;
        this.scale.y = t * e / this._texture.orig.height, this._height = e
    }

    get style() {
        return this._style
    }

    set style(e) {
        e = e || {}, e instanceof fe ? this._style = e : this._style = new fe(e), this.localStyleID = -1, this.dirty = !0
    }

    get text() {
        return this._text
    }

    set text(e) {
        e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0)
    }

    get resolution() {
        return this._resolution
    }

    set resolution(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
    }
};
let bi = wn;
bi.defaultAutoResolution = !0;

class rh {
    constructor(t) {
        this.maxItemsPerFrame = t, this.itemsLeft = 0
    }

    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }

    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}

function Ap(e, t) {
    var i;
    let s = !1;
    if ((i = e == null ? void 0 : e._textures) != null && i.length) {
        for (let r = 0; r < e._textures.length; r++) if (e._textures[r] instanceof B) {
            const n = e._textures[r].baseTexture;
            t.includes(n) || (t.push(n), s = !0)
        }
    }
    return s
}

function Sp(e, t) {
    if (e.baseTexture instanceof X) {
        const s = e.baseTexture;
        return t.includes(s) || t.push(s), !0
    }
    return !1
}

function Rp(e, t) {
    if (e._texture && e._texture instanceof B) {
        const s = e._texture.baseTexture;
        return t.includes(s) || t.push(s), !0
    }
    return !1
}

function Cp(e, t) {
    return t instanceof bi ? (t.updateText(!0), !0) : !1
}

function Ip(e, t) {
    if (t instanceof fe) {
        const s = t.toFontString();
        return _t.measureFont(s), !0
    }
    return !1
}

function Pp(e, t) {
    if (e instanceof bi) {
        t.includes(e.style) || t.push(e.style), t.includes(e) || t.push(e);
        const s = e._texture.baseTexture;
        return t.includes(s) || t.push(s), !0
    }
    return !1
}

function Mp(e, t) {
    return e instanceof fe ? (t.includes(e) || t.push(e), !0) : !1
}

const nh = class {
    constructor(e) {
        this.limiter = new rh(nh.uploadsPerFrame), this.renderer = e, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
            !this.queue || this.prepareItems()
        }, this.registerFindHook(Pp), this.registerFindHook(Mp), this.registerFindHook(Ap), this.registerFindHook(Sp), this.registerFindHook(Rp), this.registerUploadHook(Cp), this.registerUploadHook(Ip)
    }

    upload(e) {
        return new Promise(t => {
            e && this.add(e), this.queue.length ? (this.completes.push(t), this.ticking || (this.ticking = !0, ct.system.addOnce(this.tick, this, ce.UTILITY))) : t()
        })
    }

    tick() {
        setTimeout(this.delayedTick, 0)
    }

    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
            const e = this.queue[0];
            let t = !1;
            if (e && !e._destroyed) {
                for (let s = 0, i = this.uploadHooks.length; s < i; s++) if (this.uploadHooks[s](this.uploadHookHelper, e)) {
                    this.queue.shift(), t = !0;
                    break
                }
            }
            t || this.queue.shift()
        }
        if (this.queue.length) ct.system.addOnce(this.tick, this, ce.UTILITY); else {
            this.ticking = !1;
            const e = this.completes.slice(0);
            this.completes.length = 0;
            for (let t = 0, s = e.length; t < s; t++) e[t]()
        }
    }

    registerFindHook(e) {
        return e && this.addHooks.push(e), this
    }

    registerUploadHook(e) {
        return e && this.uploadHooks.push(e), this
    }

    add(e) {
        for (let t = 0, s = this.addHooks.length; t < s && !this.addHooks[t](e, this.queue); t++) ;
        if (e instanceof bt) for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
        return this
    }

    destroy() {
        this.ticking && ct.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
    }
};
let Es = nh;
Es.uploadsPerFrame = 4, Object.defineProperties(M, {
    UPLOADS_PER_FRAME: {
        get() {
            return Es.uploadsPerFrame
        }, set(e) {
            Y("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), Es.uploadsPerFrame = e
        }
    }
});

function oh(e, t) {
    return t instanceof X ? (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t), !0) : !1
}

function Bp(e, t) {
    if (!(t instanceof vs)) return !1;
    const {geometry: s} = t;
    t.finishPoly(), s.updateBatches();
    const {batches: i} = s;
    for (let r = 0; r < i.length; r++) {
        const {texture: n} = i[r].style;
        n && oh(e, n.baseTexture)
    }
    return s.batchable || e.geometry.bind(s, t._resolveDirectShader(e)), !0
}

function Dp(e, t) {
    return e instanceof vs ? (t.push(e), !0) : !1
}

class An extends Es {
    constructor(t) {
        super(t), this.uploadHookHelper = this.renderer, this.registerFindHook(Dp), this.registerUploadHook(oh), this.registerUploadHook(Bp)
    }
}

An.extension = {name: "prepare", type: I.RendererSystem}, O.add(An);

class Fp {
    constructor(t) {
        this.maxMilliseconds = t, this.frameStart = 0
    }

    beginFrame() {
        this.frameStart = Date.now()
    }

    allowedToUpload() {
        return Date.now() - this.frameStart < this.maxMilliseconds
    }
}

class Fi extends pe {
    constructor(t, s = !0) {
        super(t[0] instanceof B ? t[0] : t[0].texture), this._textures = null, this._durations = null, this._autoUpdate = s, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = t
    }

    stop() {
        !this._playing || (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (ct.shared.remove(this.update, this), this._isConnectedToTicker = !1))
    }

    play() {
        this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (ct.shared.add(this.update, this, ce.HIGH), this._isConnectedToTicker = !0))
    }

    gotoAndStop(t) {
        this.stop(), this.currentFrame = t
    }

    gotoAndPlay(t) {
        this.currentFrame = t, this.play()
    }

    update(t) {
        if (!this._playing) return;
        const s = this.animationSpeed * t, i = this.currentFrame;
        if (this._durations !== null) {
            let r = this._currentTime % 1 * this._durations[this.currentFrame];
            for (r += s / 60 * 1e3; r < 0;) this._currentTime--, r += this._durations[this.currentFrame];
            const n = Math.sign(this.animationSpeed * t);
            for (this._currentTime = Math.floor(this._currentTime); r >= this._durations[this.currentFrame];) r -= this._durations[this.currentFrame] * n, this._currentTime += n;
            this._currentTime += r / this._durations[this.currentFrame]
        } else this._currentTime += s;
        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : i !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i || this.animationSpeed < 0 && this.currentFrame > i) && this.onLoop(), this.updateTexture())
    }

    updateTexture() {
        const t = this.currentFrame;
        this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
    }

    destroy(t) {
        this.stop(), super.destroy(t), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
    }

    static fromFrames(t) {
        const s = [];
        for (let i = 0; i < t.length; ++i) s.push(B.from(t[i]));
        return new Fi(s)
    }

    static fromImages(t) {
        const s = [];
        for (let i = 0; i < t.length; ++i) s.push(B.from(t[i]));
        return new Fi(s)
    }

    get totalFrames() {
        return this._textures.length
    }

    get textures() {
        return this._textures
    }

    set textures(t) {
        if (t[0] instanceof B) this._textures = t, this._durations = null; else {
            this._textures = [], this._durations = [];
            for (let s = 0; s < t.length; s++) this._textures.push(t[s].texture), this._durations.push(t[s].time)
        }
        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
    }

    get currentFrame() {
        let t = Math.floor(this._currentTime) % this._textures.length;
        return t < 0 && (t += this._textures.length), t
    }

    set currentFrame(t) {
        if (t < 0 || t > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${t}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
        const s = this.currentFrame;
        this._currentTime = t, s !== this.currentFrame && this.updateTexture()
    }

    get playing() {
        return this._playing
    }

    get autoUpdate() {
        return this._autoUpdate
    }

    set autoUpdate(t) {
        t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (ct.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (ct.shared.add(this.update, this), this._isConnectedToTicker = !0))
    }
}

const ws = new j;

class Cn extends pe {
    constructor(t, s = 100, i = 100) {
        super(t), this.tileTransform = new is, this._width = s, this._height = i, this.uvMatrix = this.texture.uvMatrix || new ii(t), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1
    }

    get clampMargin() {
        return this.uvMatrix.clampMargin
    }

    set clampMargin(t) {
        this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
    }

    get tileScale() {
        return this.tileTransform.scale
    }

    set tileScale(t) {
        this.tileTransform.scale.copyFrom(t)
    }

    get tilePosition() {
        return this.tileTransform.position
    }

    set tilePosition(t) {
        this.tileTransform.position.copyFrom(t)
    }

    _onTextureUpdate() {
        this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
    }

    _render(t) {
        const s = this._texture;
        !s || !s.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
    }

    _calculateBounds() {
        const t = this._width * -this._anchor._x, s = this._height * -this._anchor._y,
            i = this._width * (1 - this._anchor._x), r = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, s, i, r)
    }

    getLocalBounds(t) {
        return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new z), t = this._localBoundsRect), this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }

    containsPoint(t) {
        this.worldTransform.applyInverse(t, ws);
        const s = this._width, i = this._height, r = -s * this.anchor._x;
        if (ws.x >= r && ws.x < r + s) {
            const n = -i * this.anchor._y;
            if (ws.y >= n && ws.y < n + i) return !0
        }
        return !1
    }

    destroy(t) {
        super.destroy(t), this.tileTransform = null, this.uvMatrix = null
    }

    static from(t, s) {
        const i = t instanceof B ? t : B.from(t, s);
        return new Cn(i, s.width, s.height)
    }

    get width() {
        return this._width
    }

    set width(t) {
        this._width = t
    }

    get height() {
        return this._height
    }

    set height(t) {
        this._height = t
    }
}

var Np = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, Lp = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, Op = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, ah = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, Up = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Ei = new Q;

class Sn extends ns {
    constructor(t) {
        super(t), t.runners.contextChange.add(this), this.quad = new Tr, this.state = Jt.for2d()
    }

    contextChange() {
        const t = this.renderer, s = {globals: t.globalUniforms};
        this.simpleShader = Wt.from(ah, Up, s), this.shader = t.context.webGLVersion > 1 ? Wt.from(Lp, Np, s) : Wt.from(ah, Op, s)
    }

    render(t) {
        const s = this.renderer, i = this.quad;
        let r = i.vertices;
        r[0] = r[6] = t._width * -t.anchor.x, r[1] = r[3] = t._height * -t.anchor.y, r[2] = r[4] = t._width * (1 - t.anchor.x), r[5] = r[7] = t._height * (1 - t.anchor.y);
        const n = t.uvRespectAnchor ? t.anchor.x : 0, o = t.uvRespectAnchor ? t.anchor.y : 0;
        r = i.uvs, r[0] = r[6] = -n, r[1] = r[3] = -o, r[2] = r[4] = 1 - n, r[5] = r[7] = 1 - o, i.invalidate();
        const a = t._texture, h = a.baseTexture, l = h.alphaMode > 0, c = t.tileTransform.localTransform,
            u = t.uvMatrix;
        let d = h.isPowerOfTwo && a.frame.width === h.width && a.frame.height === h.height;
        d && (h._glTextures[s.CONTEXT_UID] ? d = h.wrapMode !== Kt.CLAMP : h.wrapMode === Kt.CLAMP && (h.wrapMode = Kt.REPEAT));
        const f = d ? this.simpleShader : this.shader, p = a.width, _ = a.height, m = t._width, x = t._height;
        Ei.set(c.a * p / m, c.b * p / x, c.c * _ / m, c.d * _ / x, c.tx / m, c.ty / x), Ei.invert(), d ? Ei.prepend(u.mapCoord) : (f.uniforms.uMapCoord = u.mapCoord.toArray(!0), f.uniforms.uClampFrame = u.uClampFrame, f.uniforms.uClampOffset = u.uClampOffset), f.uniforms.uTransform = Ei.toArray(!0), f.uniforms.uColor = Qi(t.tint, t.worldAlpha, f.uniforms.uColor, l), f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), f.uniforms.uSampler = a, s.shader.bind(f), s.geometry.bind(i), this.state.blendMode = Zi(t.blendMode, l), s.state.set(this.state), s.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}

Sn.extension = {name: "tilingSprite", type: I.RendererPlugin}, O.add(Sn);
const As = class {
    constructor(e, t, s = null) {
        this.linkedSheets = [], this._texture = e instanceof B ? e : null, this.baseTexture = e instanceof X ? e : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = t;
        const i = this.baseTexture.resource;
        this.resolution = this._updateResolution(s || (i ? i.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
    }

    _updateResolution(e = null) {
        const {scale: t} = this.data.meta;
        let s = ee(e, null);
        return s === null && (s = parseFloat(t != null ? t : "1")), s !== 1 && this.baseTexture.setResolution(s), s
    }

    parse() {
        return new Promise(e => {
            this._callback = e, this._batchIndex = 0, this._frameKeys.length <= As.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
        })
    }

    _processFrames(e) {
        let t = e;
        const s = As.BATCH_SIZE;
        for (; t - e < s && t < this._frameKeys.length;) {
            const i = this._frameKeys[t], r = this._frames[i], n = r.frame;
            if (n) {
                let o = null, a = null;
                const h = r.trimmed !== !1 && r.sourceSize ? r.sourceSize : r.frame,
                    l = new z(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
                r.rotated ? o = new z(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.h) / this.resolution, Math.floor(n.w) / this.resolution) : o = new z(Math.floor(n.x) / this.resolution, Math.floor(n.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution), r.trimmed !== !1 && r.spriteSourceSize && (a = new z(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(n.w) / this.resolution, Math.floor(n.h) / this.resolution)), this.textures[i] = new B(this.baseTexture, o, l, a, r.rotated ? 2 : 0, r.anchor), B.addToCache(this.textures[i], i)
            }
            t++
        }
    }

    _processAnimations() {
        const e = this.data.animations || {};
        for (const t in e) {
            this.animations[t] = [];
            for (let s = 0; s < e[t].length; s++) {
                const i = e[t][s];
                this.animations[t].push(this.textures[i])
            }
        }
    }

    _parseComplete() {
        const e = this._callback;
        this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
    }

    _nextBatch() {
        this._processFrames(this._batchIndex * As.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
            this._batchIndex * As.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
        }, 0)
    }

    destroy(e = !1) {
        var t;
        for (const s in this.textures) this.textures[s].destroy();
        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((t = this._texture) == null || t.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = []
    }
};
let wi = As;
wi.BATCH_SIZE = 1e3;
const kp = ["jpg", "png", "jpeg", "avif", "webp"];

function hh(e, t, s) {
    const i = {};
    if (e.forEach(r => {
        i[r] = t
    }), Object.keys(t.textures).forEach(r => {
        i[r] = t.textures[r]
    }), !s) {
        const r = ft.dirname(e[0]);
        t.linkedSheets.forEach((n, o) => {
            const a = hh([`${r}/${t.data.meta.related_multi_packs[o]}`], n, !0);
            Object.assign(i, a)
        })
    }
    return i
}

const lh = {
    extension: I.Asset,
    cache: {test: e => e instanceof wi, getCacheableAssets: (e, t) => hh(e, t, !1)},
    resolver: {
        test: e => {
            const s = e.split("?")[0].split("."), i = s.pop(), r = s.pop();
            return i === "json" && kp.includes(r)
        }, parse: e => {
            var s, i;
            const t = e.split(".");
            return {
                resolution: parseFloat((i = (s = M.RETINA_PREFIX.exec(e)) == null ? void 0 : s[1]) != null ? i : "1"),
                format: t[t.length - 2],
                src: e
            }
        }
    },
    loader: {
        extension: {type: I.LoadParser, priority: Xt.Normal}, async testParse(e, t) {
            return ft.extname(t.src).toLowerCase() === ".json" && !!e.frames
        }, async parse(e, t, s) {
            var l, c;
            let i = ft.dirname(t.src);
            i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
            let r = i + e.meta.image;
            r = pi(r, t.src);
            const o = (await s.load([r]))[r], a = new wi(o.baseTexture, e, t.src);
            await a.parse();
            const h = (l = e == null ? void 0 : e.meta) == null ? void 0 : l.related_multi_packs;
            if (Array.isArray(h)) {
                const u = [];
                for (const f of h) {
                    if (typeof f != "string") continue;
                    let p = i + f;
                    (c = t.data) != null && c.ignoreMultiPack || (p = pi(p, t.src), u.push(s.load({
                        src: p,
                        data: {ignoreMultiPack: !0}
                    })))
                }
                const d = await Promise.all(u);
                a.linkedSheets = d, d.forEach(f => {
                    f.linkedSheets = [a].concat(a.linkedSheets.filter(p => p !== f))
                })
            }
            return a
        }, unload(e) {
            e.destroy(!0)
        }
    }
};
O.add(lh);

class Ss {
    constructor() {
        this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
    }
}

class Rs {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }

    static parse(t) {
        const s = t.match(/^[a-z]+\s+.+$/gm),
            i = {info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: []};
        for (const n in s) {
            const o = s[n].match(/^[a-z]+/gm)[0], a = s[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), h = {};
            for (const l in a) {
                const c = a[l].split("="), u = c[0], d = c[1].replace(/"/gm, ""), f = parseFloat(d),
                    p = isNaN(f) ? d : f;
                h[u] = p
            }
            i[o].push(h)
        }
        const r = new Ss;
        return i.info.forEach(n => r.info.push({
            face: n.face,
            size: parseInt(n.size, 10)
        })), i.common.forEach(n => r.common.push({lineHeight: parseInt(n.lineHeight, 10)})), i.page.forEach(n => r.page.push({
            id: parseInt(n.id, 10),
            file: n.file
        })), i.char.forEach(n => r.char.push({
            id: parseInt(n.id, 10),
            page: parseInt(n.page, 10),
            x: parseInt(n.x, 10),
            y: parseInt(n.y, 10),
            width: parseInt(n.width, 10),
            height: parseInt(n.height, 10),
            xoffset: parseInt(n.xoffset, 10),
            yoffset: parseInt(n.yoffset, 10),
            xadvance: parseInt(n.xadvance, 10)
        })), i.kerning.forEach(n => r.kerning.push({
            first: parseInt(n.first, 10),
            second: parseInt(n.second, 10),
            amount: parseInt(n.amount, 10)
        })), i.distanceField.forEach(n => r.distanceField.push({
            distanceRange: parseInt(n.distanceRange, 10),
            fieldType: n.fieldType
        })), r
    }
}

class Ai {
    static test(t) {
        const s = t;
        return "getElementsByTagName" in s && s.getElementsByTagName("page").length && s.getElementsByTagName("info")[0].getAttribute("face") !== null
    }

    static parse(t) {
        const s = new Ss, i = t.getElementsByTagName("info"), r = t.getElementsByTagName("common"),
            n = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"),
            a = t.getElementsByTagName("kerning"), h = t.getElementsByTagName("distanceField");
        for (let l = 0; l < i.length; l++) s.info.push({
            face: i[l].getAttribute("face"),
            size: parseInt(i[l].getAttribute("size"), 10)
        });
        for (let l = 0; l < r.length; l++) s.common.push({lineHeight: parseInt(r[l].getAttribute("lineHeight"), 10)});
        for (let l = 0; l < n.length; l++) s.page.push({
            id: parseInt(n[l].getAttribute("id"), 10) || 0,
            file: n[l].getAttribute("file")
        });
        for (let l = 0; l < o.length; l++) {
            const c = o[l];
            s.char.push({
                id: parseInt(c.getAttribute("id"), 10),
                page: parseInt(c.getAttribute("page"), 10) || 0,
                x: parseInt(c.getAttribute("x"), 10),
                y: parseInt(c.getAttribute("y"), 10),
                width: parseInt(c.getAttribute("width"), 10),
                height: parseInt(c.getAttribute("height"), 10),
                xoffset: parseInt(c.getAttribute("xoffset"), 10),
                yoffset: parseInt(c.getAttribute("yoffset"), 10),
                xadvance: parseInt(c.getAttribute("xadvance"), 10)
            })
        }
        for (let l = 0; l < a.length; l++) s.kerning.push({
            first: parseInt(a[l].getAttribute("first"), 10),
            second: parseInt(a[l].getAttribute("second"), 10),
            amount: parseInt(a[l].getAttribute("amount"), 10)
        });
        for (let l = 0; l < h.length; l++) s.distanceField.push({
            fieldType: h[l].getAttribute("fieldType"),
            distanceRange: parseInt(h[l].getAttribute("distanceRange"), 10)
        });
        return s
    }
}

class Si {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? Ai.test(M.ADAPTER.parseXML(t)) : !1
    }

    static parse(t) {
        return Ai.parse(M.ADAPTER.parseXML(t))
    }
}

const Rn = [Rs, Ai, Si];

function ch(e) {
    for (let t = 0; t < Rn.length; t++) if (Rn[t].test(e)) return Rn[t];
    return null
}

function Gp(e, t, s, i, r, n) {
    const o = s.fill;
    if (Array.isArray(o)) {
        if (o.length === 1) return o[0]
    } else return o;
    let a;
    const h = s.dropShadow ? s.dropShadowDistance : 0, l = s.padding || 0, c = e.width / i - h - l * 2,
        u = e.height / i - h - l * 2, d = o.slice(), f = s.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let _ = 1; _ < p; ++_) f.push(_ / p)
    }
    if (d.unshift(o[0]), f.unshift(0), d.push(o[o.length - 1]), f.push(1), s.fillGradientType === Ts.LINEAR_VERTICAL) {
        a = t.createLinearGradient(c / 2, l, c / 2, u + l);
        let p = 0;
        const m = (n.fontProperties.fontSize + s.strokeThickness) / u;
        for (let x = 0; x < r.length; x++) {
            const y = n.lineHeight * x;
            for (let g = 0; g < d.length; g++) {
                let v = 0;
                typeof f[g] == "number" ? v = f[g] : v = g / d.length;
                const A = y / u + v * m;
                let P = Math.max(p, A);
                P = Math.min(P, 1), a.addColorStop(P, d[g]), p = P
            }
        }
    } else {
        a = t.createLinearGradient(l, u / 2, c + l, u / 2);
        const p = d.length + 1;
        let _ = 1;
        for (let m = 0; m < d.length; m++) {
            let x;
            typeof f[m] == "number" ? x = f[m] : x = _ / p, a.addColorStop(x, d[m]), _++
        }
    }
    return a
}

function Hp(e, t, s, i, r, n, o) {
    const a = s.text, h = s.fontProperties;
    t.translate(i, r), t.scale(n, n);
    const l = o.strokeThickness / 2, c = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(), t.lineWidth = o.strokeThickness, t.textBaseline = o.textBaseline, t.lineJoin = o.lineJoin, t.miterLimit = o.miterLimit, t.fillStyle = Gp(e, t, o, n, [a], s), t.strokeStyle = o.stroke, o.dropShadow) {
        const u = o.dropShadowColor, d = xe(typeof u == "number" ? u : Gs(u)), f = o.dropShadowBlur * n,
            p = o.dropShadowDistance * n;
        t.shadowColor = `rgba(${d[0] * 255},${d[1] * 255},${d[2] * 255},${o.dropShadowAlpha})`, t.shadowBlur = f, t.shadowOffsetX = Math.cos(o.dropShadowAngle) * p, t.shadowOffsetY = Math.sin(o.dropShadowAngle) * p
    } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, l, c + s.lineHeight - h.descent), o.fill && t.fillText(a, l, c + s.lineHeight - h.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)"
}

function Ri(e) {
    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
}

function uh(e) {
    return Array.from ? Array.from(e) : e.split("")
}

function Xp(e) {
    typeof e == "string" && (e = [e]);
    const t = [];
    for (let s = 0, i = e.length; s < i; s++) {
        const r = e[s];
        if (Array.isArray(r)) {
            if (r.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
            const n = r[0].charCodeAt(0), o = r[1].charCodeAt(0);
            if (o < n) throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = n, h = o; a <= h; a++) t.push(String.fromCharCode(a))
        } else t.push(...uh(r))
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}

const zt = class {
    constructor(e, t, s) {
        var l, c;
        const [i] = e.info, [r] = e.common, [n] = e.page, [o] = e.distanceField, a = ee(n.file), h = {};
        this._ownsTextures = s, this.font = i.face, this.size = i.size, this.lineHeight = r.lineHeight / a, this.chars = {}, this.pageTextures = h;
        for (let u = 0; u < e.page.length; u++) {
            const {id: d, file: f} = e.page[u];
            h[d] = t instanceof Array ? t[u] : t[f], (o == null ? void 0 : o.fieldType) && o.fieldType !== "none" && (h[d].baseTexture.alphaMode = Ct.NO_PREMULTIPLIED_ALPHA, h[d].baseTexture.mipmap = Lt.OFF)
        }
        for (let u = 0; u < e.char.length; u++) {
            const {id: d, page: f} = e.char[u];
            let {x: p, y: _, width: m, height: x, xoffset: y, yoffset: g, xadvance: v} = e.char[u];
            p /= a, _ /= a, m /= a, x /= a, y /= a, g /= a, v /= a;
            const A = new z(p + h[f].frame.x / a, _ + h[f].frame.y / a, m, x);
            this.chars[d] = {
                xOffset: y,
                yOffset: g,
                xAdvance: v,
                kerning: {},
                texture: new B(h[f].baseTexture, A),
                page: f
            }
        }
        for (let u = 0; u < e.kerning.length; u++) {
            let {first: d, second: f, amount: p} = e.kerning[u];
            d /= a, f /= a, p /= a, this.chars[f] && (this.chars[f].kerning[d] = p)
        }
        this.distanceFieldRange = o == null ? void 0 : o.distanceRange, this.distanceFieldType = (c = (l = o == null ? void 0 : o.fieldType) == null ? void 0 : l.toLowerCase()) != null ? c : "none"
    }

    destroy() {
        for (const e in this.chars) this.chars[e].texture.destroy(), this.chars[e].texture = null;
        for (const e in this.pageTextures) this._ownsTextures && this.pageTextures[e].destroy(!0), this.pageTextures[e] = null;
        this.chars = null, this.pageTextures = null
    }

    static install(e, t, s) {
        let i;
        if (e instanceof Ss) i = e; else {
            const n = ch(e);
            if (!n) throw new Error("Unrecognized data format for font.");
            i = n.parse(e)
        }
        t instanceof B && (t = [t]);
        const r = new zt(i, t, s);
        return zt.available[r.font] = r, r
    }

    static uninstall(e) {
        const t = zt.available[e];
        if (!t) throw new Error(`No font found named '${e}'`);
        t.destroy(), delete zt.available[e]
    }

    static from(e, t, s) {
        if (!e) throw new Error("[BitmapFont] Property `name` is required.");
        const P = Object.assign({}, zt.defaultOptions, s), {
                chars: i,
                padding: r,
                resolution: n,
                textureWidth: o,
                textureHeight: a
            } = P, h = Li(P, ["chars", "padding", "resolution", "textureWidth", "textureHeight"]), l = Xp(i),
            c = t instanceof fe ? t : new fe(t), u = o, d = new Ss;
        d.info[0] = {face: c.fontFamily, size: c.fontSize}, d.common[0] = {lineHeight: c.fontSize};
        let f = 0, p = 0, _, m, x, y = 0;
        const g = [], v = [];
        for (let S = 0; S < l.length; S++) {
            _ || (_ = M.ADAPTER.createCanvas(), _.width = o, _.height = a, m = _.getContext("2d"), x = new X(_, Yt({resolution: n}, h)), g.push(x), v.push(new B(x)), d.page.push({
                id: v.length - 1,
                file: ""
            }));
            const b = l[S], L = _t.measureText(b, c, !1, _), G = L.width, C = Math.ceil(L.height),
                F = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * G);
            if (p >= a - C * n) {
                if (p === 0) throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${b}')`);
                --S, _ = null, m = null, x = null, p = 0, f = 0, y = 0;
                continue
            }
            if (y = Math.max(C + L.fontProperties.descent, y), F * n + f >= u) {
                if (f === 0) throw new Error(`[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${b}')`);
                --S, p += y * n, p = Math.ceil(p), f = 0, y = 0;
                continue
            }
            Hp(_, m, L, f, p, n, c);
            const E = Ri(L.text);
            d.char.push({
                id: E,
                page: v.length - 1,
                x: f / n,
                y: p / n,
                width: F,
                height: C,
                xoffset: 0,
                yoffset: 0,
                xadvance: G - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0)
            }), f += (F + 2 * r) * n, f = Math.ceil(f)
        }
        for (let S = 0, b = l.length; S < b; S++) {
            const L = l[S];
            for (let G = 0; G < b; G++) {
                const C = l[G], F = m.measureText(L).width, E = m.measureText(C).width,
                    V = m.measureText(L + C).width - (F + E);
                V && d.kerning.push({first: Ri(L), second: Ri(C), amount: V})
            }
        }
        const A = new zt(d, v, !0);
        return zt.available[e] !== void 0 && zt.uninstall(e), zt.available[e] = A, A
    }
};
let yt = zt;
yt.ALPHA = [["a", "z"], ["A", "Z"], " "], yt.NUMERIC = [["0", "9"]], yt.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], yt.ASCII = [[" ", "~"]], yt.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: zt.ALPHANUMERIC
}, yt.available = {};
var Vp = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, zp = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const dh = [], fh = [], ph = [], mh = class extends bt {
    constructor(e, t = {}) {
        super(), this._tint = 16777215;
        const {
            align: s,
            tint: i,
            maxWidth: r,
            letterSpacing: n,
            fontName: o,
            fontSize: a
        } = Object.assign({}, mh.styleDefaults, t);
        if (!yt.available[o]) throw new Error(`Missing BitmapFont "${o}"`);
        this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = s, this._tint = i, this._font = void 0, this._fontName = o, this._fontSize = a, this.text = e, this._maxWidth = r, this._maxLineHeight = 0, this._letterSpacing = n, this._anchor = new ne(() => {
            this.dirty = !0
        }, this, 0, 0), this._roundPixels = M.ROUND_PIXELS, this.dirty = !0, this._resolution = M.RESOLUTION, this._autoResolution = !0, this._textureCache = {}
    }

    updateText() {
        var G;
        const e = yt.available[this._fontName], t = this.fontSize, s = t / e.size, i = new j, r = [], n = [], o = [],
            a = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", h = uh(a), l = this._maxWidth * e.size / t, c = e.distanceFieldType === "none" ? dh : fh;
        let u = null, d = 0, f = 0, p = 0, _ = -1, m = 0, x = 0, y = 0, g = 0;
        for (let C = 0; C < h.length; C++) {
            const F = h[C], E = Ri(F);
            if (/(?:\s)/.test(F) && (_ = C, m = d, g++), F === "\r" || F === `
`) {
                n.push(d), o.push(-1), f = Math.max(f, d), ++p, ++x, i.x = 0, i.y += e.lineHeight, u = null, g = 0;
                continue
            }
            const T = e.chars[E];
            if (!T) continue;
            u && T.kerning[u] && (i.x += T.kerning[u]);
            const V = ph.pop() || {texture: B.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new j};
            V.texture = T.texture, V.line = p, V.charCode = E, V.position.x = Math.round(i.x + T.xOffset + this._letterSpacing / 2), V.position.y = Math.round(i.y + T.yOffset), V.prevSpaces = g, r.push(V), d = V.position.x + Math.max(T.xAdvance - T.xOffset, T.texture.orig.width), i.x += T.xAdvance + this._letterSpacing, y = Math.max(y, T.yOffset + T.texture.height), u = E, _ !== -1 && l > 0 && i.x > l && (++x, ve(r, 1 + _ - x, 1 + C - _), C = _, _ = -1, n.push(m), o.push(r.length > 0 ? r[r.length - 1].prevSpaces : 0), f = Math.max(f, m), p++, i.x = 0, i.y += e.lineHeight, u = null, g = 0)
        }
        const v = h[h.length - 1];
        v !== "\r" && v !== `
` && (/(?:\s)/.test(v) && (d = m), n.push(d), f = Math.max(f, d), o.push(-1));
        const A = [];
        for (let C = 0; C <= p; C++) {
            let F = 0;
            this._align === "right" ? F = f - n[C] : this._align === "center" ? F = (f - n[C]) / 2 : this._align === "justify" && (F = o[C] < 0 ? 0 : (f - n[C]) / o[C]), A.push(F)
        }
        const P = r.length, S = {}, b = [], L = this._activePagesMeshData;
        c.push(...L);
        for (let C = 0; C < P; C++) {
            const F = r[C].texture, E = F.baseTexture.uid;
            if (!S[E]) {
                let T = c.pop();
                if (!T) {
                    const W = new ys;
                    let D, q;
                    e.distanceFieldType === "none" ? (D = new je(B.EMPTY), q = k.NORMAL) : (D = new je(B.EMPTY, {
                        program: Pt.from(zp, Vp),
                        uniforms: {uFWidth: 0}
                    }), q = k.NORMAL_NPM);
                    const rt = new Ie(W, D);
                    rt.blendMode = q, T = {
                        index: 0,
                        indexCount: 0,
                        vertexCount: 0,
                        uvsCount: 0,
                        total: 0,
                        mesh: rt,
                        vertices: null,
                        uvs: null,
                        indices: null
                    }
                }
                T.index = 0, T.indexCount = 0, T.vertexCount = 0, T.uvsCount = 0, T.total = 0;
                const {_textureCache: V} = this;
                V[E] = V[E] || new B(F.baseTexture), T.mesh.texture = V[E], T.mesh.tint = this._tint, b.push(T), S[E] = T
            }
            S[E].total++
        }
        for (let C = 0; C < L.length; C++) b.includes(L[C]) || this.removeChild(L[C].mesh);
        for (let C = 0; C < b.length; C++) b[C].mesh.parent !== this && this.addChild(b[C].mesh);
        this._activePagesMeshData = b;
        for (const C in S) {
            const F = S[C], E = F.total;
            if (!(((G = F.indices) == null ? void 0 : G.length) > 6 * E) || F.vertices.length < Ie.BATCHABLE_SIZE * 2) F.vertices = new Float32Array(4 * 2 * E), F.uvs = new Float32Array(4 * 2 * E), F.indices = new Uint16Array(6 * E); else {
                const T = F.total, V = F.vertices;
                for (let W = T * 4 * 2; W < V.length; W++) V[W] = 0
            }
            F.mesh.size = 6 * E
        }
        for (let C = 0; C < P; C++) {
            const F = r[C];
            let E = F.position.x + A[F.line] * (this._align === "justify" ? F.prevSpaces : 1);
            this._roundPixels && (E = Math.round(E));
            const T = E * s, V = F.position.y * s, W = F.texture, D = S[W.baseTexture.uid], q = W.frame, rt = W._uvs,
                w = D.index++;
            D.indices[w * 6 + 0] = 0 + w * 4, D.indices[w * 6 + 1] = 1 + w * 4, D.indices[w * 6 + 2] = 2 + w * 4, D.indices[w * 6 + 3] = 0 + w * 4, D.indices[w * 6 + 4] = 2 + w * 4, D.indices[w * 6 + 5] = 3 + w * 4, D.vertices[w * 8 + 0] = T, D.vertices[w * 8 + 1] = V, D.vertices[w * 8 + 2] = T + q.width * s, D.vertices[w * 8 + 3] = V, D.vertices[w * 8 + 4] = T + q.width * s, D.vertices[w * 8 + 5] = V + q.height * s, D.vertices[w * 8 + 6] = T, D.vertices[w * 8 + 7] = V + q.height * s, D.uvs[w * 8 + 0] = rt.x0, D.uvs[w * 8 + 1] = rt.y0, D.uvs[w * 8 + 2] = rt.x1, D.uvs[w * 8 + 3] = rt.y1, D.uvs[w * 8 + 4] = rt.x2, D.uvs[w * 8 + 5] = rt.y2, D.uvs[w * 8 + 6] = rt.x3, D.uvs[w * 8 + 7] = rt.y3
        }
        this._textWidth = f * s, this._textHeight = (i.y + e.lineHeight) * s;
        for (const C in S) {
            const F = S[C];
            if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                let W = 0;
                const D = this._textWidth * this.anchor.x, q = this._textHeight * this.anchor.y;
                for (let rt = 0; rt < F.total; rt++) F.vertices[W++] -= D, F.vertices[W++] -= q, F.vertices[W++] -= D, F.vertices[W++] -= q, F.vertices[W++] -= D, F.vertices[W++] -= q, F.vertices[W++] -= D, F.vertices[W++] -= q
            }
            this._maxLineHeight = y * s;
            const E = F.mesh.geometry.getBuffer("aVertexPosition"), T = F.mesh.geometry.getBuffer("aTextureCoord"),
                V = F.mesh.geometry.getIndex();
            E.data = F.vertices, T.data = F.uvs, V.data = F.indices, E.update(), T.update(), V.update()
        }
        for (let C = 0; C < r.length; C++) ph.push(r[C]);
        this._font = e, this.dirty = !1
    }

    updateTransform() {
        this.validate(), this.containerUpdateTransform()
    }

    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
        const {distanceFieldRange: t, distanceFieldType: s, size: i} = yt.available[this._fontName];
        if (s !== "none") {
            const {a: r, b: n, c: o, d: a} = this.worldTransform, h = Math.sqrt(r * r + n * n),
                l = Math.sqrt(o * o + a * a), c = (Math.abs(h) + Math.abs(l)) / 2, u = this.fontSize / i,
                d = e._view.resolution;
            for (const f of this._activePagesMeshData) f.mesh.shader.uniforms.uFWidth = c * t * u * d
        }
        super._render(e)
    }

    getLocalBounds() {
        return this.validate(), super.getLocalBounds()
    }

    validate() {
        const e = yt.available[this._fontName];
        if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== e && (this.dirty = !0), this.dirty && this.updateText()
    }

    get tint() {
        return this._tint
    }

    set tint(e) {
        if (this._tint !== e) {
            this._tint = e;
            for (let t = 0; t < this._activePagesMeshData.length; t++) this._activePagesMeshData[t].mesh.tint = e
        }
    }

    get align() {
        return this._align
    }

    set align(e) {
        this._align !== e && (this._align = e, this.dirty = !0)
    }

    get fontName() {
        return this._fontName
    }

    set fontName(e) {
        if (!yt.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
        this._fontName !== e && (this._fontName = e, this.dirty = !0)
    }

    get fontSize() {
        var e;
        return (e = this._fontSize) != null ? e : yt.available[this._fontName].size
    }

    set fontSize(e) {
        this._fontSize !== e && (this._fontSize = e, this.dirty = !0)
    }

    get anchor() {
        return this._anchor
    }

    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }

    get text() {
        return this._text
    }

    set text(e) {
        e = String(e == null ? "" : e), this._text !== e && (this._text = e, this.dirty = !0)
    }

    get maxWidth() {
        return this._maxWidth
    }

    set maxWidth(e) {
        this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0)
    }

    get maxLineHeight() {
        return this.validate(), this._maxLineHeight
    }

    get textWidth() {
        return this.validate(), this._textWidth
    }

    get letterSpacing() {
        return this._letterSpacing
    }

    set letterSpacing(e) {
        this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0)
    }

    get roundPixels() {
        return this._roundPixels
    }

    set roundPixels(e) {
        e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0)
    }

    get textHeight() {
        return this.validate(), this._textHeight
    }

    get resolution() {
        return this._resolution
    }

    set resolution(e) {
        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
    }

    destroy(e) {
        const {_textureCache: t} = this, i = yt.available[this._fontName].distanceFieldType === "none" ? dh : fh;
        i.push(...this._activePagesMeshData);
        for (const r of this._activePagesMeshData) this.removeChild(r.mesh);
        this._activePagesMeshData = [], i.filter(r => t[r.mesh.texture.baseTexture.uid]).forEach(r => {
            r.mesh.texture = B.EMPTY
        });
        for (const r in t) t[r].destroy(), delete t[r];
        this._font = null, this._textureCache = null, super.destroy(e)
    }
};
let _h = mh;
_h.styleDefaults = {align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0};
const Wp = [".xml", ".fnt"], gh = {
    extension: {type: I.LoadParser, priority: Xt.Normal}, test(e) {
        return Wp.includes(ft.extname(e).toLowerCase())
    }, async testParse(e) {
        return Rs.test(e) || Si.test(e)
    }, async parse(e, t, s) {
        const i = Rs.test(e) ? Rs.parse(e) : Si.parse(e), {src: r} = t, {page: n} = i, o = [];
        for (let l = 0; l < n.length; ++l) {
            const c = n[l].file;
            let u = ft.join(ft.dirname(r), c);
            u = pi(u, r), o.push(u)
        }
        const a = await s.load(o), h = o.map(l => a[l]);
        return yt.install(i, h, !0)
    }, async load(e, t) {
        return (await M.ADAPTER.fetch(e)).text()
    }, unload(e) {
        e.destroy()
    }
};
O.add(gh);
export {
    Ct as ALPHA_MODES,
    Yr as AbstractMultiResource,
    en as AccessibilityManager,
    ra as AlphaFilter,
    Fi as AnimatedSprite,
    rn as Application,
    ta as ArrayResource,
    ms as Assets,
    Aa as AssetsClass,
    Cs as Attribute,
    k as BLEND_MODES,
    Bs as BUFFER_BITS,
    Ut as BUFFER_TYPE,
    pr as BackgroundSystem,
    se as BaseImageResource,
    Es as BasePrepare,
    gr as BaseRenderTexture,
    X as BaseTexture,
    $s as BatchDrawCall,
    ur as BatchGeometry,
    Mt as BatchRenderer,
    Bo as BatchShaderGenerator,
    mr as BatchSystem,
    Js as BatchTextureArray,
    yt as BitmapFont,
    Ss as BitmapFontData,
    _h as BitmapText,
    Fa as BlobResource,
    na as BlurFilter,
    ci as BlurFilterPass,
    ls as Bounds,
    Fn as BrowserAdapter,
    nt as Buffer,
    Oe as BufferResource,
    Wr as BufferSystem,
    Ot as CLEAR_MODES,
    Dn as COLOR_MASK_BITS,
    Xe as Cache,
    ea as CanvasResource,
    Ci as Circle,
    ui as ColorMatrixFilter,
    me as CompressedTextureResource,
    bt as Container,
    _r as ContextSystem,
    rh as CountLimiter,
    qr as CubeResource,
    vo as DEG_TO_RAD,
    Nt as DRAW_MODES,
    oa as DisplacementFilter,
    et as DisplayObject,
    he as ENV,
    Ii as Ellipse,
    la as EventBoundary,
    tn as EventSystem,
    I as ExtensionType,
    fn as Extract,
    R as FORMATS,
    Ua as FORMATS_TO_COMPONENTS,
    aa as FXAAFilter,
    ca as FederatedDisplayObject,
    $e as FederatedEvent,
    us as FederatedMouseEvent,
    Dt as FederatedPointerEvent,
    di as FederatedWheelEvent,
    Ps as FillStyle,
    mt as Filter,
    Lo as FilterState,
    Er as FilterSystem,
    ti as Framebuffer,
    wr as FramebufferSystem,
    Fs as GC_MODES,
    Oo as GLFramebuffer,
    zo as GLProgram,
    ai as GLTexture,
    lp as GRAPHICS_CURVES,
    Br as GenerateTextureSystem,
    ae as Geometry,
    Sr as GeometrySystem,
    vs as Graphics,
    Is as GraphicsData,
    xn as GraphicsGeometry,
    Fd as IGLUniformData,
    js as INSTALLED,
    Et as INTERNAL_FORMATS,
    _s as INTERNAL_FORMAT_TO_BYTES_PER_PIXEL,
    Me as ImageBitmapResource,
    xr as ImageResource,
    ue as LINE_CAP,
    re as LINE_JOIN,
    Di as LineStyle,
    Xt as LoaderParserPriority,
    ht as MASK_TYPES,
    Lt as MIPMAP_MODES,
    st as MSAA_QUALITY,
    Go as MaskData,
    Rr as MaskSystem,
    Q as Matrix,
    Ie as Mesh,
    Ka as MeshBatchUvs,
    ys as MeshGeometry,
    je as MeshMaterial,
    zr as MultisampleSystem,
    _p as NineSlicePlane,
    ha as NoiseFilter,
    ns as ObjectRenderer,
    jr as ObjectRendererSystem,
    ne as ObservablePoint,
    ss as PI_2,
    wt as PRECISION,
    vp as ParticleContainer,
    Tn as ParticleRenderer,
    Ja as PlaneGeometry,
    Pr as PluginSystem,
    j as Point,
    Pe as Polygon,
    An as Prepare,
    Pt as Program,
    Mr as ProjectionSystem,
    No as Quad,
    Tr as QuadUv,
    xo as RAD_TO_DEG,
    Bn as RENDERER_TYPE,
    z as Rectangle,
    oe as RenderTexture,
    yr as RenderTexturePool,
    Dr as RenderTextureSystem,
    Re as Renderer,
    nn as ResizePlugin,
    Le as Resource,
    th as RopeGeometry,
    Pi as RoundedRectangle,
    St as Runner,
    Ds as SAMPLER_TYPES,
    qt as SCALE_MODES,
    pt as SHAPES,
    He as SVGResource,
    Cr as ScissorSystem,
    Wt as Shader,
    Fr as ShaderSystem,
    gp as SimpleMesh,
    eh as SimplePlane,
    xp as SimpleRope,
    pe as Sprite,
    ko as SpriteMaskFilter,
    wi as Spritesheet,
    Nr as StartupSystem,
    Jt as State,
    Or as StateSystem,
    Ir as StencilSystem,
    Ko as SystemManager,
    _e as TARGETS,
    Ts as TEXT_GRADIENT,
    U as TYPES,
    un as TYPES_TO_BYTES_PER_COMPONENT,
    ka as TYPES_TO_BYTES_PER_PIXEL,
    sa as TemporaryDisplayObject,
    bi as Text,
    Rs as TextFormat,
    _t as TextMetrics,
    fe as TextStyle,
    B as Texture,
    Bt as TextureGCSystem,
    ii as TextureMatrix,
    Ur as TextureSystem,
    vr as TextureUvs,
    ct as Ticker,
    Xr as TickerPlugin,
    Cn as TilingSprite,
    Sn as TilingSpriteRenderer,
    Fp as TimeLimiter,
    is as Transform,
    Zd as TransformFeedback,
    kr as TransformFeedbackSystem,
    ce as UPDATE_PRIORITY,
    Ft as UniformGroup,
    Qd as VERSION,
    li as VideoResource,
    Gr as ViewSystem,
    Ws as ViewableBuffer,
    Kt as WRAP_MODES,
    Ai as XMLFormat,
    Si as XMLStringFormat,
    ua as accessibleTarget,
    ch as autoDetectFormat,
    Qo as autoDetectRenderer,
    cr as autoDetectResource,
    Sa as cacheTextureArray,
    on as checkDataUrl,
    ds as checkExtension,
    _o as checkMaxIfStatementsInShader,
    Qt as convertToList,
    pi as copySearchParams,
    _a as createStringVariations,
    ps as createTexture,
    $o as createUBOElements,
    de as curves,
    Vr as defaultFilterVertex,
    Jo as defaultVertex,
    Ra as detectAvif,
    Da as detectCompressedTextures,
    Pa as detectDefaults,
    Ca as detectWebp,
    O as extensions,
    Qr as filters,
    Wo as generateProgram,
    qo as generateUniformBufferSync,
    va as getFontFamilyName,
    Ao as getTestContext,
    Yo as getUBOData,
    fp as graphicsUtils,
    tt as groupD8,
    kt as isMobile,
    fs as isSingleItem,
    gh as loadBitmapFont,
    Ha as loadDDS,
    Ea as loadImageBitmap,
    ga as loadJson,
    Xa as loadKTX,
    wa as loadSVG,
    Ve as loadTextures,
    xa as loadTxt,
    ya as loadWebFont,
    La as parseDDS,
    Ga as parseKTX,
    Va as resolveCompressedTextureUrl,
    Ma as resolveTextureUrl,
    M as settings,
    lh as spritesheetAsset,
    Ae as uniformParsers,
    Mo as unsafeEvalSupported,
    id as utils
};
//# sourceMappingURL=pixi.min.mjs.map